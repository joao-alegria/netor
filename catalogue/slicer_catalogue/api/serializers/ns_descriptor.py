# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__


class additional_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module additional-info - based on the path /additional-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module alarm - based on the path /alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class alternative_images(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module alternative-images - based on the path /alternative-images. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class cloud_init(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cloud-init - based on the path /cloud-init. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class common_augments(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module common-augments - based on the path /common-augments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class day1_2(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module day1-2 - based on the path /day1-2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module epa - based on the path /epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module interface - based on the path /interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ip_profiles(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ip-profiles - based on the path /ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class kdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module kdu - based on the path /kdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class mgmt_interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mgmt-interface - based on the path /mgmt-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-configuration - based on the path /ns-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_various(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-various - based on the path /ns-various. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_vld(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-vld - based on the path /ns-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class scaling(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module scaling - based on the path /scaling. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class various(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module various - based on the path /various. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class vip(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vip - based on the path /vip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/virtual-network-interface-requirement/network-interface-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'network-interface-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement',
                    'network-interface-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/virtual-network-interface-requirement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__description', '__support_mandatory',
                 '__network_interface_requirements',)

    _yang_name = 'virtual-network-interface-requirement'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                             defining_module='etsi-nfv-nsd', yang_type='list',
                                                             is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/support_mandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_network_interface_requirements(self):
        """
    Getter method for network_interface_requirements, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements (list)

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        return self.__network_interface_requirements

    def _set_network_interface_requirements(self, v, load=False):
        """
    Setter method for network_interface_requirements, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_interface_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_interface_requirements() directly.

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                  yang_name="network-interface-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="network-interface-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_interface_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements, yang_name="network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__network_interface_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_interface_requirements(self):
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                             defining_module='etsi-nfv-nsd', yang_type='list',
                                                             is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    network_interface_requirements = __builtin__.property(_get_network_interface_requirements,
                                                          _set_network_interface_requirements)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('description', description), ('support_mandatory', support_mandatory),
         ('network_interface_requirements', network_interface_requirements), ])


class yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l2_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/protocol/address-data/l2-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
  """
    __slots__ = ('_path_helper', '_extmethods', '__mac_address_assignment',)

    _yang_name = 'l2-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data', 'l2-address-data']

    def _get_mac_address_assignment(self):
        """
    Getter method for mac_address_assignment, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        return self.__mac_address_assignment

    def _set_mac_address_assignment(self, v, load=False):
        """
    Setter method for mac_address_assignment, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_assignment() directly.

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__mac_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address_assignment(self):
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

    mac_address_assignment = __builtin__.property(_get_mac_address_assignment, _set_mac_address_assignment)

    _pyangbind_elements = OrderedDict([('mac_address_assignment', mac_address_assignment), ])


class yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l3_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/protocol/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__ip_address_assignment', '__floating_ip_activated', '__ip_address_type',
        '__number_of_ip_addresses',)

    _yang_name = 'l3-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data', 'l3-address-data']

    def _get_ip_address_assignment(self):
        """
    Getter method for ip_address_assignment, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
    Setter method for ip_address_assignment, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__ip_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_floating_ip_activated(self):
        """
    Getter method for floating_ip_activated, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
    Setter method for floating_ip_activated, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_activated must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_activated = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_ip_address_type(self):
        """
    Getter method for ip_address_type, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
    Setter method for ip_address_type, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
                             yang_name="ip-address-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_address_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)

    def _get_number_of_ip_addresses(self):
        """
    Getter method for number_of_ip_addresses, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
    Setter method for number_of_ip_addresses, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="number-of-ip-addresses",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_ip_addresses = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
    floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)

    _pyangbind_elements = OrderedDict(
        [('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated),
         ('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ])


class yc_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/protocol/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__l2_address_data', '__l3_address_data',)

    _yang_name = 'address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/type (identityref)

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_l2_address_data(self):
        """
    Getter method for l2_address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l2_address_data (container)

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
    Setter method for l2_address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l2_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
                             is_container='container', yang_name="l2-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l2_address_data, is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l2_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_l3_address_data(self):
        """
    Getter method for l3_address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data (container)
    """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
    Setter method for l3_address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
                             is_container='container', yang_name="l3-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l3_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [('type', type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_protocol_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
  """
    __slots__ = ('_path_helper', '_extmethods', '__associated_layer_protocol', '__address_data',)

    _yang_name = 'protocol'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd', 'protocol']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)

    def _get_address_data(self):
        """
    Getter method for address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
    Setter method for address_data, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("type",
                                                  yc_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data,
                                                  yang_name="address-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='type',
                                                  extensions=None), is_container='list', yang_name="address-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("type",yc_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('address_data', address_data), ])


class yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/int-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
  """
    __slots__ = ('_path_helper', '_extmethods', '__int_virtual_link_desc', '__bitrate_requirement',
                 '__virtual_network_interface_requirement', '__nicio_requirements', '__order', '__id',
                 '__layer_protocol', '__role', '__description', '__protocol', '__trunk_mode',
                 '__security_group_rule_id',)

    _yang_name = 'int-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__bitrate_requirement = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                    defining_module='etsi-nfv-nsd', yang_type='list',
                                                                    is_config=True)
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__order = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                             int_size=32)), is_leaf=False, yang_name="order", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='uint32', is_config=True)
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'int-cpd']

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/int_virtual_link_desc (leafref)

    YANG Description: Reference of the internal VLD which this internal CPD
connects to.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/int_virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Reference of the internal VLD which this internal CPD
connects to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_bitrate_requirement(self):
        """
    Getter method for bitrate_requirement, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/bitrate_requirement (uint64)

    YANG Description: Bitrate requirement on this CP.
    """
        return self.__bitrate_requirement

    def _set_bitrate_requirement(self, v, load=False):
        """
    Setter method for bitrate_requirement, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/bitrate_requirement (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bitrate_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bitrate_requirement() directly.

    YANG Description: Bitrate requirement on this CP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="bitrate-requirement",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """bitrate_requirement must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__bitrate_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_bitrate_requirement(self):
        self.__bitrate_requirement = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_virtual_network_interface_requirement(self):
        """
    Getter method for virtual_network_interface_requirement, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement (list)

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        return self.__virtual_network_interface_requirement

    def _set_virtual_network_interface_requirement(self, v, load=False):
        """
    Setter method for virtual_network_interface_requirement, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/virtual_network_interface_requirement (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_interface_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_interface_requirement() directly.

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                  yang_name="virtual-network-interface-requirement", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="virtual-network-interface-requirement", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_network_interface_requirement must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement, yang_name="virtual-network-interface-requirement", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_network_interface_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_network_interface_requirement(self):
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                    defining_module='etsi-nfv-nsd', yang_type='list',
                                                                    is_config=True)

    def _get_nicio_requirements(self):
        """
    Getter method for nicio_requirements, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/nicio_requirements (leafref)

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        return self.__nicio_requirements

    def _set_nicio_requirements(self, v, load=False):
        """
    Setter method for nicio_requirements, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/nicio_requirements (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nicio_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nicio_requirements() directly.

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nicio_requirements must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nicio_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nicio_requirements(self):
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_order(self):
        """
    Getter method for order, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/order (uint32)

    YANG Description: The order of the NIC to be assigned on the compute
instance (e.g. 2 for eth2).

Note: when binding more than one port to a single
compute (aka multi vNICs) and ordering is desired, it
is mandatory that all ports will be set with an order
value. The order values shall represent a positive,
arithmetic progression that starts with 0 (i.e. 0, 1,
2,..., n).

If the property is not present, it shall be left to the
VIM to assign a value when creating the instance.
    """
        return self.__order

    def _set_order(self, v, load=False):
        """
    Setter method for order, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/order (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.

    YANG Description: The order of the NIC to be assigned on the compute
instance (e.g. 2 for eth2).

Note: when binding more than one port to a single
compute (aka multi vNICs) and ordering is desired, it
is mandatory that all ports will be set with an order
value. The order values shall represent a positive,
arithmetic progression that starts with 0 (i.e. 0, 1,
2,..., n).

If the property is not present, it shall be left to the
VIM to assign a value when creating the instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                 int_size=32)), is_leaf=False, yang_name="order", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """order must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__order = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_order(self):
        self.__order = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                             int_size=32)), is_leaf=False, yang_name="order", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='uint32', is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/layer_protocol (identityref)

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)

    def _get_role(self):
        """
    Getter method for role, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/role (identityref)

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        return self.__role

    def _set_role(self, v, load=False):
        """
    Setter method for role, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """role must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__role = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_role(self):
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol (list)

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("associated_layer_protocol",
                                                  yc_protocol_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol,
                                                  yang_name="protocol", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='associated-layer-protocol', extensions=None),
                             is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_protocol_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_trunk_mode(self):
        """
    Getter method for trunk_mode, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/trunk_mode (boolean)

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
    Setter method for trunk_mode, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/trunk_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_mode() directly.

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trunk_mode must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__trunk_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_security_group_rule_id(self):
        """
    Getter method for security_group_rule_id, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/security_group_rule_id (leafref)

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        return self.__security_group_rule_id

    def _set_security_group_rule_id(self, v, load=False):
        """
    Setter method for security_group_rule_id, mapped from YANG variable /nsd/vnfd/vdu/int_cpd/security_group_rule_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule_id() directly.

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__security_group_rule_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule_id(self):
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)

    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    bitrate_requirement = __builtin__.property(_get_bitrate_requirement, _set_bitrate_requirement)
    virtual_network_interface_requirement = __builtin__.property(_get_virtual_network_interface_requirement,
                                                                 _set_virtual_network_interface_requirement)
    nicio_requirements = __builtin__.property(_get_nicio_requirements, _set_nicio_requirements)
    order = __builtin__.property(_get_order, _set_order)
    id = __builtin__.property(_get_id, _set_id)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    role = __builtin__.property(_get_role, _set_role)
    description = __builtin__.property(_get_description, _set_description)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)
    security_group_rule_id = __builtin__.property(_get_security_group_rule_id, _set_security_group_rule_id)

    _pyangbind_elements = OrderedDict(
        [('int_virtual_link_desc', int_virtual_link_desc), ('bitrate_requirement', bitrate_requirement),
         ('virtual_network_interface_requirement', virtual_network_interface_requirement),
         ('nicio_requirements', nicio_requirements), ('order', order), ('id', id), ('layer_protocol', layer_protocol),
         ('role', role), ('description', description), ('protocol', protocol), ('trunk_mode', trunk_mode),
         ('security_group_rule_id', security_group_rule_id), ])


class yc_boot_order_etsi_nfv_nsd__nsd_vnfd_vdu_boot_order(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/boot-order. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'boot-order'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'boot-order']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/vdu/boot_order/key (uint32)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/vdu/boot_order/key (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/vdu/boot_order/value (leafref)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/vdu/boot_order/value (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='leafref', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_vdu_monitoring_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/monitoring-parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'monitoring-parameter']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_vdu_configurable_properties(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu/configurable-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'configurable-properties'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu', 'configurable-properties']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_vdu_etsi_nfv_nsd__nsd_vnfd_vdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__description', '__int_cpd', '__virtual_compute_desc',
        '__virtual_storage_desc', '__boot_order', '__sw_image_desc', '__nfvi_constraint', '__monitoring_parameter',
        '__configurable_properties', '__boot_data',)

    _yang_name = 'vdu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__int_cpd = YANGDynClass(
            base=YANGListType("id", yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="int-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__virtual_compute_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__virtual_storage_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="virtual-storage-desc", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__boot_order = YANGDynClass(
            base=YANGListType("key", yc_boot_order_etsi_nfv_nsd__nsd_vnfd_vdu_boot_order, yang_name="boot-order",
                              parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper,
                              yang_keys='key', extensions=None), is_container='list', yang_name="boot-order",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__nfvi_constraint = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="nfvi-constraint", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_vdu_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__configurable_properties = YANGDynClass(
            base=YANGListType("key", yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_vdu_configurable_properties,
                              yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__boot_data = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'vdu']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/vdu/id (string)

    YANG Description: Unique identifier of this VDU in VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/vdu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VDU in VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/vdu/name (string)

    YANG Description: Human readable name of the VDU.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/vdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/vdu/description (string)

    YANG Description: Human readable description of the VDU.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/vdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_int_cpd(self):
        """
    Getter method for int_cpd, mapped from YANG variable /nsd/vnfd/vdu/int_cpd (list)

    YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
    """
        return self.__int_cpd

    def _set_int_cpd(self, v, load=False):
        """
    Setter method for int_cpd, mapped from YANG variable /nsd/vnfd/vdu/int_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_cpd() directly.

    YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd, yang_name="int-cpd",
                                               parent=self, is_container='list', user_ordered=False,
                                               path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="int-cpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_cpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="int-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__int_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_cpd(self):
        self.__int_cpd = YANGDynClass(
            base=YANGListType("id", yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="int-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_virtual_compute_desc(self):
        """
    Getter method for virtual_compute_desc, mapped from YANG variable /nsd/vnfd/vdu/virtual_compute_desc (leafref)

    YANG Description: Describes CPU, Memory and acceleration requirements of
the Virtualisation Container realizing this VDU.
    """
        return self.__virtual_compute_desc

    def _set_virtual_compute_desc(self, v, load=False):
        """
    Setter method for virtual_compute_desc, mapped from YANG variable /nsd/vnfd/vdu/virtual_compute_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_compute_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_compute_desc() directly.

    YANG Description: Describes CPU, Memory and acceleration requirements of
the Virtualisation Container realizing this VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_compute_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_compute_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_compute_desc(self):
        self.__virtual_compute_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_virtual_storage_desc(self):
        """
    Getter method for virtual_storage_desc, mapped from YANG variable /nsd/vnfd/vdu/virtual_storage_desc (leafref)

    YANG Description: Describes storage requirements for a VirtualStorage
instance attached to the virtualisation container
created from virtualComputeDesc defined for this VDU.
    """
        return self.__virtual_storage_desc

    def _set_virtual_storage_desc(self, v, load=False):
        """
    Setter method for virtual_storage_desc, mapped from YANG variable /nsd/vnfd/vdu/virtual_storage_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage_desc() directly.

    YANG Description: Describes storage requirements for a VirtualStorage
instance attached to the virtualisation container
created from virtualComputeDesc defined for this VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_storage_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_storage_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_storage_desc(self):
        self.__virtual_storage_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="virtual-storage-desc", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_boot_order(self):
        """
    Getter method for boot_order, mapped from YANG variable /nsd/vnfd/vdu/boot_order (list)

    YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
    """
        return self.__boot_order

    def _set_boot_order(self, v, load=False):
        """
    Setter method for boot_order, mapped from YANG variable /nsd/vnfd/vdu/boot_order (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_order() directly.

    YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key", yc_boot_order_etsi_nfv_nsd__nsd_vnfd_vdu_boot_order,
                                                  yang_name="boot-order", parent=self, is_container='list',
                                                  user_ordered=True, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="boot-order",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """boot_order must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_boot_order_etsi_nfv_nsd__nsd_vnfd_vdu_boot_order, yang_name="boot-order", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="boot-order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__boot_order = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_boot_order(self):
        self.__boot_order = YANGDynClass(
            base=YANGListType("key", yc_boot_order_etsi_nfv_nsd__nsd_vnfd_vdu_boot_order, yang_name="boot-order",
                              parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper,
                              yang_keys='key', extensions=None), is_container='list', yang_name="boot-order",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/vdu/sw_image_desc (leafref)

    YANG Description: Describes the software image which is directly loaded on
the virtualisation container realising this Vdu.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/vdu/sw_image_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Describes the software image which is directly loaded on
the virtualisation container realising this Vdu.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_nfvi_constraint(self):
        """
    Getter method for nfvi_constraint, mapped from YANG variable /nsd/vnfd/vdu/nfvi_constraint (string)

    YANG Description: Describes constraints on the NFVI for the VNFC
instance(s) created from this Vdu. For example, aspects
of a secure hosting environment for the VNFC instance
that involve additional entities or processes.
    """
        return self.__nfvi_constraint

    def _set_nfvi_constraint(self, v, load=False):
        """
    Setter method for nfvi_constraint, mapped from YANG variable /nsd/vnfd/vdu/nfvi_constraint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nfvi_constraint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nfvi_constraint() directly.

    YANG Description: Describes constraints on the NFVI for the VNFC
instance(s) created from this Vdu. For example, aspects
of a secure hosting environment for the VNFC instance
that involve additional entities or processes.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="nfvi-constraint", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nfvi_constraint must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nfvi-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__nfvi_constraint = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nfvi_constraint(self):
        self.__nfvi_constraint = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="nfvi-constraint", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_monitoring_parameter(self):
        """
    Getter method for monitoring_parameter, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter (list)
    """
        return self.__monitoring_parameter

    def _set_monitoring_parameter(self, v, load=False):
        """
    Setter method for monitoring_parameter, mapped from YANG variable /nsd/vnfd/vdu/monitoring_parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameter() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_vdu_monitoring_parameter,
                                                  yang_name="monitoring-parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_vdu_monitoring_parameter, yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameter(self):
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_vdu_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_configurable_properties(self):
        """
    Getter method for configurable_properties, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties (list)

    YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
    """
        return self.__configurable_properties

    def _set_configurable_properties(self, v, load=False):
        """
    Setter method for configurable_properties, mapped from YANG variable /nsd/vnfd/vdu/configurable_properties (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable_properties() directly.

    YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_vdu_configurable_properties,
                                                  yang_name="configurable-properties", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """configurable_properties must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_vdu_configurable_properties, yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="configurable-properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__configurable_properties = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_configurable_properties(self):
        self.__configurable_properties = YANGDynClass(
            base=YANGListType("key", yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_vdu_configurable_properties,
                              yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_boot_data(self):
        """
    Getter method for boot_data, mapped from YANG variable /nsd/vnfd/vdu/boot_data (string)

    YANG Description: Contains a string or a URL to a file contained in the
VNF package used to customize a virtualised compute
resource at boot time. The bootData may contain variable
parts that are replaced by deployment specific values
before being sent to the VIM.
    """
        return self.__boot_data

    def _set_boot_data(self, v, load=False):
        """
    Setter method for boot_data, mapped from YANG variable /nsd/vnfd/vdu/boot_data (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_data() directly.

    YANG Description: Contains a string or a URL to a file contained in the
VNF package used to customize a virtualised compute
resource at boot time. The bootData may contain variable
parts that are replaced by deployment specific values
before being sent to the VIM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """boot_data must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__boot_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_boot_data(self):
        self.__boot_data = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    int_cpd = __builtin__.property(_get_int_cpd, _set_int_cpd)
    virtual_compute_desc = __builtin__.property(_get_virtual_compute_desc, _set_virtual_compute_desc)
    virtual_storage_desc = __builtin__.property(_get_virtual_storage_desc, _set_virtual_storage_desc)
    boot_order = __builtin__.property(_get_boot_order, _set_boot_order)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)
    nfvi_constraint = __builtin__.property(_get_nfvi_constraint, _set_nfvi_constraint)
    monitoring_parameter = __builtin__.property(_get_monitoring_parameter, _set_monitoring_parameter)
    configurable_properties = __builtin__.property(_get_configurable_properties, _set_configurable_properties)
    boot_data = __builtin__.property(_get_boot_data, _set_boot_data)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('int_cpd', int_cpd),
                                       ('virtual_compute_desc', virtual_compute_desc),
                                       ('virtual_storage_desc', virtual_storage_desc), ('boot_order', boot_order),
                                       ('sw_image_desc', sw_image_desc), ('nfvi_constraint', nfvi_constraint),
                                       ('monitoring_parameter', monitoring_parameter),
                                       ('configurable_properties', configurable_properties),
                                       ('boot_data', boot_data), ])


class yc_requirement_detail_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node_requirement_detail(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/logical-node/requirement-detail. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'requirement-detail'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'logical-node', 'requirement-detail']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_logical_node_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/logical-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__requirement_detail',)

    _yang_name = 'logical-node'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__requirement_detail = YANGDynClass(base=YANGListType("key",
                                                                   yc_requirement_detail_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                                   yang_name="requirement-detail", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper, yang_keys='key',
                                                                   extensions=None), is_container='list',
                                                 yang_name="requirement-detail", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'logical-node']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/id (string)

    YANG Description: Identifies this set of logical node requirements.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies this set of logical node requirements.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_requirement_detail(self):
        """
    Getter method for requirement_detail, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail (list)

    YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
    """
        return self.__requirement_detail

    def _set_requirement_detail(self, v, load=False):
        """
    Setter method for requirement_detail, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node/requirement_detail (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement_detail() directly.

    YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_requirement_detail_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                  yang_name="requirement-detail", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="requirement-detail",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """requirement_detail must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_requirement_detail_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node_requirement_detail, yang_name="requirement-detail", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__requirement_detail = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_requirement_detail(self):
        self.__requirement_detail = YANGDynClass(base=YANGListType("key",
                                                                   yc_requirement_detail_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                                   yang_name="requirement-detail", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper, yang_keys='key',
                                                                   extensions=None), is_container='list',
                                                 yang_name="requirement-detail", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    requirement_detail = __builtin__.property(_get_requirement_detail, _set_requirement_detail)

    _pyangbind_elements = OrderedDict([('id', id), ('requirement_detail', requirement_detail), ])


class yc_target_performance_parameters_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/request-additional-capability/target-performance-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'target-performance-parameters'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'request-additional-capability',
                    'target-performance-parameters']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_request_additional_capability_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/request-additional-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__support_mandatory', '__min_version', '__preferred_version',
                 '__target_performance_parameters',)

    _yang_name = 'request-additional-capability'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__min_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__preferred_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",
                                                                              yc_target_performance_parameters_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                                              yang_name="target-performance-parameters",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='key', extensions=None),
                                                            is_container='list',
                                                            yang_name="target-performance-parameters", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'request-additional-capability']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/name (string)

    YANG Description: Identifies a requested additional capability for the
VDU. ETSI GS NFV-IFA 002 [i.1] describes acceleration
capabilities.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identifies a requested additional capability for the
VDU. ETSI GS NFV-IFA 002 [i.1] describes acceleration
capabilities.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/support_mandatory (boolean)

    YANG Description: Indicates whether the requested additional capability
is mandatory for successful operation.
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether the requested additional capability
is mandatory for successful operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_min_version(self):
        """
    Getter method for min_version, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/min_version (string)

    YANG Description: Identifies the minimum version of the requested
additional capability.
    """
        return self.__min_version

    def _set_min_version(self, v, load=False):
        """
    Setter method for min_version, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/min_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_version() directly.

    YANG Description: Identifies the minimum version of the requested
additional capability.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__min_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_version(self):
        self.__min_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_preferred_version(self):
        """
    Getter method for preferred_version, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/preferred_version (string)

    YANG Description: Identifies the preferred version of the requested
additional capability.
    """
        return self.__preferred_version

    def _set_preferred_version(self, v, load=False):
        """
    Setter method for preferred_version, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/preferred_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_version() directly.

    YANG Description: Identifies the preferred version of the requested
additional capability.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="preferred-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """preferred_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__preferred_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_preferred_version(self):
        self.__preferred_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_target_performance_parameters(self):
        """
    Getter method for target_performance_parameters, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters (list)

    YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
    """
        return self.__target_performance_parameters

    def _set_target_performance_parameters(self, v, load=False):
        """
    Setter method for target_performance_parameters, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_performance_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_performance_parameters() directly.

    YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_target_performance_parameters_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                  yang_name="target-performance-parameters", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="target-performance-parameters", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """target_performance_parameters must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__target_performance_parameters = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_target_performance_parameters(self):
        self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",
                                                                              yc_target_performance_parameters_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                                              yang_name="target-performance-parameters",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='key', extensions=None),
                                                            is_container='list',
                                                            yang_name="target-performance-parameters", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    min_version = __builtin__.property(_get_min_version, _set_min_version)
    preferred_version = __builtin__.property(_get_preferred_version, _set_preferred_version)
    target_performance_parameters = __builtin__.property(_get_target_performance_parameters,
                                                         _set_target_performance_parameters)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('support_mandatory', support_mandatory), ('min_version', min_version),
         ('preferred_version', preferred_version), ('target_performance_parameters', target_performance_parameters), ])


class yc_vdu_mem_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-memory/vdu-mem-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pair requirements on the memory for
the VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-mem-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-memory', 'vdu-mem-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_memory_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual memory of the virtualised compute.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__size', '__over_subscription_policy', '__vdu_mem_requirements',
        '__numa_enabled',)

    _yang_name = 'virtual-memory'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__size = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                                   default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='decimal64', is_config=True)
        self.__over_subscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="over-subscription-policy", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='string',
                                                       is_config=True)
        self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_mem_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                                     yang_name="vdu-mem-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-mem-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-memory']

    def _get_size(self):
        """
    Getter method for size, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/size (decimal64)

    YANG Description: Amount of virtual memory in GB.
    """
        return self.__size

    def _set_size(self, v, load=False):
        """
    Setter method for size, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/size (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: Amount of virtual memory in GB.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                             default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(1), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='decimal64', is_config=True)""",
            })

        self.__size = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                                   default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='decimal64', is_config=True)

    def _get_over_subscription_policy(self):
        """
    Getter method for over_subscription_policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/over_subscription_policy (string)

    YANG Description: The memory core oversubscription policy in terms of
virtual memory to physical memory on the platform.
The cardinality can be 0 during the allocation
request, if no particular value is requested.
    """
        return self.__over_subscription_policy

    def _set_over_subscription_policy(self, v, load=False):
        """
    Setter method for over_subscription_policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/over_subscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_over_subscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_over_subscription_policy() directly.

    YANG Description: The memory core oversubscription policy in terms of
virtual memory to physical memory on the platform.
The cardinality can be 0 during the allocation
request, if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="over-subscription-policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """over_subscription_policy must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="over-subscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__over_subscription_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_over_subscription_policy(self):
        self.__over_subscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="over-subscription-policy", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='string',
                                                       is_config=True)

    def _get_vdu_mem_requirements(self):
        """
    Getter method for vdu_mem_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements (list)

    YANG Description: Array of key-value pair requirements on the memory for
the VDU.
    """
        return self.__vdu_mem_requirements

    def _set_vdu_mem_requirements(self, v, load=False):
        """
    Setter method for vdu_mem_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_mem_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_mem_requirements() directly.

    YANG Description: Array of key-value pair requirements on the memory for
the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_mem_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                  yang_name="vdu-mem-requirements", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_mem_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_mem_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_mem_requirements(self):
        self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_mem_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                                     yang_name="vdu-mem-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-mem-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_numa_enabled(self):
        """
    Getter method for numa_enabled, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/numa_enabled (boolean)

    YANG Description: It specifies the memory allocation to be cognisant of
the relevant process/core allocation. The cardinality
can be 0 during the allocation request, if no
particular value is requested.
    """
        return self.__numa_enabled

    def _set_numa_enabled(self, v, load=False):
        """
    Setter method for numa_enabled, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory/numa_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_enabled() directly.

    YANG Description: It specifies the memory allocation to be cognisant of
the relevant process/core allocation. The cardinality
can be 0 during the allocation request, if no
particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """numa_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__numa_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_numa_enabled(self):
        self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    size = __builtin__.property(_get_size, _set_size)
    over_subscription_policy = __builtin__.property(_get_over_subscription_policy, _set_over_subscription_policy)
    vdu_mem_requirements = __builtin__.property(_get_vdu_mem_requirements, _set_vdu_mem_requirements)
    numa_enabled = __builtin__.property(_get_numa_enabled, _set_numa_enabled)

    _pyangbind_elements = OrderedDict([('size', size), ('over_subscription_policy', over_subscription_policy),
                                       ('vdu_mem_requirements', vdu_mem_requirements),
                                       ('numa_enabled', numa_enabled), ])


class yc_vdu_cpu_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-cpu/vdu-cpu-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-cpu-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-cpu', 'vdu-cpu-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_rule_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning_rule(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-cpu/pinning/rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-cpu', 'pinning', 'rule']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_pinning_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-cpu/pinning. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
  """
    __slots__ = ('_path_helper', '_extmethods', '__policy', '__rule',)

    _yang_name = 'pinning'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'static': {}, 'dynamic': {}}, ),
                                     default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)
        self.__rule = YANGDynClass(
            base=YANGListType("key", yc_rule_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                              yang_name="rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-cpu', 'pinning']

    def _get_policy(self):
        """
    Getter method for policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/policy (enumeration)

    YANG Description: The policy can take values of 'static' or 'dynamic'.
In case of 'static' the virtual CPU cores are
requested to be allocated to logical CPU cores
according to the rules defined in
virtualCpuPinningRules. In case of 'dynamic' the
allocation of virtual CPU cores to logical CPU cores
is decided by the VIM. (e.g. SMT (Simultaneous
MultiThreading) requirements).
    """
        return self.__policy

    def _set_policy(self, v, load=False):
        """
    Setter method for policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy() directly.

    YANG Description: The policy can take values of 'static' or 'dynamic'.
In case of 'static' the virtual CPU cores are
requested to be allocated to logical CPU cores
according to the rules defined in
virtualCpuPinningRules. In case of 'dynamic' the
allocation of virtual CPU cores to logical CPU cores
is decided by the VIM. (e.g. SMT (Simultaneous
MultiThreading) requirements).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'static': {}, 'dynamic': {}}, ),
                             default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """policy must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'static': {}, 'dynamic': {}},), default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_policy(self):
        self.__policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'static': {}, 'dynamic': {}}, ),
                                     default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)

    def _get_rule(self):
        """
    Getter method for rule, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule (list)

    YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
    """
        return self.__rule

    def _set_rule(self, v, load=False):
        """
    Setter method for rule, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning/rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.

    YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_rule_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                                                  yang_name="rule", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_rule_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning_rule, yang_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_rule(self):
        self.__rule = YANGDynClass(
            base=YANGListType("key", yc_rule_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                              yang_name="rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    policy = __builtin__.property(_get_policy, _set_policy)
    rule = __builtin__.property(_get_rule, _set_rule)

    _pyangbind_elements = OrderedDict([('policy', policy), ('rule', rule), ])


class yc_virtual_cpu_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc/virtual-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU(s)of the virtualised compute.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__cpu_architecture', '__num_virtual_cpu', '__clock',
        '__oversubscription_policy',
        '__vdu_cpu_requirements', '__pinning',)

    _yang_name = 'virtual-cpu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__cpu_architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__num_virtual_cpu = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={
            'range': ['0..65535']}, int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__clock = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="oversubscription-policy", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='string',
                                                      is_config=True)
        self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_cpu_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                                     yang_name="vdu-cpu-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-cpu-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__pinning = YANGDynClass(base=yc_pinning_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning,
                                      is_container='container', yang_name="pinning", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc', 'virtual-cpu']

    def _get_cpu_architecture(self):
        """
    Getter method for cpu_architecture, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/cpu_architecture (string)

    YANG Description: CPU architecture type. Examples are x86, ARM. The
cardinality can be 0 during the allocation request,
if no particular CPU architecture type is requested.
    """
        return self.__cpu_architecture

    def _set_cpu_architecture(self, v, load=False):
        """
    Setter method for cpu_architecture, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/cpu_architecture (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_architecture is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_architecture() directly.

    YANG Description: CPU architecture type. Examples are x86, ARM. The
cardinality can be 0 during the allocation request,
if no particular CPU architecture type is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpu-architecture", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpu_architecture must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__cpu_architecture = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpu_architecture(self):
        self.__cpu_architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_num_virtual_cpu(self):
        """
    Getter method for num_virtual_cpu, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/num_virtual_cpu (uint16)

    YANG Description: Number of virtual CPUs.
    """
        return self.__num_virtual_cpu

    def _set_num_virtual_cpu(self, v, load=False):
        """
    Setter method for num_virtual_cpu, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/num_virtual_cpu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_virtual_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_virtual_cpu() directly.

    YANG Description: Number of virtual CPUs.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
                restriction_dict={'range': ['1..max']}),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """num_virtual_cpu must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__num_virtual_cpu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_num_virtual_cpu(self):
        self.__num_virtual_cpu = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={
            'range': ['0..65535']}, int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_clock(self):
        """
    Getter method for clock, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/clock (uint32)

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz). The
cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        return self.__clock

    def _set_clock(self, v, load=False):
        """
    Setter method for clock, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/clock (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz). The
cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="clock", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """clock must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__clock = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_clock(self):
        self.__clock = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_oversubscription_policy(self):
        """
    Getter method for oversubscription_policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/oversubscription_policy (string)

    YANG Description: The CPU core oversubscription policy e.g. the relation
of virtual CPU cores to physical CPU cores/threads.
The cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        return self.__oversubscription_policy

    def _set_oversubscription_policy(self, v, load=False):
        """
    Setter method for oversubscription_policy, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/oversubscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oversubscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oversubscription_policy() directly.

    YANG Description: The CPU core oversubscription policy e.g. the relation
of virtual CPU cores to physical CPU cores/threads.
The cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="oversubscription-policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """oversubscription_policy must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__oversubscription_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_oversubscription_policy(self):
        self.__oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="oversubscription-policy", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='string',
                                                      is_config=True)

    def _get_vdu_cpu_requirements(self):
        """
    Getter method for vdu_cpu_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements (list)

    YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
    """
        return self.__vdu_cpu_requirements

    def _set_vdu_cpu_requirements(self, v, load=False):
        """
    Setter method for vdu_cpu_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_cpu_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_cpu_requirements() directly.

    YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_cpu_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                  yang_name="vdu-cpu-requirements", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_cpu_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_cpu_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_cpu_requirements(self):
        self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_cpu_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                                     yang_name="vdu-cpu-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-cpu-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_pinning(self):
        """
    Getter method for pinning, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning (container)

    YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
    """
        return self.__pinning

    def _set_pinning(self, v, load=False):
        """
    Setter method for pinning, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu/pinning (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning() directly.

    YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_pinning_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning,
                             is_container='container', yang_name="pinning", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pinning must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_pinning_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning, is_container='container', yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__pinning = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pinning(self):
        self.__pinning = YANGDynClass(base=yc_pinning_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu_pinning,
                                      is_container='container', yang_name="pinning", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    cpu_architecture = __builtin__.property(_get_cpu_architecture, _set_cpu_architecture)
    num_virtual_cpu = __builtin__.property(_get_num_virtual_cpu, _set_num_virtual_cpu)
    clock = __builtin__.property(_get_clock, _set_clock)
    oversubscription_policy = __builtin__.property(_get_oversubscription_policy, _set_oversubscription_policy)
    vdu_cpu_requirements = __builtin__.property(_get_vdu_cpu_requirements, _set_vdu_cpu_requirements)
    pinning = __builtin__.property(_get_pinning, _set_pinning)

    _pyangbind_elements = OrderedDict(
        [('cpu_architecture', cpu_architecture), ('num_virtual_cpu', num_virtual_cpu), ('clock', clock),
         ('oversubscription_policy', oversubscription_policy), ('vdu_cpu_requirements', vdu_cpu_requirements),
         ('pinning', pinning), ])


class yc_virtual_compute_desc_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-compute-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__logical_node', '__request_additional_capability',
                 '__compute_requirements', '__virtual_memory', '__virtual_cpu',)

    _yang_name = 'virtual-compute-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__logical_node = YANGDynClass(
            base=YANGListType("id", yc_logical_node_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node,
                              yang_name="logical-node", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__request_additional_capability = YANGDynClass(base=YANGListType("name",
                                                                              yc_request_additional_capability_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability,
                                                                              yang_name="request-additional-capability",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='name', extensions=None),
                                                            is_container='list',
                                                            yang_name="request-additional-capability", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)
        self.__compute_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory, is_container='container',
            yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu,
                                          is_container='container', yang_name="virtual-cpu", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-compute-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/id (string)

    YANG Description: Unique identifier of this VirtualComputeDesc in the
VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VirtualComputeDesc in the
VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_logical_node(self):
        """
    Getter method for logical_node, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node (list)

    YANG Description: The logical node requirements.
    """
        return self.__logical_node

    def _set_logical_node(self, v, load=False):
        """
    Setter method for logical_node, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/logical_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_node() directly.

    YANG Description: The logical node requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_logical_node_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node,
                                                  yang_name="logical-node", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="logical-node",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """logical_node must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_logical_node_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node, yang_name="logical-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__logical_node = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_logical_node(self):
        self.__logical_node = YANGDynClass(
            base=YANGListType("id", yc_logical_node_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_logical_node,
                              yang_name="logical-node", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_request_additional_capability(self):
        """
    Getter method for request_additional_capability, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability (list)
    """
        return self.__request_additional_capability

    def _set_request_additional_capability(self, v, load=False):
        """
    Setter method for request_additional_capability, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/request_additional_capability (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_request_additional_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_request_additional_capability() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_request_additional_capability_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability,
                                                  yang_name="request-additional-capability", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="request-additional-capability", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """request_additional_capability must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_request_additional_capability_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability, yang_name="request-additional-capability", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__request_additional_capability = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_request_additional_capability(self):
        self.__request_additional_capability = YANGDynClass(base=YANGListType("name",
                                                                              yc_request_additional_capability_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_request_additional_capability,
                                                                              yang_name="request-additional-capability",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='name', extensions=None),
                                                            is_container='list',
                                                            yang_name="request-additional-capability", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)

    def _get_compute_requirements(self):
        """
    Getter method for compute_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/compute_requirements (string)

    YANG Description: Specifies compute requirements.
    """
        return self.__compute_requirements

    def _set_compute_requirements(self, v, load=False):
        """
    Setter method for compute_requirements, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/compute_requirements (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compute_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compute_requirements() directly.

    YANG Description: Specifies compute requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="compute-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """compute_requirements must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__compute_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_compute_requirements(self):
        self.__compute_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_virtual_memory(self):
        """
    Getter method for virtual_memory, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory (container)

    YANG Description: The virtual memory of the virtualised compute.
    """
        return self.__virtual_memory

    def _set_virtual_memory(self, v, load=False):
        """
    Setter method for virtual_memory, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_memory() directly.

    YANG Description: The virtual memory of the virtualised compute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_virtual_memory_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory,
                             is_container='container', yang_name="virtual-memory", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_memory must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_memory_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__virtual_memory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_memory(self):
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_memory, is_container='container',
            yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_virtual_cpu(self):
        """
    Getter method for virtual_cpu, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu (container)

    YANG Description: The virtual CPU(s)of the virtualised compute.
    """
        return self.__virtual_cpu

    def _set_virtual_cpu(self, v, load=False):
        """
    Setter method for virtual_cpu, mapped from YANG variable /nsd/vnfd/virtual_compute_desc/virtual_cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_cpu() directly.

    YANG Description: The virtual CPU(s)of the virtualised compute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_virtual_cpu_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu,
                             is_container='container', yang_name="virtual-cpu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_cpu must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_cpu_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__virtual_cpu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_cpu(self):
        self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc_virtual_cpu,
                                          is_container='container', yang_name="virtual-cpu", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    logical_node = __builtin__.property(_get_logical_node, _set_logical_node)
    request_additional_capability = __builtin__.property(_get_request_additional_capability,
                                                         _set_request_additional_capability)
    compute_requirements = __builtin__.property(_get_compute_requirements, _set_compute_requirements)
    virtual_memory = __builtin__.property(_get_virtual_memory, _set_virtual_memory)
    virtual_cpu = __builtin__.property(_get_virtual_cpu, _set_virtual_cpu)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('logical_node', logical_node), ('request_additional_capability', request_additional_capability),
         ('compute_requirements', compute_requirements), ('virtual_memory', virtual_memory),
         ('virtual_cpu', virtual_cpu), ])


class yc_vdu_storage_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc_vdu_storage_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-storage-desc/vdu-storage-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-storage-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-storage-desc', 'vdu-storage-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_storage_desc_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/virtual-storage-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__type_of_storage', '__size_of_storage', '__vdu_storage_requirements',
        '__rdma_enabled', '__sw_image_desc',)

    _yang_name = 'virtual-storage-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'root-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
            default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                        int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__vdu_storage_requirements = YANGDynClass(base=YANGListType("key",
                                                                         yc_vdu_storage_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                                         yang_name="vdu-storage-requirements",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='key',
                                                                         extensions=None), is_container='list',
                                                       yang_name="vdu-storage-requirements", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__rdma_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'virtual-storage-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/id (string)

    YANG Description: Unique identifier of this VirtualStorageDesc in the
VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VirtualStorageDesc in the
VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_type_of_storage(self):
        """
    Getter method for type_of_storage, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/type_of_storage (identityref)

    YANG Description: Type of virtualised storage resource (e.g. volume,
object).
    """
        return self.__type_of_storage

    def _set_type_of_storage(self, v, load=False):
        """
    Setter method for type_of_storage, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/type_of_storage (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_of_storage() directly.

    YANG Description: Type of virtualised storage resource (e.g. volume,
object).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ephemeral-storage': {
                                                                 '@module': 'etsi-nfv-descriptors',
                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ephemeral-storage': {
                                                                 '@module': 'etsi-nfv-descriptors',
                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type_of_storage must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__type_of_storage = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type_of_storage(self):
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'root-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
            default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)

    def _get_size_of_storage(self):
        """
    Getter method for size_of_storage, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/size_of_storage (uint64)

    YANG Description: Size of virtualised storage resource (e.g. size of
volume, in GB)
    """
        return self.__size_of_storage

    def _set_size_of_storage(self, v, load=False):
        """
    Setter method for size_of_storage, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/size_of_storage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size_of_storage() directly.

    YANG Description: Size of virtualised storage resource (e.g. size of
volume, in GB)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), default=RestrictedClassType(base_type=long,
                                                                                                   restriction_dict={
                                                                                                       'range': [
                                                                                                           '0..18446744073709551615']},
                                                                                                   int_size=64)(0),
                             is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size_of_storage must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__size_of_storage = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size_of_storage(self):
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                        int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_vdu_storage_requirements(self):
        """
    Getter method for vdu_storage_requirements, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements (list)

    YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
    """
        return self.__vdu_storage_requirements

    def _set_vdu_storage_requirements(self, v, load=False):
        """
    Setter method for vdu_storage_requirements, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/vdu_storage_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_storage_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_storage_requirements() directly.

    YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_storage_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                  yang_name="vdu-storage-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="vdu-storage-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_storage_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_storage_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc_vdu_storage_requirements, yang_name="vdu-storage-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-storage-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_storage_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_storage_requirements(self):
        self.__vdu_storage_requirements = YANGDynClass(base=YANGListType("key",
                                                                         yc_vdu_storage_requirements_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                                         yang_name="vdu-storage-requirements",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='key',
                                                                         extensions=None), is_container='list',
                                                       yang_name="vdu-storage-requirements", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_rdma_enabled(self):
        """
    Getter method for rdma_enabled, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/rdma_enabled (boolean)

    YANG Description: Indicate if the storage support RDMA.
    """
        return self.__rdma_enabled

    def _set_rdma_enabled(self, v, load=False):
        """
    Setter method for rdma_enabled, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/rdma_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdma_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdma_enabled() directly.

    YANG Description: Indicate if the storage support RDMA.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """rdma_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__rdma_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_rdma_enabled(self):
        self.__rdma_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/sw_image_desc (leafref)

    YANG Description: Software image to be loaded on the VirtualStorage
resource created based on this VirtualStorageDesc.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/virtual_storage_desc/sw_image_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Software image to be loaded on the VirtualStorage
resource created based on this VirtualStorageDesc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    type_of_storage = __builtin__.property(_get_type_of_storage, _set_type_of_storage)
    size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
    vdu_storage_requirements = __builtin__.property(_get_vdu_storage_requirements, _set_vdu_storage_requirements)
    rdma_enabled = __builtin__.property(_get_rdma_enabled, _set_rdma_enabled)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('type_of_storage', type_of_storage), ('size_of_storage', size_of_storage),
         ('vdu_storage_requirements', vdu_storage_requirements), ('rdma_enabled', rdma_enabled),
         ('sw_image_desc', sw_image_desc), ])


class yc_checksum_etsi_nfv_nsd__nsd_vnfd_sw_image_desc_checksum(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/sw-image-desc/checksum. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The checksum of the software image file.
  """
    __slots__ = ('_path_helper', '_extmethods', '__algorithm', '__hash',)

    _yang_name = 'checksum'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={
                                                                     'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                        is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='identityref', is_config=True)
        self.__hash = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'sw-image-desc', 'checksum']

    def _get_algorithm(self):
        """
    Getter method for algorithm, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum/algorithm (identityref)

    YANG Description: Species the algorithm used to obtain the checksum
value.
    """
        return self.__algorithm

    def _set_algorithm(self, v, load=False):
        """
    Setter method for algorithm, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum/algorithm (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Species the algorithm used to obtain the checksum
value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-224': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-224': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-256': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-256': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-384': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-384': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-512': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-512': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """algorithm must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__algorithm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_algorithm(self):
        self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={
                                                                     'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                        is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='identityref', is_config=True)

    def _get_hash(self):
        """
    Getter method for hash, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum/hash (string)

    YANG Description: Contains the result of applying the algorithm
indicated by the algorithm attribute to the data to
which this ChecksumData refers.
    """
        return self.__hash

    def _set_hash(self, v, load=False):
        """
    Setter method for hash, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum/hash (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hash is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hash() directly.

    YANG Description: Contains the result of applying the algorithm
indicated by the algorithm attribute to the data to
which this ChecksumData refers.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """hash must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__hash = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_hash(self):
        self.__hash = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
    hash = __builtin__.property(_get_hash, _set_hash)

    _pyangbind_elements = OrderedDict([('algorithm', algorithm), ('hash', hash), ])


class yc_sw_image_desc_etsi_nfv_nsd__nsd_vnfd_sw_image_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/sw-image-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines descriptors of software images to be used by the
VNF.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__version', '__checksum', '__container_format',
        '__disk_format',
        '__min_disk', '__min_ram', '__size', '__image', '__operating_system', '__supported_virtualization_environment',)

    _yang_name = 'sw-image-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)
        self.__checksum = YANGDynClass(base=yc_checksum_etsi_nfv_nsd__nsd_vnfd_sw_image_desc_checksum,
                                       is_container='container', yang_name="checksum", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                       defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__container_format = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {},
                                                      'ova': {}, 'ovf': {}}, ), default=six.text_type("bare"),
            is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__disk_format = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'aki': {}, 'ami': {}, 'ari': {},
                                                                                    'iso': {}, 'qcow2': {}, 'raw': {},
                                                                                    'vdi': {}, 'vhd': {}, 'vhdx': {},
                                                                                    'vmdk': {}}, ),
                                          default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format",
                                          parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0),
            is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="size", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__image = YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                    defining_module='etsi-nfv-nsd', yang_type='inet:uri', is_config=True)
        self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__supported_virtualization_environment = YANGDynClass(unique=True,
                                                                   base=TypedListType(allowed_type=six.text_type),
                                                                   is_leaf=False,
                                                                   yang_name="supported-virtualization-environment",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='string',
                                                                   is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'sw-image-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/sw_image_desc/id (string)

    YANG Description: The identifier of this software image.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/sw_image_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this software image.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/sw_image_desc/name (string)

    YANG Description: The name of this software image.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/sw_image_desc/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd/vnfd/sw_image_desc/version (string)

    YANG Description: The version of this software image.
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /nsd/vnfd/sw_image_desc/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)

    def _get_checksum(self):
        """
    Getter method for checksum, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum (container)

    YANG Description: The checksum of the software image file.
    """
        return self.__checksum

    def _set_checksum(self, v, load=False):
        """
    Setter method for checksum, mapped from YANG variable /nsd/vnfd/sw_image_desc/checksum (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: The checksum of the software image file.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_checksum_etsi_nfv_nsd__nsd_vnfd_sw_image_desc_checksum,
                             is_container='container', yang_name="checksum", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """checksum must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_checksum_etsi_nfv_nsd__nsd_vnfd_sw_image_desc_checksum, is_container='container', yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__checksum = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_checksum(self):
        self.__checksum = YANGDynClass(base=yc_checksum_etsi_nfv_nsd__nsd_vnfd_sw_image_desc_checksum,
                                       is_container='container', yang_name="checksum", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                       defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_container_format(self):
        """
    Getter method for container_format, mapped from YANG variable /nsd/vnfd/sw_image_desc/container_format (enumeration)

    YANG Description: The container format describes the container file
format in which software image is provided.
    """
        return self.__container_format

    def _set_container_format(self, v, load=False):
        """
    Setter method for container_format, mapped from YANG variable /nsd/vnfd/sw_image_desc/container_format (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_container_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_container_format() directly.

    YANG Description: The container format describes the container file
format in which software image is provided.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {},
                                                                          'docker': {}, 'ova': {}, 'ovf': {}}, ),
                             default=six.text_type("bare"), is_leaf=True, yang_name="container-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """container_format must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {}, 'ova': {}, 'ovf': {}},), default=six.text_type("bare"), is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__container_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_container_format(self):
        self.__container_format = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {},
                                                      'ova': {}, 'ovf': {}}, ), default=six.text_type("bare"),
            is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_disk_format(self):
        """
    Getter method for disk_format, mapped from YANG variable /nsd/vnfd/sw_image_desc/disk_format (enumeration)

    YANG Description: The disk format of a software image is the format of
the underlying disk image.
    """
        return self.__disk_format

    def _set_disk_format(self, v, load=False):
        """
    Setter method for disk_format, mapped from YANG variable /nsd/vnfd/sw_image_desc/disk_format (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_format() directly.

    YANG Description: The disk format of a software image is the format of
the underlying disk image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'iso': {},
                                                                          'qcow2': {}, 'raw': {}, 'vdi': {}, 'vhd': {},
                                                                          'vhdx': {}, 'vmdk': {}}, ),
                             default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """disk_format must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'iso': {}, 'qcow2': {}, 'raw': {}, 'vdi': {}, 'vhd': {}, 'vhdx': {}, 'vmdk': {}},), default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__disk_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_disk_format(self):
        self.__disk_format = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'aki': {}, 'ami': {}, 'ari': {},
                                                                                    'iso': {}, 'qcow2': {}, 'raw': {},
                                                                                    'vdi': {}, 'vhd': {}, 'vhdx': {},
                                                                                    'vmdk': {}}, ),
                                          default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format",
                                          parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_min_disk(self):
        """
    Getter method for min_disk, mapped from YANG variable /nsd/vnfd/sw_image_desc/min_disk (uint64)

    YANG Description: The minimal disk size requirement for this software
image. The value of the 'size of storage' attribute
of the VirtualStorageDesc referencing this
SwImageDesc shall not be smaller than the value of
minDisk.
    """
        return self.__min_disk

    def _set_min_disk(self, v, load=False):
        """
    Setter method for min_disk, mapped from YANG variable /nsd/vnfd/sw_image_desc/min_disk (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_disk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_disk() directly.

    YANG Description: The minimal disk size requirement for this software
image. The value of the 'size of storage' attribute
of the VirtualStorageDesc referencing this
SwImageDesc shall not be smaller than the value of
minDisk.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_disk must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__min_disk = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_disk(self):
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_min_ram(self):
        """
    Getter method for min_ram, mapped from YANG variable /nsd/vnfd/sw_image_desc/min_ram (decimal64)

    YANG Description: The minimal RAM requirement for this software image.
The value of the 'size' attribute of
VirtualMemoryData of the Vdu referencing this
SwImageDesc shall not be smaller than the value of
minRam.
    """
        return self.__min_ram

    def _set_min_ram(self, v, load=False):
        """
    Setter method for min_ram, mapped from YANG variable /nsd/vnfd/sw_image_desc/min_ram (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ram is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_ram() directly.

    YANG Description: The minimal RAM requirement for this software image.
The value of the 'size' attribute of
VirtualMemoryData of the Vdu referencing this
SwImageDesc shall not be smaller than the value of
minRam.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                             default=Decimal(0), is_leaf=True, yang_name="min-ram", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_ram must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='decimal64', is_config=True)""",
            })

        self.__min_ram = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_ram(self):
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0),
            is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)

    def _get_size(self):
        """
    Getter method for size, mapped from YANG variable /nsd/vnfd/sw_image_desc/size (uint64)

    YANG Description: The size of this software image.
    """
        return self.__size

    def _set_size(self, v, load=False):
        """
    Setter method for size, mapped from YANG variable /nsd/vnfd/sw_image_desc/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The size of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="size", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__size = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="size", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_image(self):
        """
    Getter method for image, mapped from YANG variable /nsd/vnfd/sw_image_desc/image (inet:uri)

    YANG Description: This is a reference to the actual software image.
The reference can be relative to the root of the VNF
Package or can be a URL
    """
        return self.__image

    def _set_image(self, v, load=False):
        """
    Setter method for image, mapped from YANG variable /nsd/vnfd/sw_image_desc/image (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: This is a reference to the actual software image.
The reference can be relative to the root of the VNF
Package or can be a URL
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='inet:uri', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """image must be of a type compatible with inet:uri""",
                'defined-type': "inet:uri",
                'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='inet:uri', is_config=True)""",
            })

        self.__image = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_image(self):
        self.__image = YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                    defining_module='etsi-nfv-nsd', yang_type='inet:uri', is_config=True)

    def _get_operating_system(self):
        """
    Getter method for operating_system, mapped from YANG variable /nsd/vnfd/sw_image_desc/operating_system (string)

    YANG Description: Identifies the operating system used in the software
image. This attribute may also identify if a 32 bit
or 64 bit software image is used.
    """
        return self.__operating_system

    def _set_operating_system(self, v, load=False):
        """
    Setter method for operating_system, mapped from YANG variable /nsd/vnfd/sw_image_desc/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Identifies the operating system used in the software
image. This attribute may also identify if a 32 bit
or 64 bit software image is used.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """operating_system must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__operating_system = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_operating_system(self):
        self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_supported_virtualization_environment(self):
        """
    Getter method for supported_virtualization_environment, mapped from YANG variable /nsd/vnfd/sw_image_desc/supported_virtualization_environment (string)

    YANG Description: Identifies the virtualisation environments
(e.g. hypervisor) compatible with this software
image.
    """
        return self.__supported_virtualization_environment

    def _set_supported_virtualization_environment(self, v, load=False):
        """
    Setter method for supported_virtualization_environment, mapped from YANG variable /nsd/vnfd/sw_image_desc/supported_virtualization_environment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_virtualization_environment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_virtualization_environment() directly.

    YANG Description: Identifies the virtualisation environments
(e.g. hypervisor) compatible with this software
image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="supported-virtualization-environment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_virtualization_environment must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualization-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__supported_virtualization_environment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_virtualization_environment(self):
        self.__supported_virtualization_environment = YANGDynClass(unique=True,
                                                                   base=TypedListType(allowed_type=six.text_type),
                                                                   is_leaf=False,
                                                                   yang_name="supported-virtualization-environment",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='string',
                                                                   is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)
    checksum = __builtin__.property(_get_checksum, _set_checksum)
    container_format = __builtin__.property(_get_container_format, _set_container_format)
    disk_format = __builtin__.property(_get_disk_format, _set_disk_format)
    min_disk = __builtin__.property(_get_min_disk, _set_min_disk)
    min_ram = __builtin__.property(_get_min_ram, _set_min_ram)
    size = __builtin__.property(_get_size, _set_size)
    image = __builtin__.property(_get_image, _set_image)
    operating_system = __builtin__.property(_get_operating_system, _set_operating_system)
    supported_virtualization_environment = __builtin__.property(_get_supported_virtualization_environment,
                                                                _set_supported_virtualization_environment)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('checksum', checksum),
                                       ('container_format', container_format), ('disk_format', disk_format),
                                       ('min_disk', min_disk), ('min_ram', min_ram), ('size', size), ('image', image),
                                       ('operating_system', operating_system), (
                                           'supported_virtualization_environment',
                                           supported_virtualization_environment), ])


class yc_qos_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour_qos(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/int-virtual-link-desc/flavour/qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QoS of the VL.
  """
    __slots__ = ('_path_helper', '_extmethods', '__latency', '__packet_delay_variation', '__packet_loss_ratio',)

    _yang_name = 'qos'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'int-virtual-link-desc', 'flavour', 'qos']

    def _get_latency(self):
        """
    Getter method for latency, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/latency (uint32)

    YANG Description: Specifies the maximum latency in ms.
    """
        return self.__latency

    def _set_latency(self, v, load=False):
        """
    Setter method for latency, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/latency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency() directly.

    YANG Description: Specifies the maximum latency in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="latency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """latency must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__latency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_latency(self):
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_packet_delay_variation(self):
        """
    Getter method for packet_delay_variation, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/packet_delay_variation (uint32)

    YANG Description: Specifies the maximum jitter in ms.
    """
        return self.__packet_delay_variation

    def _set_packet_delay_variation(self, v, load=False):
        """
    Setter method for packet_delay_variation, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/packet_delay_variation (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_delay_variation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_delay_variation() directly.

    YANG Description: Specifies the maximum jitter in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="packet-delay-variation",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_delay_variation must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__packet_delay_variation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_delay_variation(self):
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    def _get_packet_loss_ratio(self):
        """
    Getter method for packet_loss_ratio, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/packet_loss_ratio (decimal64)

    YANG Description: Specifies the maximum packet loss ratio.
    """
        return self.__packet_loss_ratio

    def _set_packet_loss_ratio(self, v, load=False):
        """
    Setter method for packet_loss_ratio, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos/packet_loss_ratio (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_loss_ratio() directly.

    YANG Description: Specifies the maximum packet loss ratio.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}),
                             is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_loss_ratio must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='decimal64', is_config=True)""",
            })

        self.__packet_loss_ratio = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_loss_ratio(self):
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)

    latency = __builtin__.property(_get_latency, _set_latency)
    packet_delay_variation = __builtin__.property(_get_packet_delay_variation, _set_packet_delay_variation)
    packet_loss_ratio = __builtin__.property(_get_packet_loss_ratio, _set_packet_loss_ratio)

    _pyangbind_elements = OrderedDict([('latency', latency), ('packet_delay_variation', packet_delay_variation),
                                       ('packet_loss_ratio', packet_loss_ratio), ])


class yc_flavour_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/int-virtual-link-desc/flavour. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__qos',)

    _yang_name = 'flavour'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour_qos,
                                  is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'int-virtual-link-desc', 'flavour']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/id (string)

    YANG Description: Identifies a flavour within a VnfVirtualLinkDesc.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies a flavour within a VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_qos(self):
        """
    Getter method for qos, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos (container)

    YANG Description: QoS of the VL.
    """
        return self.__qos

    def _set_qos(self, v, load=False):
        """
    Setter method for qos, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour/qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: QoS of the VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_qos_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour_qos,
                             is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """qos must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__qos = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_qos(self):
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour_qos,
                                  is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    qos = __builtin__.property(_get_qos, _set_qos)

    _pyangbind_elements = OrderedDict([('id', id), ('qos', qos), ])


class yc_connectivity_type_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_connectivity_type(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/int-virtual-link-desc/connectivity-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__layer_protocol', '__flow_pattern',)

    _yang_name = 'connectivity-type'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='flow-pattern', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'int-virtual-link-desc', 'connectivity-type']

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type/layer_protocol (identityref)

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)

    def _get_flow_pattern(self):
        """
    Getter method for flow_pattern, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        return self.__flow_pattern

    def _set_flow_pattern(self, v, load=False):
        """
    Setter method for flow_pattern, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_pattern is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_pattern() directly.

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ),
                             is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='flow-pattern', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flow_pattern must be of a type compatible with flow-pattern""",
                'defined-type': "etsi-nfv-nsd:flow-pattern",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}},), is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='flow-pattern', is_config=True)""",
            })

        self.__flow_pattern = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flow_pattern(self):
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='flow-pattern', is_config=True)

    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    flow_pattern = __builtin__.property(_get_flow_pattern, _set_flow_pattern)

    _pyangbind_elements = OrderedDict([('layer_protocol', layer_protocol), ('flow_pattern', flow_pattern), ])


class yc_monitoring_parameters_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_monitoring_parameters(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/int-virtual-link-desc/monitoring-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameters'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'int-virtual-link-desc', 'monitoring-parameters']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_int_virtual_link_desc_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/int-virtual-link-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__flavour', '__connectivity_type', '__test_access', '__description',
        '__monitoring_parameters',)

    _yang_name = 'int-virtual-link-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__flavour = YANGDynClass(
            base=YANGListType("id", yc_flavour_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour,
                              yang_name="flavour", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__test_access = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__monitoring_parameters = YANGDynClass(base=YANGListType("id",
                                                                      yc_monitoring_parameters_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_monitoring_parameters,
                                                                      yang_name="monitoring-parameters", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper, yang_keys='id',
                                                                      extensions=None), is_container='list',
                                                    yang_name="monitoring-parameters", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'int-virtual-link-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/id (string)

    YANG Description: Unique identifier of this internal VLD in VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this internal VLD in VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_flavour(self):
        """
    Getter method for flavour, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour (list)

    YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
    """
        return self.__flavour

    def _set_flavour(self, v, load=False):
        """
    Setter method for flavour, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/flavour (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour() directly.

    YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_flavour_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour,
                                                  yang_name="flavour", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="flavour",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_flavour_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour, yang_name="flavour", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__flavour = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour(self):
        self.__flavour = YANGDynClass(
            base=YANGListType("id", yc_flavour_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_flavour,
                              yang_name="flavour", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_connectivity_type(self):
        """
    Getter method for connectivity_type, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type (container)
    """
        return self.__connectivity_type

    def _set_connectivity_type(self, v, load=False):
        """
    Setter method for connectivity_type, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/connectivity_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectivity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectivity_type() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_connectivity_type_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_connectivity_type,
                             is_container='container', yang_name="connectivity-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """connectivity_type must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_connectivity_type_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_connectivity_type, is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__connectivity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_connectivity_type(self):
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_test_access(self):
        """
    Getter method for test_access, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/test_access (string)

    YANG Description: Specifies test access facilities expected on the VL
(e.g. none, passive monitoring, or active (intrusive)
loopbacks at endpoints.
    """
        return self.__test_access

    def _set_test_access(self, v, load=False):
        """
    Setter method for test_access, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/test_access (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_access() directly.

    YANG Description: Specifies test access facilities expected on the VL
(e.g. none, passive monitoring, or active (intrusive)
loopbacks at endpoints.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="test-access", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """test_access must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="test-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__test_access = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_test_access(self):
        self.__test_access = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/description (string)

    YANG Description: Provides human-readable information on the purpose of
the VL (e.g. control plane traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of
the VL (e.g. control plane traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_monitoring_parameters(self):
        """
    Getter method for monitoring_parameters, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters (list)
    """
        return self.__monitoring_parameters

    def _set_monitoring_parameters(self, v, load=False):
        """
    Setter method for monitoring_parameters, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc/monitoring_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameters() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameters_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_monitoring_parameters,
                                                  yang_name="monitoring-parameters", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameters", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameters must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameters_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_monitoring_parameters, yang_name="monitoring-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameters = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameters(self):
        self.__monitoring_parameters = YANGDynClass(base=YANGListType("id",
                                                                      yc_monitoring_parameters_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc_monitoring_parameters,
                                                                      yang_name="monitoring-parameters", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper, yang_keys='id',
                                                                      extensions=None), is_container='list',
                                                    yang_name="monitoring-parameters", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    flavour = __builtin__.property(_get_flavour, _set_flavour)
    connectivity_type = __builtin__.property(_get_connectivity_type, _set_connectivity_type)
    test_access = __builtin__.property(_get_test_access, _set_test_access)
    description = __builtin__.property(_get_description, _set_description)
    monitoring_parameters = __builtin__.property(_get_monitoring_parameters, _set_monitoring_parameters)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('flavour', flavour), ('connectivity_type', connectivity_type), ('test_access', test_access),
         ('description', description), ('monitoring_parameters', monitoring_parameters), ])


class yc_security_group_rule_etsi_nfv_nsd__nsd_vnfd_security_group_rule(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/security-group-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines security group rules to be used by the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__direction', '__ether_type', '__protocol',
                 '__port_range_min', '__port_range_max',)

    _yang_name = 'security-group-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='enumeration', is_config=True)
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'security-group-rule']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/security_group_rule/id (string)

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/security_group_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/security_group_rule/description (string)

    YANG Description: Human readable description of the security group rule.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/security_group_rule/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the security group rule.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_direction(self):
        """
    Getter method for direction, mapped from YANG variable /nsd/vnfd/security_group_rule/direction (enumeration)

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        return self.__direction

    def _set_direction(self, v, load=False):
        """
    Setter method for direction, mapped from YANG variable /nsd/vnfd/security_group_rule/direction (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ingress': {}, 'egress': {}}, ),
                             default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """direction must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ingress': {}, 'egress': {}},), default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__direction = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_direction(self):
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_ether_type(self):
        """
    Getter method for ether_type, mapped from YANG variable /nsd/vnfd/security_group_rule/ether_type (enumeration)

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        return self.__ether_type

    def _set_ether_type(self, v, load=False):
        """
    Setter method for ether_type, mapped from YANG variable /nsd/vnfd/security_group_rule/ether_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ether_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ether_type() directly.

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ether_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ether_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ether_type(self):
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /nsd/vnfd/security_group_rule/protocol (enumeration)

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /nsd/vnfd/security_group_rule/protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                             default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}},), default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='enumeration', is_config=True)

    def _get_port_range_min(self):
        """
    Getter method for port_range_min, mapped from YANG variable /nsd/vnfd/security_group_rule/port_range_min (uint16)

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        return self.__port_range_min

    def _set_port_range_min(self, v, load=False):
        """
    Setter method for port_range_min, mapped from YANG variable /nsd/vnfd/security_group_rule/port_range_min (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_min() directly.

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(0), is_leaf=True, yang_name="port-range-min",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_min must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_min = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_min(self):
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_port_range_max(self):
        """
    Getter method for port_range_max, mapped from YANG variable /nsd/vnfd/security_group_rule/port_range_max (uint16)

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        return self.__port_range_max

    def _set_port_range_max(self, v, load=False):
        """
    Setter method for port_range_max, mapped from YANG variable /nsd/vnfd/security_group_rule/port_range_max (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_max() directly.

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(65535), is_leaf=True, yang_name="port-range-max",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_max must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(65535), is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_max = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_max(self):
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    direction = __builtin__.property(_get_direction, _set_direction)
    ether_type = __builtin__.property(_get_ether_type, _set_ether_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    port_range_min = __builtin__.property(_get_port_range_min, _set_port_range_min)
    port_range_max = __builtin__.property(_get_port_range_max, _set_port_range_max)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('direction', direction), ('ether_type', ether_type),
         ('protocol', protocol), ('port_range_min', port_range_min), ('port_range_max', port_range_max), ])


class yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd_int_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/int-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vdu_id', '__cpd',)

    _yang_name = 'int-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)
        self.__cpd = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                                  choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'int-cpd']

    def _get_vdu_id(self):
        """
    Getter method for vdu_id, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd/vdu_id (leafref)
    """
        return self.__vdu_id

    def _set_vdu_id(self, v, load=False):
        """
    Setter method for vdu_id, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                             choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_id(self):
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    def _get_cpd(self):
        """
    Getter method for cpd, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd/cpd (leafref)
    """
        return self.__cpd

    def _set_cpd(self, v, load=False):
        """
    Setter method for cpd, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd/cpd (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                             choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd(self):
        self.__cpd = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                                  choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='leafref', is_config=True)

    vdu_id = __builtin__.property(_get_vdu_id, _set_vdu_id)
    cpd = __builtin__.property(_get_cpd, _set_cpd)

    __choices__ = {'cp-connection': {'int-cpd': ['vdu_id', 'cpd']}}
    _pyangbind_elements = OrderedDict([('vdu_id', vdu_id), ('cpd', cpd), ])


class yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/virtual-network-interface-requirement/network-interface-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'network-interface-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'virtual-network-interface-requirement', 'network-interface-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/virtual-network-interface-requirement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__description', '__support_mandatory',
                 '__network_interface_requirements',)

    _yang_name = 'virtual-network-interface-requirement'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                             defining_module='etsi-nfv-nsd', yang_type='list',
                                                             is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'virtual-network-interface-requirement']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/support_mandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_network_interface_requirements(self):
        """
    Getter method for network_interface_requirements, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements (list)

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        return self.__network_interface_requirements

    def _set_network_interface_requirements(self, v, load=False):
        """
    Setter method for network_interface_requirements, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_interface_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_interface_requirements() directly.

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                  yang_name="network-interface-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="network-interface-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_interface_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements, yang_name="network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__network_interface_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_interface_requirements(self):
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                             defining_module='etsi-nfv-nsd', yang_type='list',
                                                             is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    network_interface_requirements = __builtin__.property(_get_network_interface_requirements,
                                                          _set_network_interface_requirements)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('description', description), ('support_mandatory', support_mandatory),
         ('network_interface_requirements', network_interface_requirements), ])


class yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l2_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/protocol/address-data/l2-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
  """
    __slots__ = ('_path_helper', '_extmethods', '__mac_address_assignment',)

    _yang_name = 'l2-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'protocol', 'address-data', 'l2-address-data']

    def _get_mac_address_assignment(self):
        """
    Getter method for mac_address_assignment, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        return self.__mac_address_assignment

    def _set_mac_address_assignment(self, v, load=False):
        """
    Setter method for mac_address_assignment, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_assignment() directly.

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__mac_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address_assignment(self):
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

    mac_address_assignment = __builtin__.property(_get_mac_address_assignment, _set_mac_address_assignment)

    _pyangbind_elements = OrderedDict([('mac_address_assignment', mac_address_assignment), ])


class yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l3_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/protocol/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__ip_address_assignment', '__floating_ip_activated', '__ip_address_type',
        '__number_of_ip_addresses',)

    _yang_name = 'l3-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'protocol', 'address-data', 'l3-address-data']

    def _get_ip_address_assignment(self):
        """
    Getter method for ip_address_assignment, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
    Setter method for ip_address_assignment, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__ip_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_floating_ip_activated(self):
        """
    Getter method for floating_ip_activated, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
    Setter method for floating_ip_activated, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_activated must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_activated = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_ip_address_type(self):
        """
    Getter method for ip_address_type, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
    Setter method for ip_address_type, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
                             yang_name="ip-address-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_address_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)

    def _get_number_of_ip_addresses(self):
        """
    Getter method for number_of_ip_addresses, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
    Setter method for number_of_ip_addresses, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="number-of-ip-addresses",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_ip_addresses = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
    floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)

    _pyangbind_elements = OrderedDict(
        [('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated),
         ('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ])


class yc_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/protocol/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__l2_address_data', '__l3_address_data',)

    _yang_name = 'address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'protocol', 'address-data']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/type (identityref)

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_l2_address_data(self):
        """
    Getter method for l2_address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l2_address_data (container)

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
    Setter method for l2_address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l2_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l2_address_data,
                             is_container='container', yang_name="l2-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l2_address_data, is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l2_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_l3_address_data(self):
        """
    Getter method for l3_address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
    Setter method for l3_address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l3_address_data,
                             is_container='container', yang_name="l3-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l3_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [('type', type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_protocol_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
  """
    __slots__ = ('_path_helper', '_extmethods', '__associated_layer_protocol', '__address_data',)

    _yang_name = 'protocol'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd', 'protocol']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)

    def _get_address_data(self):
        """
    Getter method for address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
    Setter method for address_data, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("type",
                                                  yc_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data,
                                                  yang_name="address-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='type',
                                                  extensions=None), is_container='list', yang_name="address-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("type",yc_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('address_data', address_data), ])


class yc_ext_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/ext-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__int_virtual_link_desc', '__int_cpd',
        '__virtual_network_interface_requirement',
        '__nicio_requirements', '__id', '__layer_protocol', '__role', '__description', '__protocol', '__trunk_mode',
        '__security_group_rule_id',)

    _yang_name = 'ext-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, choice=('cp-connection', 'int-virtual-link-desc'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__int_cpd = YANGDynClass(base=yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd_int_cpd, is_container='container',
                                      yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                    defining_module='etsi-nfv-nsd', yang_type='list',
                                                                    is_config=True)
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'ext-cpd']

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/ext_cpd/int_virtual_link_desc (leafref)

    YANG Description: Reference to the internal Virtual Link Descriptor (VLD)
to which CPs instantiated from this external CP
Descriptor (CPD) connect. Either intVirtualLinkDesc or
intCpd shall be present.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/ext_cpd/int_virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Reference to the internal Virtual Link Descriptor (VLD)
to which CPs instantiated from this external CP
Descriptor (CPD) connect. Either intVirtualLinkDesc or
intCpd shall be present.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self,
                             choice=('cp-connection', 'int-virtual-link-desc'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self, choice=('cp-connection', 'int-virtual-link-desc'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, choice=('cp-connection', 'int-virtual-link-desc'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_int_cpd(self):
        """
    Getter method for int_cpd, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd (container)
    """
        return self.__int_cpd

    def _set_int_cpd(self, v, load=False):
        """
    Setter method for int_cpd, mapped from YANG variable /nsd/vnfd/ext_cpd/int_cpd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_cpd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd_int_cpd, is_container='container',
                             yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_cpd must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd_int_cpd, is_container='container', yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__int_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_cpd(self):
        self.__int_cpd = YANGDynClass(base=yc_int_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd_int_cpd, is_container='container',
                                      yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_virtual_network_interface_requirement(self):
        """
    Getter method for virtual_network_interface_requirement, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement (list)

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        return self.__virtual_network_interface_requirement

    def _set_virtual_network_interface_requirement(self, v, load=False):
        """
    Setter method for virtual_network_interface_requirement, mapped from YANG variable /nsd/vnfd/ext_cpd/virtual_network_interface_requirement (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_interface_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_interface_requirement() directly.

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement,
                                                  yang_name="virtual-network-interface-requirement", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="virtual-network-interface-requirement", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_network_interface_requirement must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement, yang_name="virtual-network-interface-requirement", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_network_interface_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_network_interface_requirement(self):
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_nsd__nsd_vnfd_ext_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                    defining_module='etsi-nfv-nsd', yang_type='list',
                                                                    is_config=True)

    def _get_nicio_requirements(self):
        """
    Getter method for nicio_requirements, mapped from YANG variable /nsd/vnfd/ext_cpd/nicio_requirements (leafref)

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        return self.__nicio_requirements

    def _set_nicio_requirements(self, v, load=False):
        """
    Setter method for nicio_requirements, mapped from YANG variable /nsd/vnfd/ext_cpd/nicio_requirements (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nicio_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nicio_requirements() directly.

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nicio_requirements must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nicio_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nicio_requirements(self):
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/ext_cpd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/ext_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/layer_protocol (identityref)

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)

    def _get_role(self):
        """
    Getter method for role, mapped from YANG variable /nsd/vnfd/ext_cpd/role (identityref)

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        return self.__role

    def _set_role(self, v, load=False):
        """
    Setter method for role, mapped from YANG variable /nsd/vnfd/ext_cpd/role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """role must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__role = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_role(self):
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/ext_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/ext_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol (list)

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /nsd/vnfd/ext_cpd/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("associated_layer_protocol",
                                                  yc_protocol_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol,
                                                  yang_name="protocol", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='associated-layer-protocol', extensions=None),
                             is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_protocol_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_vnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_trunk_mode(self):
        """
    Getter method for trunk_mode, mapped from YANG variable /nsd/vnfd/ext_cpd/trunk_mode (boolean)

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
    Setter method for trunk_mode, mapped from YANG variable /nsd/vnfd/ext_cpd/trunk_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_mode() directly.

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trunk_mode must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__trunk_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_security_group_rule_id(self):
        """
    Getter method for security_group_rule_id, mapped from YANG variable /nsd/vnfd/ext_cpd/security_group_rule_id (leafref)

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        return self.__security_group_rule_id

    def _set_security_group_rule_id(self, v, load=False):
        """
    Setter method for security_group_rule_id, mapped from YANG variable /nsd/vnfd/ext_cpd/security_group_rule_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule_id() directly.

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__security_group_rule_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule_id(self):
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)

    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    int_cpd = __builtin__.property(_get_int_cpd, _set_int_cpd)
    virtual_network_interface_requirement = __builtin__.property(_get_virtual_network_interface_requirement,
                                                                 _set_virtual_network_interface_requirement)
    nicio_requirements = __builtin__.property(_get_nicio_requirements, _set_nicio_requirements)
    id = __builtin__.property(_get_id, _set_id)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    role = __builtin__.property(_get_role, _set_role)
    description = __builtin__.property(_get_description, _set_description)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)
    security_group_rule_id = __builtin__.property(_get_security_group_rule_id, _set_security_group_rule_id)

    __choices__ = {'cp-connection': {'int-virtual-link-desc': ['int_virtual_link_desc'], 'int-cpd': ['int_cpd']}}
    _pyangbind_elements = OrderedDict([('int_virtual_link_desc', int_virtual_link_desc), ('int_cpd', int_cpd),
                                       ('virtual_network_interface_requirement', virtual_network_interface_requirement),
                                       ('nicio_requirements', nicio_requirements), ('id', id),
                                       ('layer_protocol', layer_protocol), ('role', role), ('description', description),
                                       ('protocol', protocol), ('trunk_mode', trunk_mode),
                                       ('security_group_rule_id', security_group_rule_id), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/vdu-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'vdu-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_affinity_or_anti_affinity_group(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/vdu-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'vdu-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/vdu_profile/affinity_or_anti_affinity_group/id (leafref)

    YANG Description: Identifies an affinity or anti-affinity group to
which the affinity or anti-affinity rule applies.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/vdu_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies an affinity or anti-affinity group to
which the affinity or anti-affinity rule applies.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_vdu_profile_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/vdu-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__min_number_of_instances', '__max_number_of_instances',
                 '__local_affinity_or_anti_affinity_rule', '__affinity_or_anti_affinity_group',)

    _yang_name = 'vdu-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'vdu-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/vdu_profile/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/vdu_profile/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_min_number_of_instances(self):
        """
    Getter method for min_number_of_instances, mapped from YANG variable /nsd/vnfd/df/vdu_profile/min_number_of_instances (uint16)

    YANG Description: Minimum number of instances of the VNFC based on this
VDU that is permitted to exist for this flavour.
    """
        return self.__min_number_of_instances

    def _set_min_number_of_instances(self, v, load=False):
        """
    Setter method for min_number_of_instances, mapped from YANG variable /nsd/vnfd/df/vdu_profile/min_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_number_of_instances() directly.

    YANG Description: Minimum number of instances of the VNFC based on this
VDU that is permitted to exist for this flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__min_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_number_of_instances(self):
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_max_number_of_instances(self):
        """
    Getter method for max_number_of_instances, mapped from YANG variable /nsd/vnfd/df/vdu_profile/max_number_of_instances (uint16)
    """
        return self.__max_number_of_instances

    def _set_max_number_of_instances(self, v, load=False):
        """
    Setter method for max_number_of_instances, mapped from YANG variable /nsd/vnfd/df/vdu_profile/max_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_number_of_instances() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__max_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_number_of_instances(self):
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/vdu_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/vdu_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    min_number_of_instances = __builtin__.property(_get_min_number_of_instances, _set_min_number_of_instances)
    max_number_of_instances = __builtin__.property(_get_max_number_of_instances, _set_max_number_of_instances)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)

    _pyangbind_elements = OrderedDict([('id', id), ('min_number_of_instances', min_number_of_instances),
                                       ('max_number_of_instances', max_number_of_instances),
                                       ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_max_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_max_bit_rate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/max-bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'max-bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'max-bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_min_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_min_bit_rate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/min-bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'min-bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'min-bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_l2_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/virtual-link-protocol-data/l2-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__network_type', '__vlan_transparent', '__mtu',)

    _yang_name = 'l2-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l2-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)

    YANG Description: Network name associated with this L2 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_network_type(self):
        """
    Getter method for network_type, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        return self.__network_type

    def _set_network_type(self, v, load=False):
        """
    Setter method for network_type, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_type() directly.

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {},
                                                                          'gre': {}}, ), is_leaf=True,
                             yang_name="network-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__network_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_type(self):
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)

    def _get_vlan_transparent(self):
        """
    Getter method for vlan_transparent, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        return self.__vlan_transparent

    def _set_vlan_transparent(self, v, load=False):
        """
    Setter method for vlan_transparent, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_transparent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_transparent() directly.

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vlan_transparent must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__vlan_transparent = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vlan_transparent(self):
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_mtu(self):
        """
    Getter method for mtu, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        return self.__mtu

    def _set_mtu(self, v, load=False):
        """
    Setter method for mtu, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16), is_leaf=True, yang_name="mtu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mtu must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__mtu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mtu(self):
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint16', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    network_type = __builtin__.property(_get_network_type, _set_network_type)
    vlan_transparent = __builtin__.property(_get_vlan_transparent, _set_vlan_transparent)
    mtu = __builtin__.property(_get_mtu, _set_mtu)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('network_type', network_type), ('vlan_transparent', vlan_transparent), ('mtu', mtu), ])


class yc_l3_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/virtual-link-protocol-data/l3-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__ip_version', '__cidr', '__ip_allocation_pools', '__gateway_ip',
        '__dhcp_enabled', '__ipv6_address_mode',)

    _yang_name = 'l3-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='inet:ip-address', is_config=True)
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                           yang_type='boolean', is_config=True)
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l3-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)

    YANG Description: Network name associated with this L3 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_ip_version(self):
        """
    Getter method for ip_version, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)

    YANG Description: Specifies IP version of this L3 protocol.
Value:
 IPV4.
 IPV6.
    """
        return self.__ip_version

    def _set_ip_version(self, v, load=False):
        """
    Setter method for ip_version, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.

    YANG Description: Specifies IP version of this L3 protocol.
Value:
 IPV4.
 IPV6.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_version must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_version(self):
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_cidr(self):
        """
    Getter method for cidr, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        return self.__cidr

    def _set_cidr(self, v, load=False):
        """
    Setter method for cidr, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cidr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cidr() directly.

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cidr must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__cidr = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cidr(self):
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_ip_allocation_pools(self):
        """
    Getter method for ip_allocation_pools, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        return self.__ip_allocation_pools

    def _set_ip_allocation_pools(self, v, load=False):
        """
    Setter method for ip_allocation_pools, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_allocation_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_allocation_pools() directly.

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_allocation_pools must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__ip_allocation_pools = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_allocation_pools(self):
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_gateway_ip(self):
        """
    Getter method for gateway_ip, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        return self.__gateway_ip

    def _set_gateway_ip(self, v, load=False):
        """
    Setter method for gateway_ip, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_ip() directly.

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
                'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                      RestrictedClassType(base_type=six.text_type, restriction_dict={
                                          'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                             is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='inet:ip-address', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """gateway_ip must be of a type compatible with inet:ip-address""",
                'defined-type': "inet:ip-address",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='inet:ip-address', is_config=True)""",
            })

        self.__gateway_ip = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_gateway_ip(self):
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='inet:ip-address', is_config=True)

    def _get_dhcp_enabled(self):
        """
    Getter method for dhcp_enabled, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        return self.__dhcp_enabled

    def _set_dhcp_enabled(self, v, load=False):
        """
    Setter method for dhcp_enabled, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enabled() directly.

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """dhcp_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__dhcp_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_dhcp_enabled(self):
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                           yang_type='boolean', is_config=True)

    def _get_ipv6_address_mode(self):
        """
    Getter method for ipv6_address_mode, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)

    YANG Description: Specifies IPv6 address mode. Possible values:
 SLAAC.
 DHCPV6-STATEFUL.
 DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        return self.__ipv6_address_mode

    def _set_ipv6_address_mode(self, v, load=False):
        """
    Setter method for ipv6_address_mode, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address_mode() directly.

    YANG Description: Specifies IPv6 address mode. Possible values:
 SLAAC.
 DHCPV6-STATEFUL.
 DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'slaac': {}, 'dhcpv6-stateful': {},
                                                                          'dhcpv6-stateless': {}}, ), is_leaf=True,
                             yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ipv6_address_mode must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}},), is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ipv6_address_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ipv6_address_mode(self):
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
    cidr = __builtin__.property(_get_cidr, _set_cidr)
    ip_allocation_pools = __builtin__.property(_get_ip_allocation_pools, _set_ip_allocation_pools)
    gateway_ip = __builtin__.property(_get_gateway_ip, _set_gateway_ip)
    dhcp_enabled = __builtin__.property(_get_dhcp_enabled, _set_dhcp_enabled)
    ipv6_address_mode = __builtin__.property(_get_ipv6_address_mode, _set_ipv6_address_mode)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('ip_version', ip_version), ('cidr', cidr), ('ip_allocation_pools', ip_allocation_pools),
         ('gateway_ip', gateway_ip), ('dhcp_enabled', dhcp_enabled), ('ipv6_address_mode', ipv6_address_mode), ])


class yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile/virtual-link-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__associated_layer_protocol', '__l2_protocol_data', '__l3_protocol_data',)

    _yang_name = 'virtual-link-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)

    def _get_l2_protocol_data(self):
        """
    Getter method for l2_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        return self.__l2_protocol_data

    def _set_l2_protocol_data(self, v, load=False):
        """
    Setter method for l2_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_protocol_data() directly.

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
                             is_container='container', yang_name="l2-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data, is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l2_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_protocol_data(self):
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_l3_protocol_data(self):
        """
    Getter method for l3_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        return self.__l3_protocol_data

    def _set_l3_protocol_data(self, v, load=False):
        """
    Setter method for l3_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_protocol_data() directly.

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
                             is_container='container', yang_name="l3-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data, is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l3_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_protocol_data(self):
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    l2_protocol_data = __builtin__.property(_get_l2_protocol_data, _set_l2_protocol_data)
    l3_protocol_data = __builtin__.property(_get_l3_protocol_data, _set_l3_protocol_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('l2_protocol_data', l2_protocol_data),
         ('l3_protocol_data', l3_protocol_data), ])


class yc_virtual_link_profile_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/virtual-link-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__flavour', '__local_affinity_or_anti_affinity_rule',
                 '__affinity_or_anti_affinity_group', '__max_bit_rate_requirements', '__min_bit_rate_requirements',
                 '__virtual_link_protocol_data',)

    _yang_name = 'virtual-link-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__flavour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)
        self.__max_bit_rate_requirements = YANGDynClass(
            base=yc_max_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_max_bit_rate_requirements,
            is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__min_bit_rate_requirements = YANGDynClass(
            base=yc_min_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_min_bit_rate_requirements,
            is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'virtual-link-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/id (leafref)

    YANG Description: Uniquely identifies a Vnf VLD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a Vnf VLD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_flavour(self):
        """
    Getter method for flavour, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/flavour (leafref)

    YANG Description: Identifies a flavour within the VnfVirtualLinkDesc.
    """
        return self.__flavour

    def _set_flavour(self, v, load=False):
        """
    Setter method for flavour, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/flavour (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour() directly.

    YANG Description: Identifies a flavour within the VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__flavour = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour(self):
        self.__flavour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                      defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    def _get_max_bit_rate_requirements(self):
        """
    Getter method for max_bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements (container)

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__max_bit_rate_requirements

    def _set_max_bit_rate_requirements(self, v, load=False):
        """
    Setter method for max_bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/max_bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_bit_rate_requirements() directly.

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_max_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_max_bit_rate_requirements,
                             is_container='container', yang_name="max-bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_max_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_max_bit_rate_requirements, is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__max_bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_bit_rate_requirements(self):
        self.__max_bit_rate_requirements = YANGDynClass(
            base=yc_max_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_max_bit_rate_requirements,
            is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_min_bit_rate_requirements(self):
        """
    Getter method for min_bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements (container)

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__min_bit_rate_requirements

    def _set_min_bit_rate_requirements(self, v, load=False):
        """
    Setter method for min_bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/min_bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_bit_rate_requirements() directly.

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_min_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_min_bit_rate_requirements,
                             is_container='container', yang_name="min-bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_min_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_min_bit_rate_requirements, is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__min_bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_bit_rate_requirements(self):
        self.__min_bit_rate_requirements = YANGDynClass(
            base=yc_min_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_min_bit_rate_requirements,
            is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_virtual_link_protocol_data(self):
        """
    Getter method for virtual_link_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data (container)

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        return self.__virtual_link_protocol_data

    def _set_virtual_link_protocol_data(self, v, load=False):
        """
    Setter method for virtual_link_protocol_data, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile/virtual_link_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_protocol_data() directly.

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data,
                             is_container='container', yang_name="virtual-link-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data, is_container='container', yang_name="virtual-link-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__virtual_link_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_protocol_data(self):
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    flavour = __builtin__.property(_get_flavour, _set_flavour)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    max_bit_rate_requirements = __builtin__.property(_get_max_bit_rate_requirements, _set_max_bit_rate_requirements)
    min_bit_rate_requirements = __builtin__.property(_get_min_bit_rate_requirements, _set_min_bit_rate_requirements)
    virtual_link_protocol_data = __builtin__.property(_get_virtual_link_protocol_data, _set_virtual_link_protocol_data)

    _pyangbind_elements = OrderedDict([('id', id), ('flavour', flavour),
                                       ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
                                       ('max_bit_rate_requirements', max_bit_rate_requirements),
                                       ('min_bit_rate_requirements', min_bit_rate_requirements),
                                       ('virtual_link_protocol_data', virtual_link_protocol_data), ])


class yc_vdu_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_vdu_level(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/instantiation-level/vdu-level. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sets the number of instances for the VDU in this
instantiation level.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vdu_id', '__number_of_instances',)

    _yang_name = 'vdu-level'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                     defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'instantiation-level', 'vdu-level']

    def _get_vdu_id(self):
        """
    Getter method for vdu_id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level/vdu_id (leafref)

    YANG Description: Uniquely identifies a VDU.
    """
        return self.__vdu_id

    def _set_vdu_id(self, v, load=False):
        """
    Setter method for vdu_id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.

    YANG Description: Uniquely identifies a VDU.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_id(self):
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                     defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level/number_of_instances (uint16)

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for this level.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level/number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for this level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True, yang_name="number-of-instances",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    vdu_id = __builtin__.property(_get_vdu_id, _set_vdu_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict([('vdu_id', vdu_id), ('number_of_instances', number_of_instances), ])


class yc_scaling_info_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_scaling_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/instantiation-level/scaling-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__scaling_aspect_id', '__scale_level',)

    _yang_name = 'scaling-info'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__scaling_aspect_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, is_keyval=True,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__scale_level = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'instantiation-level', 'scaling-info']

    def _get_scaling_aspect_id(self):
        """
    Getter method for scaling_aspect_id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info/scaling_aspect_id (leafref)

    YANG Description: Identifier of the scaling aspect.
    """
        return self.__scaling_aspect_id

    def _set_scaling_aspect_id(self, v, load=False):
        """
    Setter method for scaling_aspect_id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info/scaling_aspect_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_aspect_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_aspect_id() directly.

    YANG Description: Identifier of the scaling aspect.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_aspect_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__scaling_aspect_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_aspect_id(self):
        self.__scaling_aspect_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, is_keyval=True,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_scale_level(self):
        """
    Getter method for scale_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info/scale_level (uint32)

    YANG Description: The scale level, greater than or equal to 0.
    """
        return self.__scale_level

    def _set_scale_level(self, v, load=False):
        """
    Setter method for scale_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info/scale_level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_level() directly.

    YANG Description: The scale level, greater than or equal to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="scale-level",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_level must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__scale_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_level(self):
        self.__scale_level = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    scaling_aspect_id = __builtin__.property(_get_scaling_aspect_id, _set_scaling_aspect_id)
    scale_level = __builtin__.property(_get_scale_level, _set_scale_level)

    _pyangbind_elements = OrderedDict([('scaling_aspect_id', scaling_aspect_id), ('scale_level', scale_level), ])


class yc_instantiation_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/instantiation-level. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu_level', '__scaling_info',)

    _yang_name = 'instantiation-level'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vdu_level = YANGDynClass(
            base=YANGListType("vdu_id", yc_vdu_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_vdu_level,
                              yang_name="vdu-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list',
            yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__scaling_info = YANGDynClass(base=YANGListType("scaling_aspect_id",
                                                             yc_scaling_info_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_scaling_info,
                                                             yang_name="scaling-info", parent=self, is_container='list',
                                                             user_ordered=False, path_helper=self._path_helper,
                                                             yang_keys='scaling-aspect-id', extensions=None),
                                           is_container='list', yang_name="scaling-info", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, extensions=None,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                           yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'instantiation-level']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/id (string)

    YANG Description: Uniquely identifies a level with the DF.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/instantiation_level/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a level with the DF.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/df/instantiation_level/description (string)

    YANG Description: Human readable description of the instantiation level
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/df/instantiation_level/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the instantiation level
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vdu_level(self):
        """
    Getter method for vdu_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level (list)

    YANG Description: Sets the number of instances for the VDU in this
instantiation level.
    """
        return self.__vdu_level

    def _set_vdu_level(self, v, load=False):
        """
    Setter method for vdu_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level/vdu_level (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_level() directly.

    YANG Description: Sets the number of instances for the VDU in this
instantiation level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("vdu_id",
                                                  yc_vdu_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_vdu_level,
                                                  yang_name="vdu-level", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id',
                                                  extensions=None), is_container='list', yang_name="vdu-level",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_level must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("vdu_id",yc_vdu_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_vdu_level, yang_name="vdu-level", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list', yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_level(self):
        self.__vdu_level = YANGDynClass(
            base=YANGListType("vdu_id", yc_vdu_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_vdu_level,
                              yang_name="vdu-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list',
            yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_scaling_info(self):
        """
    Getter method for scaling_info, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info (list)

    YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
    """
        return self.__scaling_info

    def _set_scaling_info(self, v, load=False):
        """
    Setter method for scaling_info, mapped from YANG variable /nsd/vnfd/df/instantiation_level/scaling_info (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_info() directly.

    YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("scaling_aspect_id",
                                                  yc_scaling_info_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_scaling_info,
                                                  yang_name="scaling-info", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='scaling-aspect-id', extensions=None), is_container='list',
                             yang_name="scaling-info", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_info must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("scaling_aspect_id",yc_scaling_info_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_scaling_info, yang_name="scaling-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='scaling-aspect-id', extensions=None), is_container='list', yang_name="scaling-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__scaling_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_info(self):
        self.__scaling_info = YANGDynClass(base=YANGListType("scaling_aspect_id",
                                                             yc_scaling_info_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level_scaling_info,
                                                             yang_name="scaling-info", parent=self, is_container='list',
                                                             user_ordered=False, path_helper=self._path_helper,
                                                             yang_keys='scaling-aspect-id', extensions=None),
                                           is_container='list', yang_name="scaling-info", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, extensions=None,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                           yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu_level = __builtin__.property(_get_vdu_level, _set_vdu_level)
    scaling_info = __builtin__.property(_get_scaling_info, _set_scaling_info)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('vdu_level', vdu_level), ('scaling_info', scaling_info), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/instantiate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'instantiate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_instantiate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/instantiate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the InstantiateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'instantiate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'instantiate-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/scale-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_scale_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/scale-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the ScaleVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__scaling_by_more_than_one_step_supported',)

    _yang_name = 'scale-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)
        self.__scaling_by_more_than_one_step_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"),
                                                                      is_leaf=True,
                                                                      yang_name="scaling-by-more-than-one-step-supported",
                                                                      parent=self, path_helper=self._path_helper,
                                                                      extmethods=self._extmethods, register_paths=True,
                                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                      defining_module='etsi-nfv-nsd',
                                                                      yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    def _get_scaling_by_more_than_one_step_supported(self):
        """
    Getter method for scaling_by_more_than_one_step_supported, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/scaling_by_more_than_one_step_supported (boolean)

    YANG Description: Signals whether passing a value larger than one in
the numScalingSteps parameter of the ScaleVnf
operation is supported by this VNF.
Default is FALSE, i.e. 'not supported'.
    """
        return self.__scaling_by_more_than_one_step_supported

    def _set_scaling_by_more_than_one_step_supported(self, v, load=False):
        """
    Setter method for scaling_by_more_than_one_step_supported, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config/scaling_by_more_than_one_step_supported (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_by_more_than_one_step_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_by_more_than_one_step_supported() directly.

    YANG Description: Signals whether passing a value larger than one in
the numScalingSteps parameter of the ScaleVnf
operation is supported by this VNF.
Default is FALSE, i.e. 'not supported'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True,
                             yang_name="scaling-by-more-than-one-step-supported", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_by_more_than_one_step_supported must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="scaling-by-more-than-one-step-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__scaling_by_more_than_one_step_supported = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_by_more_than_one_step_supported(self):
        self.__scaling_by_more_than_one_step_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"),
                                                                      is_leaf=True,
                                                                      yang_name="scaling-by-more-than-one-step-supported",
                                                                      parent=self, path_helper=self._path_helper,
                                                                      extmethods=self._extmethods, register_paths=True,
                                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                      defining_module='etsi-nfv-nsd',
                                                                      yang_type='boolean', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    scaling_by_more_than_one_step_supported = __builtin__.property(_get_scaling_by_more_than_one_step_supported,
                                                                   _set_scaling_by_more_than_one_step_supported)

    _pyangbind_elements = OrderedDict([('parameter', parameter), (
        'scaling_by_more_than_one_step_supported', scaling_by_more_than_one_step_supported), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/scale-vnf-to-level-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-to-level-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_scale_vnf_to_level_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/scale-vnf-to-level-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__arbitrary_target_levels_supported',)

    _yang_name = 'scale-vnf-to-level-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)
        self.__arbitrary_target_levels_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                                yang_name="arbitrary-target-levels-supported",
                                                                parent=self, path_helper=self._path_helper,
                                                                extmethods=self._extmethods, register_paths=True,
                                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                                is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-to-level-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    def _get_arbitrary_target_levels_supported(self):
        """
    Getter method for arbitrary_target_levels_supported, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/arbitrary_target_levels_supported (boolean)

    YANG Description: Signals whether scaling according to the parameter
'scaleInfo' is supported by this VNF.
    """
        return self.__arbitrary_target_levels_supported

    def _set_arbitrary_target_levels_supported(self, v, load=False):
        """
    Setter method for arbitrary_target_levels_supported, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/arbitrary_target_levels_supported (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_arbitrary_target_levels_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_arbitrary_target_levels_supported() directly.

    YANG Description: Signals whether scaling according to the parameter
'scaleInfo' is supported by this VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True,
                             yang_name="arbitrary-target-levels-supported", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """arbitrary_target_levels_supported must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="arbitrary-target-levels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__arbitrary_target_levels_supported = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_arbitrary_target_levels_supported(self):
        self.__arbitrary_target_levels_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                                yang_name="arbitrary-target-levels-supported",
                                                                parent=self, path_helper=self._path_helper,
                                                                extmethods=self._extmethods, register_paths=True,
                                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                                is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    arbitrary_target_levels_supported = __builtin__.property(_get_arbitrary_target_levels_supported,
                                                             _set_arbitrary_target_levels_supported)

    _pyangbind_elements = OrderedDict(
        [('parameter', parameter), ('arbitrary_target_levels_supported', arbitrary_target_levels_supported), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/heal-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'heal-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_heal_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/heal-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__cause',)

    _yang_name = 'heal-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)
        self.__cause = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                    yang_name="cause", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'heal-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    def _get_cause(self):
        """
    Getter method for cause, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/cause (string)

    YANG Description: Supported 'cause' parameter values.
    """
        return self.__cause

    def _set_cause(self, v, load=False):
        """
    Setter method for cause, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config/cause (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cause is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cause() directly.

    YANG Description: Supported 'cause' parameter values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cause must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__cause = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cause(self):
        self.__cause = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                    yang_name="cause", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    cause = __builtin__.property(_get_cause, _set_cause)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ('cause', cause), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/terminate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'terminate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_terminate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/terminate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__min_graceful_termination', '__max_recommended_graceful_termination',
                 '__parameter',)

    _yang_name = 'terminate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)
        self.__max_recommended_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'terminate-vnf-op-config']

    def _get_min_graceful_termination(self):
        """
    Getter method for min_graceful_termination, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/min_graceful_termination (yang:timeticks)

    YANG Description: Minimum timeout value for graceful termination of
a VNF instance.
    """
        return self.__min_graceful_termination

    def _set_min_graceful_termination(self, v, load=False):
        """
    Setter method for min_graceful_termination, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/min_graceful_termination (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_termination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_termination() directly.

    YANG Description: Minimum timeout value for graceful termination of
a VNF instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True,
                             yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_graceful_termination must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__min_graceful_termination = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_graceful_termination(self):
        self.__min_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)

    def _get_max_recommended_graceful_termination(self):
        """
    Getter method for max_recommended_graceful_termination, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/max_recommended_graceful_termination (yang:timeticks)

    YANG Description: Maximum recommended timeout value that can be needed
to gracefully terminate a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator
facilitating the selection of optimal timeout value.
This value is not used as constraint.
    """
        return self.__max_recommended_graceful_termination

    def _set_max_recommended_graceful_termination(self, v, load=False):
        """
    Setter method for max_recommended_graceful_termination, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/max_recommended_graceful_termination (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_termination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_termination() directly.

    YANG Description: Maximum recommended timeout value that can be needed
to gracefully terminate a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator
facilitating the selection of optimal timeout value.
This value is not used as constraint.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True,
                             yang_name="max-recommended-graceful-termination", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_recommended_graceful_termination must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__max_recommended_graceful_termination = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_recommended_graceful_termination(self):
        self.__max_recommended_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    min_graceful_termination = __builtin__.property(_get_min_graceful_termination, _set_min_graceful_termination)
    max_recommended_graceful_termination = __builtin__.property(_get_max_recommended_graceful_termination,
                                                                _set_max_recommended_graceful_termination)
    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('min_graceful_termination', min_graceful_termination),
                                       ('max_recommended_graceful_termination', max_recommended_graceful_termination),
                                       ('parameter', parameter), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/operate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_operate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/operate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__min_graceful_stop_timeout', '__max_recommended_graceful_stop_timeout',
        '__parameter',)

    _yang_name = 'operate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config']

    def _get_min_graceful_stop_timeout(self):
        """
    Getter method for min_graceful_stop_timeout, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/min_graceful_stop_timeout (yang:timeticks)

    YANG Description: Minimum timeout value for graceful stop of a VNF
instance.
    """
        return self.__min_graceful_stop_timeout

    def _set_min_graceful_stop_timeout(self, v, load=False):
        """
    Setter method for min_graceful_stop_timeout, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/min_graceful_stop_timeout (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_stop_timeout() directly.

    YANG Description: Minimum timeout value for graceful stop of a VNF
instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True,
                             yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_graceful_stop_timeout must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__min_graceful_stop_timeout = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_graceful_stop_timeout(self):
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)

    def _get_max_recommended_graceful_stop_timeout(self):
        """
    Getter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/max_recommended_graceful_stop_timeout (yang:timeticks)

    YANG Description: Maximum recommended timeout value that can be
needed to gracefully stop a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator facilitating
the selection of optimal timeout value. This value
is not used as constraint.
    """
        return self.__max_recommended_graceful_stop_timeout

    def _set_max_recommended_graceful_stop_timeout(self, v, load=False):
        """
    Setter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/max_recommended_graceful_stop_timeout (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_stop_timeout() directly.

    YANG Description: Maximum recommended timeout value that can be
needed to gracefully stop a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator facilitating
the selection of optimal timeout value. This value
is not used as constraint.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True,
                             yang_name="max-recommended-graceful-stop-timeout", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_recommended_graceful_stop_timeout must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__max_recommended_graceful_stop_timeout = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_recommended_graceful_stop_timeout(self):
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='yang:timeticks', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    min_graceful_stop_timeout = __builtin__.property(_get_min_graceful_stop_timeout, _set_min_graceful_stop_timeout)
    max_recommended_graceful_stop_timeout = __builtin__.property(_get_max_recommended_graceful_stop_timeout,
                                                                 _set_max_recommended_graceful_stop_timeout)
    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('min_graceful_stop_timeout', min_graceful_stop_timeout),
                                       ('max_recommended_graceful_stop_timeout', max_recommended_graceful_stop_timeout),
                                       ('parameter', parameter), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/change-vnf-flavour-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'change-vnf-flavour-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_vnf_flavour_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/change-vnf-flavour-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'change-vnf-flavour-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'change-vnf-flavour-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/change-ext-vnf-connectivity-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'change-ext-vnf-connectivity-op-config',
                    'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_ext_vnf_connectivity_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration/change-ext-vnf-connectivity-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'change-ext-vnf-connectivity-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration', 'change-ext-vnf-connectivity-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_lcm_operations_configuration_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/lcm-operations-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__instantiate_vnf_op_config', '__scale_vnf_op_config',
                 '__scale_vnf_to_level_op_config', '__heal_vnf_op_config', '__terminate_vnf_op_config',
                 '__operate_vnf_op_config', '__change_vnf_flavour_op_config',
                 '__change_ext_vnf_connectivity_op_config',)

    _yang_name = 'lcm-operations-configuration'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__instantiate_vnf_op_config = YANGDynClass(
            base=yc_instantiate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
            is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__scale_vnf_op_config = YANGDynClass(
            base=yc_scale_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
            is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__scale_vnf_to_level_op_config = YANGDynClass(
            base=yc_scale_vnf_to_level_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
            is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__heal_vnf_op_config = YANGDynClass(
            base=yc_heal_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
            is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__terminate_vnf_op_config = YANGDynClass(
            base=yc_terminate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
            is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__operate_vnf_op_config = YANGDynClass(
            base=yc_operate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
            is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__change_vnf_flavour_op_config = YANGDynClass(
            base=yc_change_vnf_flavour_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
            is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__change_ext_vnf_connectivity_op_config = YANGDynClass(
            base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
            is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'lcm-operations-configuration']

    def _get_instantiate_vnf_op_config(self):
        """
    Getter method for instantiate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config (container)

    YANG Description: Configuration parameters for the InstantiateVnf
operation.
    """
        return self.__instantiate_vnf_op_config

    def _set_instantiate_vnf_op_config(self, v, load=False):
        """
    Setter method for instantiate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiate_vnf_op_config() directly.

    YANG Description: Configuration parameters for the InstantiateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_instantiate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
                             is_container='container', yang_name="instantiate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_instantiate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config, is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__instantiate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiate_vnf_op_config(self):
        self.__instantiate_vnf_op_config = YANGDynClass(
            base=yc_instantiate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
            is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_scale_vnf_op_config(self):
        """
    Getter method for scale_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config (container)

    YANG Description: Configuration parameters for the ScaleVnf operation.
    """
        return self.__scale_vnf_op_config

    def _set_scale_vnf_op_config(self, v, load=False):
        """
    Setter method for scale_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_vnf_op_config() directly.

    YANG Description: Configuration parameters for the ScaleVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_scale_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
                             is_container='container', yang_name="scale-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_scale_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config, is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__scale_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_vnf_op_config(self):
        self.__scale_vnf_op_config = YANGDynClass(
            base=yc_scale_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
            is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_scale_vnf_to_level_op_config(self):
        """
    Getter method for scale_vnf_to_level_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
    """
        return self.__scale_vnf_to_level_op_config

    def _set_scale_vnf_to_level_op_config(self, v, load=False):
        """
    Setter method for scale_vnf_to_level_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_vnf_to_level_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_vnf_to_level_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_scale_vnf_to_level_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
                             is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_vnf_to_level_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_scale_vnf_to_level_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config, is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__scale_vnf_to_level_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_vnf_to_level_op_config(self):
        self.__scale_vnf_to_level_op_config = YANGDynClass(
            base=yc_scale_vnf_to_level_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
            is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_heal_vnf_op_config(self):
        """
    Getter method for heal_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
    """
        return self.__heal_vnf_op_config

    def _set_heal_vnf_op_config(self, v, load=False):
        """
    Setter method for heal_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/heal_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_heal_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_heal_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_heal_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
                             is_container='container', yang_name="heal-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """heal_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_heal_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config, is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__heal_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_heal_vnf_op_config(self):
        self.__heal_vnf_op_config = YANGDynClass(
            base=yc_heal_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
            is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_terminate_vnf_op_config(self):
        """
    Getter method for terminate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
    """
        return self.__terminate_vnf_op_config

    def _set_terminate_vnf_op_config(self, v, load=False):
        """
    Setter method for terminate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/terminate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_terminate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
                             is_container='container', yang_name="terminate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """terminate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_terminate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config, is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__terminate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_terminate_vnf_op_config(self):
        self.__terminate_vnf_op_config = YANGDynClass(
            base=yc_terminate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
            is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_operate_vnf_op_config(self):
        """
    Getter method for operate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
    """
        return self.__operate_vnf_op_config

    def _set_operate_vnf_op_config(self, v, load=False):
        """
    Setter method for operate_vnf_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/operate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operate_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_operate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
                             is_container='container', yang_name="operate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """operate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_operate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config, is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__operate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_operate_vnf_op_config(self):
        self.__operate_vnf_op_config = YANGDynClass(
            base=yc_operate_vnf_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
            is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_change_vnf_flavour_op_config(self):
        """
    Getter method for change_vnf_flavour_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config (container)

    YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
    """
        return self.__change_vnf_flavour_op_config

    def _set_change_vnf_flavour_op_config(self, v, load=False):
        """
    Setter method for change_vnf_flavour_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_vnf_flavour_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_vnf_flavour_op_config() directly.

    YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_change_vnf_flavour_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
                             is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """change_vnf_flavour_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_change_vnf_flavour_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config, is_container='container', yang_name="change-vnf-flavour-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__change_vnf_flavour_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_change_vnf_flavour_op_config(self):
        self.__change_vnf_flavour_op_config = YANGDynClass(
            base=yc_change_vnf_flavour_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
            is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_change_ext_vnf_connectivity_op_config(self):
        """
    Getter method for change_ext_vnf_connectivity_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config (container)

    YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
    """
        return self.__change_ext_vnf_connectivity_op_config

    def _set_change_ext_vnf_connectivity_op_config(self, v, load=False):
        """
    Setter method for change_ext_vnf_connectivity_op_config, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_ext_vnf_connectivity_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_ext_vnf_connectivity_op_config() directly.

    YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
                             is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """change_ext_vnf_connectivity_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config, is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__change_ext_vnf_connectivity_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_change_ext_vnf_connectivity_op_config(self):
        self.__change_ext_vnf_connectivity_op_config = YANGDynClass(
            base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
            is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    instantiate_vnf_op_config = __builtin__.property(_get_instantiate_vnf_op_config, _set_instantiate_vnf_op_config)
    scale_vnf_op_config = __builtin__.property(_get_scale_vnf_op_config, _set_scale_vnf_op_config)
    scale_vnf_to_level_op_config = __builtin__.property(_get_scale_vnf_to_level_op_config,
                                                        _set_scale_vnf_to_level_op_config)
    heal_vnf_op_config = __builtin__.property(_get_heal_vnf_op_config, _set_heal_vnf_op_config)
    terminate_vnf_op_config = __builtin__.property(_get_terminate_vnf_op_config, _set_terminate_vnf_op_config)
    operate_vnf_op_config = __builtin__.property(_get_operate_vnf_op_config, _set_operate_vnf_op_config)
    change_vnf_flavour_op_config = __builtin__.property(_get_change_vnf_flavour_op_config,
                                                        _set_change_vnf_flavour_op_config)
    change_ext_vnf_connectivity_op_config = __builtin__.property(_get_change_ext_vnf_connectivity_op_config,
                                                                 _set_change_ext_vnf_connectivity_op_config)

    _pyangbind_elements = OrderedDict(
        [('instantiate_vnf_op_config', instantiate_vnf_op_config), ('scale_vnf_op_config', scale_vnf_op_config),
         ('scale_vnf_to_level_op_config', scale_vnf_to_level_op_config), ('heal_vnf_op_config', heal_vnf_op_config),
         ('terminate_vnf_op_config', terminate_vnf_op_config), ('operate_vnf_op_config', operate_vnf_op_config),
         ('change_vnf_flavour_op_config', change_vnf_flavour_op_config),
         ('change_ext_vnf_connectivity_op_config', change_ext_vnf_connectivity_op_config), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_affinity_or_anti_affinity_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__type', '__scope',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='affinity-type', is_config=True)
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='affinity-scope', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/id (string)

    YANG Description: Identifies an affinity or anti-affinity group to which
the affinity or anti-affinity rule applies.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies an affinity or anti-affinity group to which
the affinity or anti-affinity rule applies.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='affinity-type', is_config=True)

    def _get_scope(self):
        """
    Getter method for scope, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__scope

    def _set_scope(self, v, load=False):
        """
    Setter method for scope, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group/scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scope(self):
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='affinity-scope', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    type = __builtin__.property(_get_type, _set_type)
    scope = __builtin__.property(_get_scope, _set_scope)

    _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('scope', scope), ])


class yc_indicator_etsi_nfv_nsd__nsd_vnfd_df_indicator(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/indicator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__indicator_value', '__source',)

    _yang_name = 'indicator'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__indicator_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value",
                                              parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'indicator']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/indicator/id (string)

    YANG Description: Unique identifier.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/indicator/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/indicator/name (string)

    YANG Description: The human readable name of the VnfIndicator.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/indicator/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The human readable name of the VnfIndicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_indicator_value(self):
        """
    Getter method for indicator_value, mapped from YANG variable /nsd/vnfd/df/indicator/indicator_value (string)

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        return self.__indicator_value

    def _set_indicator_value(self, v, load=False):
        """
    Setter method for indicator_value, mapped from YANG variable /nsd/vnfd/df/indicator/indicator_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator_value() directly.

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="indicator-value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__indicator_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator_value(self):
        self.__indicator_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value",
                                              parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_source(self):
        """
    Getter method for source, mapped from YANG variable /nsd/vnfd/df/indicator/source (enumeration)

    YANG Description: Describe the source of the indicator. The possible
values are:
 VNF.
 EM.
 Both.

This tells the consumer where to send the subscription
request.
    """
        return self.__source

    def _set_source(self, v, load=False):
        """
    Setter method for source, mapped from YANG variable /nsd/vnfd/df/indicator/source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Describe the source of the indicator. The possible
values are:
 VNF.
 EM.
 Both.

This tells the consumer where to send the subscription
request.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                             is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """source must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf': {}, 'em': {}, 'both': {}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__source = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_source(self):
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    indicator_value = __builtin__.property(_get_indicator_value, _set_indicator_value)
    source = __builtin__.property(_get_source, _set_source)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('indicator_value', indicator_value), ('source', source), ])


class yc_interface_details_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces_interface_details(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/supported-vnf-interfaces/interface-details. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'interface-details'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'supported-vnf-interfaces', 'interface-details']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_supported_vnf_interfaces_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/supported-vnf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__cpd_id', '__interface_details',)

    _yang_name = 'supported-vnf-interfaces'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'vnf-configuration': {},
                                                                             'vnf-indicator': {}}, ), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='enumeration', is_config=True)
        self.__cpd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                     yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)
        self.__interface_details = YANGDynClass(base=YANGListType("key",
                                                                  yc_interface_details_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces_interface_details,
                                                                  yang_name="interface-details", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='key',
                                                                  extensions=None), is_container='list',
                                                yang_name="interface-details", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'supported-vnf-interfaces']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/name (enumeration)

    YANG Description: Identifies an interface produced by the VNF. Valid
values:
- VNF_CONFIGURATION
- VNF_INDICATOR
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/name (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identifies an interface produced by the VNF. Valid
values:
- VNF_CONFIGURATION
- VNF_INDICATOR
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf-configuration': {},
                                                                          'vnf-indicator': {}}, ), is_leaf=True,
                             yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf-configuration': {}, 'vnf-indicator': {}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'vnf-configuration': {},
                                                                             'vnf-indicator': {}}, ), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='enumeration', is_config=True)

    def _get_cpd_id(self):
        """
    Getter method for cpd_id, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/cpd_id (leafref)

    YANG Description: References one or more CPDs from which to instantiate
external CPs through which interface endpoints on the
VNF side can be reached by the VNFM.
    """
        return self.__cpd_id

    def _set_cpd_id(self, v, load=False):
        """
    Setter method for cpd_id, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_id() directly.

    YANG Description: References one or more CPDs from which to instantiate
external CPs through which interface endpoints on the
VNF side can be reached by the VNFM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd_id(self):
        self.__cpd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                     yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    def _get_interface_details(self):
        """
    Getter method for interface_details, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details (list)
    """
        return self.__interface_details

    def _set_interface_details(self, v, load=False):
        """
    Setter method for interface_details, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces/interface_details (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_details() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_interface_details_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces_interface_details,
                                                  yang_name="interface-details", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="interface-details",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """interface_details must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_interface_details_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces_interface_details, yang_name="interface-details", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="interface-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__interface_details = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_interface_details(self):
        self.__interface_details = YANGDynClass(base=YANGListType("key",
                                                                  yc_interface_details_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces_interface_details,
                                                                  yang_name="interface-details", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='key',
                                                                  extensions=None), is_container='list',
                                                yang_name="interface-details", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    cpd_id = __builtin__.property(_get_cpd_id, _set_cpd_id)
    interface_details = __builtin__.property(_get_interface_details, _set_interface_details)

    _pyangbind_elements = OrderedDict([('name', name), ('cpd_id', cpd_id), ('interface_details', interface_details), ])


class yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_df_monitoring_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/monitoring-parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'monitoring-parameter']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_vdu_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect/aspect-delta-details/deltas/vdu-delta. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__number_of_instances',)

    _yang_name = 'vdu-delta'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas', 'vdu-delta']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/id (leafref)

    YANG Description: Uniquely identifies a VDU.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a VDU.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/number_of_instances (uint32)

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for an instantiation level or for a
scaling delta. Shall be zero or greater.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/number_of_instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for an instantiation level or for a
scaling delta. Shall be zero or greater.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                              int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True,
                             yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict([('id', id), ('number_of_instances', number_of_instances), ])


class yc_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect/aspect-delta-details/deltas/virtual-link-bit-rate-delta/bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas',
                    'virtual-link-bit-rate-delta', 'bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g.
bitrate of E-Line, root bitrate of E-Tree,
aggregate capacity of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g.
bitrate of E-Line, root bitrate of E-Tree,
aggregate capacity of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to
the link when applicable to the connectivity
type (e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to
the link when applicable to the connectivity
type (e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_virtual_link_bit_rate_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect/aspect-delta-details/deltas/virtual-link-bit-rate-delta. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__bit_rate_requirements',)

    _yang_name = 'virtual-link-bit-rate-delta'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__bit_rate_requirements = YANGDynClass(
            base=yc_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
            is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas',
                    'virtual-link-bit-rate-delta']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/id (string)

    YANG Description: Uniquely identifies a VnfVirtualLinkDesc.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_bit_rate_requirements(self):
        """
    Getter method for bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements (container)

    YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
    """
        return self.__bit_rate_requirements

    def _set_bit_rate_requirements(self, v, load=False):
        """
    Setter method for bit_rate_requirements, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bit_rate_requirements() directly.

    YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
                             is_container='container', yang_name="bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements, is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_bit_rate_requirements(self):
        self.__bit_rate_requirements = YANGDynClass(
            base=yc_bit_rate_requirements_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
            is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    bit_rate_requirements = __builtin__.property(_get_bit_rate_requirements, _set_bit_rate_requirements)

    _pyangbind_elements = OrderedDict([('id', id), ('bit_rate_requirements', bit_rate_requirements), ])


class yc_deltas_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect/aspect-delta-details/deltas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__vdu_delta', '__virtual_link_bit_rate_delta',)

    _yang_name = 'deltas'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vdu_delta = YANGDynClass(base=YANGListType("id",
                                                          yc_vdu_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                          yang_name="vdu-delta", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='id', extensions=None), is_container='list',
                                        yang_name="vdu-delta", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)
        self.__virtual_link_bit_rate_delta = YANGDynClass(base=YANGListType("id",
                                                                            yc_virtual_link_bit_rate_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                                            yang_name="virtual-link-bit-rate-delta",
                                                                            parent=self, is_container='list',
                                                                            user_ordered=False,
                                                                            path_helper=self._path_helper,
                                                                            yang_keys='id', extensions=None),
                                                          is_container='list', yang_name="virtual-link-bit-rate-delta",
                                                          parent=self, path_helper=self._path_helper,
                                                          extmethods=self._extmethods, register_paths=True,
                                                          extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='list',
                                                          is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/id (string)

    YANG Description: Identifier of this scaling delta.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this scaling delta.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vdu_delta(self):
        """
    Getter method for vdu_delta, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta (list)

    YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
    """
        return self.__vdu_delta

    def _set_vdu_delta(self, v, load=False):
        """
    Setter method for vdu_delta, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_delta() directly.

    YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_vdu_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                  yang_name="vdu-delta", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vdu-delta",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_delta must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta, yang_name="vdu-delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_delta = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_delta(self):
        self.__vdu_delta = YANGDynClass(base=YANGListType("id",
                                                          yc_vdu_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                          yang_name="vdu-delta", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='id', extensions=None), is_container='list',
                                        yang_name="vdu-delta", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='list', is_config=True)

    def _get_virtual_link_bit_rate_delta(self):
        """
    Getter method for virtual_link_bit_rate_delta, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta (list)

    YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
    """
        return self.__virtual_link_bit_rate_delta

    def _set_virtual_link_bit_rate_delta(self, v, load=False):
        """
    Setter method for virtual_link_bit_rate_delta, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_bit_rate_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_bit_rate_delta() directly.

    YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_virtual_link_bit_rate_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                  yang_name="virtual-link-bit-rate-delta", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="virtual-link-bit-rate-delta", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_bit_rate_delta must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_link_bit_rate_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta, yang_name="virtual-link-bit-rate-delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-link-bit-rate-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_bit_rate_delta = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_bit_rate_delta(self):
        self.__virtual_link_bit_rate_delta = YANGDynClass(base=YANGListType("id",
                                                                            yc_virtual_link_bit_rate_delta_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                                            yang_name="virtual-link-bit-rate-delta",
                                                                            parent=self, is_container='list',
                                                                            user_ordered=False,
                                                                            path_helper=self._path_helper,
                                                                            yang_keys='id', extensions=None),
                                                          is_container='list', yang_name="virtual-link-bit-rate-delta",
                                                          parent=self, path_helper=self._path_helper,
                                                          extmethods=self._extmethods, register_paths=True,
                                                          extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='list',
                                                          is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vdu_delta = __builtin__.property(_get_vdu_delta, _set_vdu_delta)
    virtual_link_bit_rate_delta = __builtin__.property(_get_virtual_link_bit_rate_delta,
                                                       _set_virtual_link_bit_rate_delta)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('vdu_delta', vdu_delta), ('virtual_link_bit_rate_delta', virtual_link_bit_rate_delta), ])


class yc_aspect_delta_details_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect/aspect-delta-details. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
  """
    __slots__ = ('_path_helper', '_extmethods', '__deltas', '__step_deltas',)

    _yang_name = 'aspect-delta-details'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__deltas = YANGDynClass(
            base=YANGListType("id", yc_deltas_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                              yang_name="deltas", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__step_deltas = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect', 'aspect-delta-details']

    def _get_deltas(self):
        """
    Getter method for deltas, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas (list)

    YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
    """
        return self.__deltas

    def _set_deltas(self, v, load=False):
        """
    Setter method for deltas, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/deltas (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deltas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deltas() directly.

    YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_deltas_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                                                  yang_name="deltas", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="deltas",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """deltas must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_deltas_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas, yang_name="deltas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__deltas = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_deltas(self):
        self.__deltas = YANGDynClass(
            base=YANGListType("id", yc_deltas_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                              yang_name="deltas", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_step_deltas(self):
        """
    Getter method for step_deltas, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/step_deltas (leafref)

    YANG Description: Identifiers of the individual scaling deltas to be
applied for the subsequent scaling steps of this
aspect. The first entry in the array shall correspond
to the first scaling step (between scale levels 0 to
1) and the last entry in the array shall correspond
to the last scaling step (between maxScaleLevel-1
and maxScaleLevel).

Each referenced scaling delta shall be declared in
the 'deltas' attribute.
    """
        return self.__step_deltas

    def _set_step_deltas(self, v, load=False):
        """
    Setter method for step_deltas, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details/step_deltas (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step_deltas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step_deltas() directly.

    YANG Description: Identifiers of the individual scaling deltas to be
applied for the subsequent scaling steps of this
aspect. The first entry in the array shall correspond
to the first scaling step (between scale levels 0 to
1) and the last entry in the array shall correspond
to the last scaling step (between maxScaleLevel-1
and maxScaleLevel).

Each referenced scaling delta shall be declared in
the 'deltas' attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """step_deltas must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__step_deltas = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_step_deltas(self):
        self.__step_deltas = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    deltas = __builtin__.property(_get_deltas, _set_deltas)
    step_deltas = __builtin__.property(_get_step_deltas, _set_step_deltas)

    _pyangbind_elements = OrderedDict([('deltas', deltas), ('step_deltas', step_deltas), ])


class yc_scaling_aspect_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df/scaling-aspect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__description', '__max_scale_level',
        '__aspect_delta_details',)

    _yang_name = 'scaling-aspect'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__max_scale_level = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        self.__aspect_delta_details = YANGDynClass(
            base=yc_aspect_delta_details_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details,
            is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df', 'scaling-aspect']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/id (string)

    YANG Description: Unique identifier of this aspect in the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this aspect in the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/name (string)

    YANG Description: Human readable name of the aspect.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/description (string)

    YANG Description: Human readable description of the aspect.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_max_scale_level(self):
        """
    Getter method for max_scale_level, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/max_scale_level (uint32)

    YANG Description: The maximum scaleLevel for total number of scaling
steps that can be applied w.r.t. this aspect. The
value of this attribute corresponds to the number of
scaling steps can be applied to this aspect when
scaling it from the minimum scale level (i.e. 0) to the
maximum scale level defined by this attribute.
    """
        return self.__max_scale_level

    def _set_max_scale_level(self, v, load=False):
        """
    Setter method for max_scale_level, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/max_scale_level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_scale_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_scale_level() directly.

    YANG Description: The maximum scaleLevel for total number of scaling
steps that can be applied w.r.t. this aspect. The
value of this attribute corresponds to the number of
scaling steps can be applied to this aspect when
scaling it from the minimum scale level (i.e. 0) to the
maximum scale level defined by this attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                              int_size=32), restriction_dict={'range': ['1..max']}), is_leaf=True,
                             yang_name="max-scale-level", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_scale_level must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__max_scale_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_scale_level(self):
        self.__max_scale_level = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    def _get_aspect_delta_details(self):
        """
    Getter method for aspect_delta_details, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details (container)

    YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
    """
        return self.__aspect_delta_details

    def _set_aspect_delta_details(self, v, load=False):
        """
    Setter method for aspect_delta_details, mapped from YANG variable /nsd/vnfd/df/scaling_aspect/aspect_delta_details (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aspect_delta_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aspect_delta_details() directly.

    YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_aspect_delta_details_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details,
                             is_container='container', yang_name="aspect-delta-details", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """aspect_delta_details must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_aspect_delta_details_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details, is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__aspect_delta_details = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_aspect_delta_details(self):
        self.__aspect_delta_details = YANGDynClass(
            base=yc_aspect_delta_details_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect_aspect_delta_details,
            is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    max_scale_level = __builtin__.property(_get_max_scale_level, _set_max_scale_level)
    aspect_delta_details = __builtin__.property(_get_aspect_delta_details, _set_aspect_delta_details)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('description', description), ('max_scale_level', max_scale_level),
         ('aspect_delta_details', aspect_delta_details), ])


class yc_df_etsi_nfv_nsd__nsd_vnfd_df(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/df. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu_profile', '__virtual_link_profile',
                 '__instantiation_level', '__default_instantiation_level', '__supported_operation',
                 '__lcm_operations_configuration', '__affinity_or_anti_affinity_group', '__indicator',
                 '__supported_vnf_interfaces', '__monitoring_parameter', '__scaling_aspect',)

    _yang_name = 'df'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vdu_profile = YANGDynClass(
            base=YANGListType("id", yc_vdu_profile_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile, yang_name="vdu-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id flavour", yc_virtual_link_profile_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id flavour', extensions=None),
            is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_instantiation_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level,
                              yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)
        self.__supported_operation = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'query-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                                  is_leaf=False, yang_name="supported-operation", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='identityref',
                                                  is_config=True)
        self.__lcm_operations_configuration = YANGDynClass(
            base=yc_lcm_operations_configuration_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration,
            is_container='container', yang_name="lcm-operations-configuration", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_df_indicator, yang_name="indicator",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__supported_vnf_interfaces = YANGDynClass(
            base=YANGListType("name", yc_supported_vnf_interfaces_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces,
                              yang_name="supported-vnf-interfaces", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_df_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect,
                              yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'df']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/df/id (string)

    YANG Description: Identifier of this DF within the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/df/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this DF within the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/df/description (string)

    YANG Description: Human readable description of the deployment flavour
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/df/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the deployment flavour
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vdu_profile(self):
        """
    Getter method for vdu_profile, mapped from YANG variable /nsd/vnfd/df/vdu_profile (list)

    YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
    """
        return self.__vdu_profile

    def _set_vdu_profile(self, v, load=False):
        """
    Setter method for vdu_profile, mapped from YANG variable /nsd/vnfd/df/vdu_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_profile() directly.

    YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vdu_profile_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile,
                                                  yang_name="vdu-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vdu-profile",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_profile_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile, yang_name="vdu-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_profile(self):
        self.__vdu_profile = YANGDynClass(
            base=YANGListType("id", yc_vdu_profile_etsi_nfv_nsd__nsd_vnfd_df_vdu_profile, yang_name="vdu-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_virtual_link_profile(self):
        """
    Getter method for virtual_link_profile, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile (list)

    YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
    """
        return self.__virtual_link_profile

    def _set_virtual_link_profile(self, v, load=False):
        """
    Setter method for virtual_link_profile, mapped from YANG variable /nsd/vnfd/df/virtual_link_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile() directly.

    YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id flavour",
                                                  yc_virtual_link_profile_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile,
                                                  yang_name="virtual-link-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='id flavour', extensions=None), is_container='list',
                             yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id flavour",yc_virtual_link_profile_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile, yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id flavour', extensions=None), is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile(self):
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id flavour", yc_virtual_link_profile_etsi_nfv_nsd__nsd_vnfd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id flavour', extensions=None),
            is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_instantiation_level(self):
        """
    Getter method for instantiation_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level (list)

    YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
    """
        return self.__instantiation_level

    def _set_instantiation_level(self, v, load=False):
        """
    Setter method for instantiation_level, mapped from YANG variable /nsd/vnfd/df/instantiation_level (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiation_level() directly.

    YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_instantiation_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level,
                                                  yang_name="instantiation-level", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="instantiation-level", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiation_level must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_instantiation_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level, yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiation_level(self):
        self.__instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_instantiation_level_etsi_nfv_nsd__nsd_vnfd_df_instantiation_level,
                              yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_default_instantiation_level(self):
        """
    Getter method for default_instantiation_level, mapped from YANG variable /nsd/vnfd/df/default_instantiation_level (leafref)

    YANG Description: This attribute references the 'instantiationLevel'
entry which defines the default instantiation level for
this DF. It shall be present if there are multiple
'instantiationLevel' entries.
    """
        return self.__default_instantiation_level

    def _set_default_instantiation_level(self, v, load=False):
        """
    Setter method for default_instantiation_level, mapped from YANG variable /nsd/vnfd/df/default_instantiation_level (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_instantiation_level() directly.

    YANG Description: This attribute references the 'instantiationLevel'
entry which defines the default instantiation level for
this DF. It shall be present if there are multiple
'instantiationLevel' entries.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_instantiation_level must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__default_instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_instantiation_level(self):
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)

    def _get_supported_operation(self):
        """
    Getter method for supported_operation, mapped from YANG variable /nsd/vnfd/df/supported_operation (identityref)

    YANG Description: Indicates which operations are available for this DF via
the VNF LCM interface. Instantiate VNF, Query VNF and
Terminate VNF are supported in all DF and therefore
need not be included in this list.
    """
        return self.__supported_operation

    def _set_supported_operation(self, v, load=False):
        """
    Setter method for supported_operation, mapped from YANG variable /nsd/vnfd/df/supported_operation (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_operation() directly.

    YANG Description: Indicates which operations are available for this DF via
the VNF LCM interface. Instantiate VNF, Query VNF and
Terminate VNF are supported in all DF and therefore
need not be included in this list.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             is_leaf=False, yang_name="supported-operation", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_operation must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), is_leaf=False, yang_name="supported-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__supported_operation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_operation(self):
        self.__supported_operation = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'query-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                                  is_leaf=False, yang_name="supported-operation", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='identityref',
                                                  is_config=True)

    def _get_lcm_operations_configuration(self):
        """
    Getter method for lcm_operations_configuration, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration (container)

    YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
    """
        return self.__lcm_operations_configuration

    def _set_lcm_operations_configuration(self, v, load=False):
        """
    Setter method for lcm_operations_configuration, mapped from YANG variable /nsd/vnfd/df/lcm_operations_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lcm_operations_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lcm_operations_configuration() directly.

    YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_lcm_operations_configuration_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration,
                             is_container='container', yang_name="lcm-operations-configuration", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lcm_operations_configuration must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_lcm_operations_configuration_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration, is_container='container', yang_name="lcm-operations-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__lcm_operations_configuration = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lcm_operations_configuration(self):
        self.__lcm_operations_configuration = YANGDynClass(
            base=yc_lcm_operations_configuration_etsi_nfv_nsd__nsd_vnfd_df_lcm_operations_configuration,
            is_container='container', yang_name="lcm-operations-configuration", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group (list)

    YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/vnfd/df/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_vnfd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    def _get_indicator(self):
        """
    Getter method for indicator, mapped from YANG variable /nsd/vnfd/df/indicator (list)

    YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
    """
        return self.__indicator

    def _set_indicator(self, v, load=False):
        """
    Setter method for indicator, mapped from YANG variable /nsd/vnfd/df/indicator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator() directly.

    YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_df_indicator,
                                                  yang_name="indicator", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="indicator",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_indicator_etsi_nfv_nsd__nsd_vnfd_df_indicator, yang_name="indicator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__indicator = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator(self):
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_df_indicator, yang_name="indicator",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_supported_vnf_interfaces(self):
        """
    Getter method for supported_vnf_interfaces, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces (list)

    YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
    """
        return self.__supported_vnf_interfaces

    def _set_supported_vnf_interfaces(self, v, load=False):
        """
    Setter method for supported_vnf_interfaces, mapped from YANG variable /nsd/vnfd/df/supported_vnf_interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_vnf_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_vnf_interfaces() directly.

    YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_supported_vnf_interfaces_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces,
                                                  yang_name="supported-vnf-interfaces", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="supported-vnf-interfaces", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_vnf_interfaces must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_supported_vnf_interfaces_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces, yang_name="supported-vnf-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__supported_vnf_interfaces = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_vnf_interfaces(self):
        self.__supported_vnf_interfaces = YANGDynClass(
            base=YANGListType("name", yc_supported_vnf_interfaces_etsi_nfv_nsd__nsd_vnfd_df_supported_vnf_interfaces,
                              yang_name="supported-vnf-interfaces", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_monitoring_parameter(self):
        """
    Getter method for monitoring_parameter, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter (list)

    YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
    """
        return self.__monitoring_parameter

    def _set_monitoring_parameter(self, v, load=False):
        """
    Setter method for monitoring_parameter, mapped from YANG variable /nsd/vnfd/df/monitoring_parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameter() directly.

    YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_df_monitoring_parameter,
                                                  yang_name="monitoring-parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_df_monitoring_parameter, yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameter(self):
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_nsd__nsd_vnfd_df_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_scaling_aspect(self):
        """
    Getter method for scaling_aspect, mapped from YANG variable /nsd/vnfd/df/scaling_aspect (list)

    YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
    """
        return self.__scaling_aspect

    def _set_scaling_aspect(self, v, load=False):
        """
    Setter method for scaling_aspect, mapped from YANG variable /nsd/vnfd/df/scaling_aspect (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_aspect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_aspect() directly.

    YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect,
                                                  yang_name="scaling-aspect", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="scaling-aspect",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_aspect must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_scaling_aspect_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect, yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__scaling_aspect = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_aspect(self):
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_vnfd_df_scaling_aspect,
                              yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu_profile = __builtin__.property(_get_vdu_profile, _set_vdu_profile)
    virtual_link_profile = __builtin__.property(_get_virtual_link_profile, _set_virtual_link_profile)
    instantiation_level = __builtin__.property(_get_instantiation_level, _set_instantiation_level)
    default_instantiation_level = __builtin__.property(_get_default_instantiation_level,
                                                       _set_default_instantiation_level)
    supported_operation = __builtin__.property(_get_supported_operation, _set_supported_operation)
    lcm_operations_configuration = __builtin__.property(_get_lcm_operations_configuration,
                                                        _set_lcm_operations_configuration)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    indicator = __builtin__.property(_get_indicator, _set_indicator)
    supported_vnf_interfaces = __builtin__.property(_get_supported_vnf_interfaces, _set_supported_vnf_interfaces)
    monitoring_parameter = __builtin__.property(_get_monitoring_parameter, _set_monitoring_parameter)
    scaling_aspect = __builtin__.property(_get_scaling_aspect, _set_scaling_aspect)

    _pyangbind_elements = OrderedDict([('id', id), ('description', description), ('vdu_profile', vdu_profile),
                                       ('virtual_link_profile', virtual_link_profile),
                                       ('instantiation_level', instantiation_level),
                                       ('default_instantiation_level', default_instantiation_level),
                                       ('supported_operation', supported_operation),
                                       ('lcm_operations_configuration', lcm_operations_configuration),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
                                       ('indicator', indicator), ('supported_vnf_interfaces', supported_vnf_interfaces),
                                       ('monitoring_parameter', monitoring_parameter),
                                       ('scaling_aspect', scaling_aspect), ])


class yc_additional_configurable_property_etsi_nfv_nsd__nsd_vnfd_configurable_properties_additional_configurable_property(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/configurable-properties/additional-configurable-property. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'additional-configurable-property'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'configurable-properties', 'additional-configurable-property']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_configurable_properties(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/configurable-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
  """
    __slots__ = ('_path_helper', '_extmethods', '__is_auto_scalable_enabled', '__is_auto_heal_enabled',
                 '__additional_configurable_property',)

    _yang_name = 'configurable-properties'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__is_auto_scalable_enabled = YANGDynClass(base=YANGBool, is_leaf=True,
                                                       yang_name="is-auto-scalable-enabled", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                       is_config=True)
        self.__is_auto_heal_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__additional_configurable_property = YANGDynClass(base=YANGListType("key",
                                                                                 yc_additional_configurable_property_etsi_nfv_nsd__nsd_vnfd_configurable_properties_additional_configurable_property,
                                                                                 yang_name="additional-configurable-property",
                                                                                 parent=self, is_container='list',
                                                                                 user_ordered=False,
                                                                                 path_helper=self._path_helper,
                                                                                 yang_keys='key', extensions=None),
                                                               is_container='list',
                                                               yang_name="additional-configurable-property",
                                                               parent=self, path_helper=self._path_helper,
                                                               extmethods=self._extmethods, register_paths=True,
                                                               extensions=None,
                                                               namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                               defining_module='etsi-nfv-nsd', yang_type='list',
                                                               is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'configurable-properties']

    def _get_is_auto_scalable_enabled(self):
        """
    Getter method for is_auto_scalable_enabled, mapped from YANG variable /nsd/vnfd/configurable_properties/is_auto_scalable_enabled (boolean)

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-scaling functionality.
    """
        return self.__is_auto_scalable_enabled

    def _set_is_auto_scalable_enabled(self, v, load=False):
        """
    Setter method for is_auto_scalable_enabled, mapped from YANG variable /nsd/vnfd/configurable_properties/is_auto_scalable_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_auto_scalable_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_auto_scalable_enabled() directly.

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-scaling functionality.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="is-auto-scalable-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """is_auto_scalable_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-scalable-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__is_auto_scalable_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_is_auto_scalable_enabled(self):
        self.__is_auto_scalable_enabled = YANGDynClass(base=YANGBool, is_leaf=True,
                                                       yang_name="is-auto-scalable-enabled", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                       is_config=True)

    def _get_is_auto_heal_enabled(self):
        """
    Getter method for is_auto_heal_enabled, mapped from YANG variable /nsd/vnfd/configurable_properties/is_auto_heal_enabled (boolean)

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-healing functionality.
    """
        return self.__is_auto_heal_enabled

    def _set_is_auto_heal_enabled(self, v, load=False):
        """
    Setter method for is_auto_heal_enabled, mapped from YANG variable /nsd/vnfd/configurable_properties/is_auto_heal_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_auto_heal_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_auto_heal_enabled() directly.

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-healing functionality.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """is_auto_heal_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__is_auto_heal_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_is_auto_heal_enabled(self):
        self.__is_auto_heal_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_additional_configurable_property(self):
        """
    Getter method for additional_configurable_property, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property (list)

    YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
    """
        return self.__additional_configurable_property

    def _set_additional_configurable_property(self, v, load=False):
        """
    Setter method for additional_configurable_property, mapped from YANG variable /nsd/vnfd/configurable_properties/additional_configurable_property (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_configurable_property is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_configurable_property() directly.

    YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_additional_configurable_property_etsi_nfv_nsd__nsd_vnfd_configurable_properties_additional_configurable_property,
                                                  yang_name="additional-configurable-property", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="additional-configurable-property", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """additional_configurable_property must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_additional_configurable_property_etsi_nfv_nsd__nsd_vnfd_configurable_properties_additional_configurable_property, yang_name="additional-configurable-property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="additional-configurable-property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__additional_configurable_property = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_additional_configurable_property(self):
        self.__additional_configurable_property = YANGDynClass(base=YANGListType("key",
                                                                                 yc_additional_configurable_property_etsi_nfv_nsd__nsd_vnfd_configurable_properties_additional_configurable_property,
                                                                                 yang_name="additional-configurable-property",
                                                                                 parent=self, is_container='list',
                                                                                 user_ordered=False,
                                                                                 path_helper=self._path_helper,
                                                                                 yang_keys='key', extensions=None),
                                                               is_container='list',
                                                               yang_name="additional-configurable-property",
                                                               parent=self, path_helper=self._path_helper,
                                                               extmethods=self._extmethods, register_paths=True,
                                                               extensions=None,
                                                               namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                               defining_module='etsi-nfv-nsd', yang_type='list',
                                                               is_config=True)

    is_auto_scalable_enabled = __builtin__.property(_get_is_auto_scalable_enabled, _set_is_auto_scalable_enabled)
    is_auto_heal_enabled = __builtin__.property(_get_is_auto_heal_enabled, _set_is_auto_heal_enabled)
    additional_configurable_property = __builtin__.property(_get_additional_configurable_property,
                                                            _set_additional_configurable_property)

    _pyangbind_elements = OrderedDict(
        [('is_auto_scalable_enabled', is_auto_scalable_enabled), ('is_auto_heal_enabled', is_auto_heal_enabled),
         ('additional_configurable_property', additional_configurable_property), ])


class yc_modifiable_attributes_etsi_nfv_nsd__nsd_vnfd_modifiable_attributes(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/modifiable-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the modifiable attributes of the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__extension', '__metadata',)

    _yang_name = 'modifiable-attributes'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__extension = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="extension", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__metadata = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                       yang_name="metadata", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'modifiable-attributes']

    def _get_extension(self):
        """
    Getter method for extension, mapped from YANG variable /nsd/vnfd/modifiable_attributes/extension (string)

    YANG Description: Additional VNF-specific attributes of VnfInfo that
affect the lifecycle management of a VNF instance and
that are writeable.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and
modified through the VNFM.

These attributes are intended to be consumed by the
VNFM or by the lifecycle management scripts during the
execution of VNF lifecycle management operations.

Modifying these values has no direct effect on the VNF
instance; however, modified values can be considered
during subsequent VNF lifecycle management operations,
which means that the modified values can indirectly
affect the configuration of the VNF instance.
    """
        return self.__extension

    def _set_extension(self, v, load=False):
        """
    Setter method for extension, mapped from YANG variable /nsd/vnfd/modifiable_attributes/extension (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extension() directly.

    YANG Description: Additional VNF-specific attributes of VnfInfo that
affect the lifecycle management of a VNF instance and
that are writeable.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and
modified through the VNFM.

These attributes are intended to be consumed by the
VNFM or by the lifecycle management scripts during the
execution of VNF lifecycle management operations.

Modifying these values has no direct effect on the VNF
instance; however, modified values can be considered
during subsequent VNF lifecycle management operations,
which means that the modified values can indirectly
affect the configuration of the VNF instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="extension", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """extension must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="extension", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__extension = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_extension(self):
        self.__extension = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="extension", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_metadata(self):
        """
    Getter method for metadata, mapped from YANG variable /nsd/vnfd/modifiable_attributes/metadata (string)

    YANG Description: Additional VNF-specific attributes of VnfInfo that are
writeable and that provide metadata describing the VNF
instance.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and modified
through the VNFM.

These attributes are intended to provide information to
functional blocks external to the VNFM and will not be
used by the VNFM or the VNF lifecycle management
scripts when executing lifecycle management operations.

Modifying these attributes has no effect on the VNF
instance. It only affects the attribute values stored by
the VNFM.
    """
        return self.__metadata

    def _set_metadata(self, v, load=False):
        """
    Setter method for metadata, mapped from YANG variable /nsd/vnfd/modifiable_attributes/metadata (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metadata is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metadata() directly.

    YANG Description: Additional VNF-specific attributes of VnfInfo that are
writeable and that provide metadata describing the VNF
instance.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and modified
through the VNFM.

These attributes are intended to provide information to
functional blocks external to the VNFM and will not be
used by the VNFM or the VNF lifecycle management
scripts when executing lifecycle management operations.

Modifying these attributes has no effect on the VNF
instance. It only affects the attribute values stored by
the VNFM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="metadata", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metadata must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="metadata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__metadata = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metadata(self):
        self.__metadata = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                       yang_name="metadata", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)

    extension = __builtin__.property(_get_extension, _set_extension)
    metadata = __builtin__.property(_get_metadata, _set_metadata)

    _pyangbind_elements = OrderedDict([('extension', extension), ('metadata', metadata), ])


class yc_script_input_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script_script_input(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/lifecycle-management-script/script-input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'script-input'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'lifecycle-management-script', 'script-input']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input/key (string)

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.

The string value specified here is a path to a file in
the VNF package.
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.

The string value specified here is a path to a file in
the VNF package.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_lifecycle_management_script_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/lifecycle-management-script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__event', '__lcm_transition_event', '__script', '__script_dsl',
                 '__script_input',)

    _yang_name = 'lifecycle-management-script'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__event = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                              'start-scaling': {}, 'end-scaling': {},
                                                              'start-healing': {}, 'end-healing': {},
                                                              'start-termination': {}, 'end-termination': {},
                                                              'start-vnf-flavour-change': {},
                                                              'end-vnf-flavour-change': {},
                                                              'start-vnf-operation-change': {},
                                                              'end-vnf-operation-change': {},
                                                              'start-vnf-ext-conn-change': {},
                                                              'end-vnf-ext-conn-change': {},
                                                              'start-vnfinfo-modification': {},
                                                              'end-vnfinfo-modification': {}}, )), is_leaf=False,
                                    yang_name="event", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='internal-lifecycle-management-script-event', is_config=True)
        self.__lcm_transition_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="lcm-transition-event", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)
        self.__script_dsl = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__script_input = YANGDynClass(
            base=YANGListType("key", yc_script_input_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script_script_input,
                              yang_name="script-input", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'lifecycle-management-script']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/id (string)

    YANG Description: A unique string that identfies the script in question.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A unique string that identfies the script in question.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_event(self):
        """
    Getter method for event, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/event (internal-lifecycle-management-script-event)

    YANG Description: Describes VNF lifecycle event(s) or an external stimulus
detected on a VNFM reference point.
    """
        return self.__event

    def _set_event(self, v, load=False):
        """
    Setter method for event, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/event (internal-lifecycle-management-script-event)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: Describes VNF lifecycle event(s) or an external stimulus
detected on a VNFM reference point.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                 restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                                  'start-scaling': {}, 'end-scaling': {},
                                                                  'start-healing': {}, 'end-healing': {},
                                                                  'start-termination': {}, 'end-termination': {},
                                                                  'start-vnf-flavour-change': {},
                                                                  'end-vnf-flavour-change': {},
                                                                  'start-vnf-operation-change': {},
                                                                  'end-vnf-operation-change': {},
                                                                  'start-vnf-ext-conn-change': {},
                                                                  'end-vnf-ext-conn-change': {},
                                                                  'start-vnfinfo-modification': {},
                                                                  'end-vnfinfo-modification': {}}, )), is_leaf=False,
                             yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='internal-lifecycle-management-script-event',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """event must be of a type compatible with internal-lifecycle-management-script-event""",
                'defined-type': "etsi-nfv-nsd:internal-lifecycle-management-script-event",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'start-instantiation': {}, 'end-instantiation': {}, 'start-scaling': {}, 'end-scaling': {}, 'start-healing': {}, 'end-healing': {}, 'start-termination': {}, 'end-termination': {}, 'start-vnf-flavour-change': {}, 'end-vnf-flavour-change': {}, 'start-vnf-operation-change': {}, 'end-vnf-operation-change': {}, 'start-vnf-ext-conn-change': {}, 'end-vnf-ext-conn-change': {}, 'start-vnfinfo-modification': {}, 'end-vnfinfo-modification': {}},)), is_leaf=False, yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='internal-lifecycle-management-script-event', is_config=True)""",
            })

        self.__event = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_event(self):
        self.__event = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                              'start-scaling': {}, 'end-scaling': {},
                                                              'start-healing': {}, 'end-healing': {},
                                                              'start-termination': {}, 'end-termination': {},
                                                              'start-vnf-flavour-change': {},
                                                              'end-vnf-flavour-change': {},
                                                              'start-vnf-operation-change': {},
                                                              'end-vnf-operation-change': {},
                                                              'start-vnf-ext-conn-change': {},
                                                              'end-vnf-ext-conn-change': {},
                                                              'start-vnfinfo-modification': {},
                                                              'end-vnfinfo-modification': {}}, )), is_leaf=False,
                                    yang_name="event", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='internal-lifecycle-management-script-event', is_config=True)

    def _get_lcm_transition_event(self):
        """
    Getter method for lcm_transition_event, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/lcm_transition_event (string)

    YANG Description: Describes the transition VNF lifecycle event(s) that
cannot be mapped to any of the enumerated values
defined for the event attribute.
    """
        return self.__lcm_transition_event

    def _set_lcm_transition_event(self, v, load=False):
        """
    Setter method for lcm_transition_event, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/lcm_transition_event (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lcm_transition_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lcm_transition_event() directly.

    YANG Description: Describes the transition VNF lifecycle event(s) that
cannot be mapped to any of the enumerated values
defined for the event attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="lcm-transition-event", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lcm_transition_event must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lcm-transition-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__lcm_transition_event = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lcm_transition_event(self):
        self.__lcm_transition_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="lcm-transition-event", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script (string)

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.
    """
        return self.__script

    def _set_script(self, v, load=False):
        """
    Setter method for script, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)

    def _get_script_dsl(self):
        """
    Getter method for script_dsl, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_dsl (string)

    YANG Description: Defines the domain specific language (i.e. the type) of
script that is provided. Types of scripts could include
bash, python, etc.
    """
        return self.__script_dsl

    def _set_script_dsl(self, v, load=False):
        """
    Setter method for script_dsl, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_dsl (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_dsl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_dsl() directly.

    YANG Description: Defines the domain specific language (i.e. the type) of
script that is provided. Types of scripts could include
bash, python, etc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_dsl must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__script_dsl = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_dsl(self):
        self.__script_dsl = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_script_input(self):
        """
    Getter method for script_input, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input (list)

    YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
    """
        return self.__script_input

    def _set_script_input(self, v, load=False):
        """
    Setter method for script_input, mapped from YANG variable /nsd/vnfd/lifecycle_management_script/script_input (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_input() directly.

    YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_script_input_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script_script_input,
                                                  yang_name="script-input", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="script-input",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_input must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_script_input_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script_script_input, yang_name="script-input", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__script_input = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_input(self):
        self.__script_input = YANGDynClass(
            base=YANGListType("key", yc_script_input_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script_script_input,
                              yang_name="script-input", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    event = __builtin__.property(_get_event, _set_event)
    lcm_transition_event = __builtin__.property(_get_lcm_transition_event, _set_lcm_transition_event)
    script = __builtin__.property(_get_script, _set_script)
    script_dsl = __builtin__.property(_get_script_dsl, _set_script_dsl)
    script_input = __builtin__.property(_get_script_input, _set_script_input)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('event', event), ('lcm_transition_event', lcm_transition_event), ('script', script),
         ('script_dsl', script_dsl), ('script_input', script_input), ])


class yc_element_group_etsi_nfv_nsd__nsd_vnfd_element_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/element-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu', '__virtual_link_desc',)

    _yang_name = 'element-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vdu = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                  yang_name="vdu", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='leafref', is_config=True)
        self.__virtual_link_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                is_leaf=False, yang_name="virtual-link-desc", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'element-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/element_group/id (string)

    YANG Description: Unique identifier of this group in the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/element_group/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this group in the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/vnfd/element_group/description (string)

    YANG Description: Human readable description of the group.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/vnfd/element_group/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /nsd/vnfd/element_group/vdu (leafref)

    YANG Description: References to Vdus that are part of this group.
    """
        return self.__vdu

    def _set_vdu(self, v, load=False):
        """
    Setter method for vdu, mapped from YANG variable /nsd/vnfd/element_group/vdu (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: References to Vdus that are part of this group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                  yang_name="vdu", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='leafref', is_config=True)

    def _get_virtual_link_desc(self):
        """
    Getter method for virtual_link_desc, mapped from YANG variable /nsd/vnfd/element_group/virtual_link_desc (leafref)

    YANG Description: References to VnfVirtualLinkDesc that are part of this
group.
    """
        return self.__virtual_link_desc

    def _set_virtual_link_desc(self, v, load=False):
        """
    Setter method for virtual_link_desc, mapped from YANG variable /nsd/vnfd/element_group/virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_desc() directly.

    YANG Description: References to VnfVirtualLinkDesc that are part of this
group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_desc(self):
        self.__virtual_link_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                is_leaf=False, yang_name="virtual-link-desc", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu = __builtin__.property(_get_vdu, _set_vdu)
    virtual_link_desc = __builtin__.property(_get_virtual_link_desc, _set_virtual_link_desc)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('vdu', vdu), ('virtual_link_desc', virtual_link_desc), ])


class yc_indicator_etsi_nfv_nsd__nsd_vnfd_indicator(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd/indicator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares the VNF indicators that are supported by this
VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__indicator_value', '__source',)

    _yang_name = 'indicator'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__indicator_value = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="indicator-value", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd', 'indicator']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/indicator/id (string)

    YANG Description: Unique identifier
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/indicator/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/vnfd/indicator/name (string)

    YANG Description: The human readable name of the VnfIndicator.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/vnfd/indicator/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The human readable name of the VnfIndicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_indicator_value(self):
        """
    Getter method for indicator_value, mapped from YANG variable /nsd/vnfd/indicator/indicator_value (string)

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        return self.__indicator_value

    def _set_indicator_value(self, v, load=False):
        """
    Setter method for indicator_value, mapped from YANG variable /nsd/vnfd/indicator/indicator_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator_value() directly.

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="indicator-value", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="indicator-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__indicator_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator_value(self):
        self.__indicator_value = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="indicator-value", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                              defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_source(self):
        """
    Getter method for source, mapped from YANG variable /nsd/vnfd/indicator/source (enumeration)

    YANG Description: Describe the source of the indicator. The possible values
are:
 VNF.
 EM.
 Both.
This tells the consumer where to send the subscription
request.
    """
        return self.__source

    def _set_source(self, v, load=False):
        """
    Setter method for source, mapped from YANG variable /nsd/vnfd/indicator/source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Describe the source of the indicator. The possible values
are:
 VNF.
 EM.
 Both.
This tells the consumer where to send the subscription
request.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                             is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """source must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf': {}, 'em': {}, 'both': {}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__source = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_source(self):
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    indicator_value = __builtin__.property(_get_indicator_value, _set_indicator_value)
    source = __builtin__.property(_get_source, _set_source)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('indicator_value', indicator_value), ('source', source), ])


class yc_vnfd_etsi_nfv_nsd__nsd_vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A VNF Descriptor (VNFD) is a deployment template which
describes a VNF in terms of deployment and operational
behaviour requirements. It also contains connectivity,
interface and virtualised resource requirements
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__provider', '__product_name', '__software_version', '__version',
        '__product_info_name', '__product_info_description', '__vnfm_info', '__localization_language',
        '__default_localization_language', '__vdu', '__virtual_compute_desc', '__virtual_storage_desc',
        '__sw_image_desc',
        '__int_virtual_link_desc', '__security_group_rule', '__ext_cpd', '__df', '__configurable_properties',
        '__modifiable_attributes', '__lifecycle_management_script', '__element_group', '__indicator', '__auto_scale',)

    _yang_name = 'vnfd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)
        self.__product_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)
        self.__product_info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__product_info_description = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="product-info-description", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='string',
                                                       is_config=True)
        self.__vnfm_info = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__localization_language = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__default_localization_language = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="default-localization-language", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='string',
                                                            is_config=True)
        self.__vdu = YANGDynClass(
            base=YANGListType("id", yc_vdu_etsi_nfv_nsd__nsd_vnfd_vdu, yang_name="vdu", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="vdu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__virtual_compute_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_compute_desc_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc,
                              yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__virtual_storage_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_storage_desc_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc,
                              yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__sw_image_desc = YANGDynClass(
            base=YANGListType("id", yc_sw_image_desc_etsi_nfv_nsd__nsd_vnfd_sw_image_desc, yang_name="sw-image-desc",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__int_virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_int_virtual_link_desc_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc,
                              yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_vnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_vnfd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__configurable_properties = YANGDynClass(
            base=yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_configurable_properties, is_container='container',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__modifiable_attributes = YANGDynClass(
            base=yc_modifiable_attributes_etsi_nfv_nsd__nsd_vnfd_modifiable_attributes, is_container='container',
            yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("id", yc_lifecycle_management_script_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__element_group = YANGDynClass(
            base=YANGListType("id", yc_element_group_etsi_nfv_nsd__nsd_vnfd_element_group, yang_name="element-group",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="element-group",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__auto_scale = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                         yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'vnfd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/vnfd/id (string)

    YANG Description: Identifier of this VNFD information element. This attribute
shall be globally unique. The format will be defined in the
data model specification phase.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/vnfd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this VNFD information element. This attribute
shall be globally unique. The format will be defined in the
data model specification phase.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_provider(self):
        """
    Getter method for provider, mapped from YANG variable /nsd/vnfd/provider (string)

    YANG Description: Provider of the VNF and of the VNFD
    """
        return self.__provider

    def _set_provider(self, v, load=False):
        """
    Setter method for provider, mapped from YANG variable /nsd/vnfd/provider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider() directly.

    YANG Description: Provider of the VNF and of the VNFD
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """provider must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__provider = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_provider(self):
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)

    def _get_product_name(self):
        """
    Getter method for product_name, mapped from YANG variable /nsd/vnfd/product_name (string)

    YANG Description: Name to identify the VNF Product. Invariant for the VNF
Product lifetime.
    """
        return self.__product_name

    def _set_product_name(self, v, load=False):
        """
    Setter method for product_name, mapped from YANG variable /nsd/vnfd/product_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_name() directly.

    YANG Description: Name to identify the VNF Product. Invariant for the VNF
Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__product_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_name(self):
        self.__product_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_software_version(self):
        """
    Getter method for software_version, mapped from YANG variable /nsd/vnfd/software_version (string)

    YANG Description: Software version of the VNF. This is changed when there is
any change to the software that is included in the VNF
Package
    """
        return self.__software_version

    def _set_software_version(self, v, load=False):
        """
    Setter method for software_version, mapped from YANG variable /nsd/vnfd/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: Software version of the VNF. This is changed when there is
any change to the software that is included in the VNF
Package
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="software-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """software_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__software_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_software_version(self):
        self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                               defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd/vnfd/version (string)

    YANG Description: Identifies the version of the VNFD
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /nsd/vnfd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the VNFD
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)

    def _get_product_info_name(self):
        """
    Getter method for product_info_name, mapped from YANG variable /nsd/vnfd/product_info_name (string)

    YANG Description: Human readable name of the VNFD. Can change
during the VNF Product lifetime.
    """
        return self.__product_info_name

    def _set_product_info_name(self, v, load=False):
        """
    Setter method for product_info_name, mapped from YANG variable /nsd/vnfd/product_info_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_info_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_info_name() directly.

    YANG Description: Human readable name of the VNFD. Can change
during the VNF Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-info-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_info_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__product_info_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_info_name(self):
        self.__product_info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_product_info_description(self):
        """
    Getter method for product_info_description, mapped from YANG variable /nsd/vnfd/product_info_description (string)

    YANG Description: Human readable description of the VNFD. Can change during
the VNF Product lifetime.
    """
        return self.__product_info_description

    def _set_product_info_description(self, v, load=False):
        """
    Setter method for product_info_description, mapped from YANG variable /nsd/vnfd/product_info_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_info_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_info_description() directly.

    YANG Description: Human readable description of the VNFD. Can change during
the VNF Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-info-description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_info_description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__product_info_description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_info_description(self):
        self.__product_info_description = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="product-info-description", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                       defining_module='etsi-nfv-nsd', yang_type='string',
                                                       is_config=True)

    def _get_vnfm_info(self):
        """
    Getter method for vnfm_info, mapped from YANG variable /nsd/vnfd/vnfm_info (string)

    YANG Description: Identifies VNFM(s) compatible with the VNF described in
this version of the VNFD.
    """
        return self.__vnfm_info

    def _set_vnfm_info(self, v, load=False):
        """
    Setter method for vnfm_info, mapped from YANG variable /nsd/vnfd/vnfm_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfm_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfm_info() directly.

    YANG Description: Identifies VNFM(s) compatible with the VNF described in
this version of the VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfm_info must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vnfm-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__vnfm_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfm_info(self):
        self.__vnfm_info = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_localization_language(self):
        """
    Getter method for localization_language, mapped from YANG variable /nsd/vnfd/localization_language (string)

    YANG Description: Information about the language of the VNF.
    """
        return self.__localization_language

    def _set_localization_language(self, v, load=False):
        """
    Setter method for localization_language, mapped from YANG variable /nsd/vnfd/localization_language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localization_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localization_language() directly.

    YANG Description: Information about the language of the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="localization-language", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """localization_language must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__localization_language = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_localization_language(self):
        self.__localization_language = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_default_localization_language(self):
        """
    Getter method for default_localization_language, mapped from YANG variable /nsd/vnfd/default_localization_language (string)

    YANG Description: Default localization language that is instantiated if no
information about selected localization language is
available. Shall be present if 'localization-language'
is present and shall be absent otherwise.
    """
        return self.__default_localization_language

    def _set_default_localization_language(self, v, load=False):
        """
    Setter method for default_localization_language, mapped from YANG variable /nsd/vnfd/default_localization_language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_localization_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_localization_language() directly.

    YANG Description: Default localization language that is instantiated if no
information about selected localization language is
available. Shall be present if 'localization-language'
is present and shall be absent otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-localization-language",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_localization_language must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-localization-language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__default_localization_language = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_localization_language(self):
        self.__default_localization_language = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="default-localization-language", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='string',
                                                            is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /nsd/vnfd/vdu (list)

    YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
    """
        return self.__vdu

    def _set_vdu(self, v, load=False):
        """
    Setter method for vdu, mapped from YANG variable /nsd/vnfd/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vdu_etsi_nfv_nsd__nsd_vnfd_vdu, yang_name="vdu", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_etsi_nfv_nsd__nsd_vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vdu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(
            base=YANGListType("id", yc_vdu_etsi_nfv_nsd__nsd_vnfd_vdu, yang_name="vdu", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="vdu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_virtual_compute_desc(self):
        """
    Getter method for virtual_compute_desc, mapped from YANG variable /nsd/vnfd/virtual_compute_desc (list)

    YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
    """
        return self.__virtual_compute_desc

    def _set_virtual_compute_desc(self, v, load=False):
        """
    Setter method for virtual_compute_desc, mapped from YANG variable /nsd/vnfd/virtual_compute_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_compute_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_compute_desc() directly.

    YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_virtual_compute_desc_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc,
                                                  yang_name="virtual-compute-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_compute_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_compute_desc_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc, yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_compute_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_compute_desc(self):
        self.__virtual_compute_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_compute_desc_etsi_nfv_nsd__nsd_vnfd_virtual_compute_desc,
                              yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_virtual_storage_desc(self):
        """
    Getter method for virtual_storage_desc, mapped from YANG variable /nsd/vnfd/virtual_storage_desc (list)

    YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
    """
        return self.__virtual_storage_desc

    def _set_virtual_storage_desc(self, v, load=False):
        """
    Setter method for virtual_storage_desc, mapped from YANG variable /nsd/vnfd/virtual_storage_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage_desc() directly.

    YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_virtual_storage_desc_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc,
                                                  yang_name="virtual-storage-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_storage_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_storage_desc_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc, yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_storage_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_storage_desc(self):
        self.__virtual_storage_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_storage_desc_etsi_nfv_nsd__nsd_vnfd_virtual_storage_desc,
                              yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/sw_image_desc (list)

    YANG Description: Defines descriptors of software images to be used by the
VNF.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /nsd/vnfd/sw_image_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Defines descriptors of software images to be used by the
VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_sw_image_desc_etsi_nfv_nsd__nsd_vnfd_sw_image_desc,
                                                  yang_name="sw-image-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="sw-image-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_sw_image_desc_etsi_nfv_nsd__nsd_vnfd_sw_image_desc, yang_name="sw-image-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(
            base=YANGListType("id", yc_sw_image_desc_etsi_nfv_nsd__nsd_vnfd_sw_image_desc, yang_name="sw-image-desc",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc (list)

    YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /nsd/vnfd/int_virtual_link_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_int_virtual_link_desc_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc,
                                                  yang_name="int-virtual-link-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_int_virtual_link_desc_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc, yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_int_virtual_link_desc_etsi_nfv_nsd__nsd_vnfd_int_virtual_link_desc,
                              yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_security_group_rule(self):
        """
    Getter method for security_group_rule, mapped from YANG variable /nsd/vnfd/security_group_rule (list)

    YANG Description: Defines security group rules to be used by the VNF.
    """
        return self.__security_group_rule

    def _set_security_group_rule(self, v, load=False):
        """
    Setter method for security_group_rule, mapped from YANG variable /nsd/vnfd/security_group_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule() directly.

    YANG Description: Defines security group rules to be used by the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_vnfd_security_group_rule,
                                               yang_name="security-group-rule", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="security-group-rule",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_security_group_rule_etsi_nfv_nsd__nsd_vnfd_security_group_rule, yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__security_group_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule(self):
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_vnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_ext_cpd(self):
        """
    Getter method for ext_cpd, mapped from YANG variable /nsd/vnfd/ext_cpd (list)

    YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
    """
        return self.__ext_cpd

    def _set_ext_cpd(self, v, load=False):
        """
    Setter method for ext_cpd, mapped from YANG variable /nsd/vnfd/ext_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd() directly.

    YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd, yang_name="ext-cpd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_ext_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__ext_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd(self):
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_vnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_df(self):
        """
    Getter method for df, mapped from YANG variable /nsd/vnfd/df (list)

    YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
    """
        return self.__df

    def _set_df(self, v, load=False):
        """
    Setter method for df, mapped from YANG variable /nsd/vnfd/df (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df() directly.

    YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_vnfd_df, yang_name="df", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """df must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_df_etsi_nfv_nsd__nsd_vnfd_df, yang_name="df", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__df = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_df(self):
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_vnfd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_configurable_properties(self):
        """
    Getter method for configurable_properties, mapped from YANG variable /nsd/vnfd/configurable_properties (container)

    YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
    """
        return self.__configurable_properties

    def _set_configurable_properties(self, v, load=False):
        """
    Setter method for configurable_properties, mapped from YANG variable /nsd/vnfd/configurable_properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable_properties() directly.

    YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_configurable_properties,
                             is_container='container', yang_name="configurable-properties", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """configurable_properties must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_configurable_properties, is_container='container', yang_name="configurable-properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__configurable_properties = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_configurable_properties(self):
        self.__configurable_properties = YANGDynClass(
            base=yc_configurable_properties_etsi_nfv_nsd__nsd_vnfd_configurable_properties, is_container='container',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_modifiable_attributes(self):
        """
    Getter method for modifiable_attributes, mapped from YANG variable /nsd/vnfd/modifiable_attributes (container)

    YANG Description: Describes the modifiable attributes of the VNF.
    """
        return self.__modifiable_attributes

    def _set_modifiable_attributes(self, v, load=False):
        """
    Setter method for modifiable_attributes, mapped from YANG variable /nsd/vnfd/modifiable_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modifiable_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modifiable_attributes() directly.

    YANG Description: Describes the modifiable attributes of the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_modifiable_attributes_etsi_nfv_nsd__nsd_vnfd_modifiable_attributes,
                             is_container='container', yang_name="modifiable-attributes", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """modifiable_attributes must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_modifiable_attributes_etsi_nfv_nsd__nsd_vnfd_modifiable_attributes, is_container='container', yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__modifiable_attributes = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_modifiable_attributes(self):
        self.__modifiable_attributes = YANGDynClass(
            base=yc_modifiable_attributes_etsi_nfv_nsd__nsd_vnfd_modifiable_attributes, is_container='container',
            yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_lifecycle_management_script(self):
        """
    Getter method for lifecycle_management_script, mapped from YANG variable /nsd/vnfd/lifecycle_management_script (list)

    YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
    """
        return self.__lifecycle_management_script

    def _set_lifecycle_management_script(self, v, load=False):
        """
    Setter method for lifecycle_management_script, mapped from YANG variable /nsd/vnfd/lifecycle_management_script (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifecycle_management_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifecycle_management_script() directly.

    YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_lifecycle_management_script_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script,
                                                  yang_name="lifecycle-management-script", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="lifecycle-management-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lifecycle_management_script must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_lifecycle_management_script_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script, yang_name="lifecycle-management-script", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__lifecycle_management_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lifecycle_management_script(self):
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("id", yc_lifecycle_management_script_etsi_nfv_nsd__nsd_vnfd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_element_group(self):
        """
    Getter method for element_group, mapped from YANG variable /nsd/vnfd/element_group (list)

    YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
    """
        return self.__element_group

    def _set_element_group(self, v, load=False):
        """
    Setter method for element_group, mapped from YANG variable /nsd/vnfd/element_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_element_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_element_group() directly.

    YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_element_group_etsi_nfv_nsd__nsd_vnfd_element_group,
                                                  yang_name="element-group", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="element-group",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """element_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_element_group_etsi_nfv_nsd__nsd_vnfd_element_group, yang_name="element-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="element-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__element_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_element_group(self):
        self.__element_group = YANGDynClass(
            base=YANGListType("id", yc_element_group_etsi_nfv_nsd__nsd_vnfd_element_group, yang_name="element-group",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="element-group",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_indicator(self):
        """
    Getter method for indicator, mapped from YANG variable /nsd/vnfd/indicator (list)

    YANG Description: Declares the VNF indicators that are supported by this
VNF.
    """
        return self.__indicator

    def _set_indicator(self, v, load=False):
        """
    Setter method for indicator, mapped from YANG variable /nsd/vnfd/indicator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator() directly.

    YANG Description: Declares the VNF indicators that are supported by this
VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_indicator,
                                                  yang_name="indicator", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="indicator",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_indicator_etsi_nfv_nsd__nsd_vnfd_indicator, yang_name="indicator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__indicator = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator(self):
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_nsd__nsd_vnfd_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_auto_scale(self):
        """
    Getter method for auto_scale, mapped from YANG variable /nsd/vnfd/auto_scale (string)

    YANG Description: Rule that determines when a scaling action needs to be
triggered on a VNF instance e.g. based on certain VNF
indicator values or VNF indicator value changes or a
combination of VNF indicator value(s) and monitoring
parameter(s).
    """
        return self.__auto_scale

    def _set_auto_scale(self, v, load=False):
        """
    Setter method for auto_scale, mapped from YANG variable /nsd/vnfd/auto_scale (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_scale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_scale() directly.

    YANG Description: Rule that determines when a scaling action needs to be
triggered on a VNF instance e.g. based on certain VNF
indicator values or VNF indicator value changes or a
combination of VNF indicator value(s) and monitoring
parameter(s).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """auto_scale must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="auto-scale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__auto_scale = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_auto_scale(self):
        self.__auto_scale = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                         yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    provider = __builtin__.property(_get_provider, _set_provider)
    product_name = __builtin__.property(_get_product_name, _set_product_name)
    software_version = __builtin__.property(_get_software_version, _set_software_version)
    version = __builtin__.property(_get_version, _set_version)
    product_info_name = __builtin__.property(_get_product_info_name, _set_product_info_name)
    product_info_description = __builtin__.property(_get_product_info_description, _set_product_info_description)
    vnfm_info = __builtin__.property(_get_vnfm_info, _set_vnfm_info)
    localization_language = __builtin__.property(_get_localization_language, _set_localization_language)
    default_localization_language = __builtin__.property(_get_default_localization_language,
                                                         _set_default_localization_language)
    vdu = __builtin__.property(_get_vdu, _set_vdu)
    virtual_compute_desc = __builtin__.property(_get_virtual_compute_desc, _set_virtual_compute_desc)
    virtual_storage_desc = __builtin__.property(_get_virtual_storage_desc, _set_virtual_storage_desc)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)
    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    security_group_rule = __builtin__.property(_get_security_group_rule, _set_security_group_rule)
    ext_cpd = __builtin__.property(_get_ext_cpd, _set_ext_cpd)
    df = __builtin__.property(_get_df, _set_df)
    configurable_properties = __builtin__.property(_get_configurable_properties, _set_configurable_properties)
    modifiable_attributes = __builtin__.property(_get_modifiable_attributes, _set_modifiable_attributes)
    lifecycle_management_script = __builtin__.property(_get_lifecycle_management_script,
                                                       _set_lifecycle_management_script)
    element_group = __builtin__.property(_get_element_group, _set_element_group)
    indicator = __builtin__.property(_get_indicator, _set_indicator)
    auto_scale = __builtin__.property(_get_auto_scale, _set_auto_scale)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('provider', provider), ('product_name', product_name), ('software_version', software_version),
         ('version', version), ('product_info_name', product_info_name),
         ('product_info_description', product_info_description), ('vnfm_info', vnfm_info),
         ('localization_language', localization_language),
         ('default_localization_language', default_localization_language), ('vdu', vdu),
         ('virtual_compute_desc', virtual_compute_desc), ('virtual_storage_desc', virtual_storage_desc),
         ('sw_image_desc', sw_image_desc), ('int_virtual_link_desc', int_virtual_link_desc),
         ('security_group_rule', security_group_rule), ('ext_cpd', ext_cpd), ('df', df),
         ('configurable_properties', configurable_properties), ('modifiable_attributes', modifiable_attributes),
         ('lifecycle_management_script', lifecycle_management_script), ('element_group', element_group),
         ('indicator', indicator), ('auto_scale', auto_scale), ])


class yc_vnf_etsi_nfv_nsd__nsd_nsd_sapd_vnf(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/sapd/vnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnfd_id', '__ext_cpd_id',)

    _yang_name = 'vnf'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'sapd', 'vnf']

    def _get_vnfd_id(self):
        """
    Getter method for vnfd_id, mapped from YANG variable /nsd/nsd/sapd/vnf/vnfd_id (leafref)
    """
        return self.__vnfd_id

    def _set_vnfd_id(self, v, load=False):
        """
    Setter method for vnfd_id, mapped from YANG variable /nsd/nsd/sapd/vnf/vnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd_id(self):
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_ext_cpd_id(self):
        """
    Getter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/vnf/ext_cpd_id (leafref)
    """
        return self.__ext_cpd_id

    def _set_ext_cpd_id(self, v, load=False):
        """
    Setter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/vnf/ext_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ext_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd_id(self):
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

    vnfd_id = __builtin__.property(_get_vnfd_id, _set_vnfd_id)
    ext_cpd_id = __builtin__.property(_get_ext_cpd_id, _set_ext_cpd_id)

    __choices__ = {'cpd-or-virtual-link': {'vnf': ['vnfd_id', 'ext_cpd_id']}}
    _pyangbind_elements = OrderedDict([('vnfd_id', vnfd_id), ('ext_cpd_id', ext_cpd_id), ])


class yc_pnf_etsi_nfv_nsd__nsd_nsd_sapd_pnf(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/sapd/pnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__pnfd_id', '__ext_cpd_id',)

    _yang_name = 'pnf'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'sapd', 'pnf']

    def _get_pnfd_id(self):
        """
    Getter method for pnfd_id, mapped from YANG variable /nsd/nsd/sapd/pnf/pnfd_id (leafref)
    """
        return self.__pnfd_id

    def _set_pnfd_id(self, v, load=False):
        """
    Setter method for pnfd_id, mapped from YANG variable /nsd/nsd/sapd/pnf/pnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnfd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnfd_id(self):
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_ext_cpd_id(self):
        """
    Getter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/pnf/ext_cpd_id (leafref)
    """
        return self.__ext_cpd_id

    def _set_ext_cpd_id(self, v, load=False):
        """
    Setter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/pnf/ext_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ext_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd_id(self):
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

    pnfd_id = __builtin__.property(_get_pnfd_id, _set_pnfd_id)
    ext_cpd_id = __builtin__.property(_get_ext_cpd_id, _set_ext_cpd_id)

    __choices__ = {'cpd-or-virtual-link': {'pnf': ['pnfd_id', 'ext_cpd_id']}}
    _pyangbind_elements = OrderedDict([('pnfd_id', pnfd_id), ('ext_cpd_id', ext_cpd_id), ])


class yc_ns_etsi_nfv_nsd__nsd_nsd_sapd_ns(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/sapd/ns. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__nsd_id', '__ext_cpd_id',)

    _yang_name = 'ns'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'sapd', 'ns']

    def _get_nsd_id(self):
        """
    Getter method for nsd_id, mapped from YANG variable /nsd/nsd/sapd/ns/nsd_id (leafref)
    """
        return self.__nsd_id

    def _set_nsd_id(self, v, load=False):
        """
    Setter method for nsd_id, mapped from YANG variable /nsd/nsd/sapd/ns/nsd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nsd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nsd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nsd_id(self):
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    def _get_ext_cpd_id(self):
        """
    Getter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/ns/ext_cpd_id (leafref)
    """
        return self.__ext_cpd_id

    def _set_ext_cpd_id(self, v, load=False):
        """
    Setter method for ext_cpd_id, mapped from YANG variable /nsd/nsd/sapd/ns/ext_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                             choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ext_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd_id(self):
        self.__ext_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ext-cpd-id", parent=self,
                                         choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

    nsd_id = __builtin__.property(_get_nsd_id, _set_nsd_id)
    ext_cpd_id = __builtin__.property(_get_ext_cpd_id, _set_ext_cpd_id)

    __choices__ = {'cpd-or-virtual-link': {'ns': ['nsd_id', 'ext_cpd_id']}}
    _pyangbind_elements = OrderedDict([('nsd_id', nsd_id), ('ext_cpd_id', ext_cpd_id), ])


class yc_sapd_etsi_nfv_nsd__nsd_nsd_sapd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/sapd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the descriptor of a service access point of the
network service.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__address_assignment', '__virtual_link_desc', '__vnf', '__pnf', '__ns',
        '__floating_ip_required',)

    _yang_name = 'sapd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address-assignment",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc",
                                                parent=self, choice=('cpd-or-virtual-link', 'virtual-link-desc'),
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__vnf = YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_sapd_vnf, is_container='container', yang_name="vnf",
                                  parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)
        self.__pnf = YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_sapd_pnf, is_container='container', yang_name="pnf",
                                  parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)
        self.__ns = YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_sapd_ns, is_container='container', yang_name="ns",
                                 parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, extensions=None,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                 yang_type='container', is_config=True)
        self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:osm:yang:augments:ns-various',
                                                   defining_module='ns-various', yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'sapd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/sapd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/sapd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_address_assignment(self):
        """
    Getter method for address_assignment, mapped from YANG variable /nsd/nsd/sapd/address_assignment (boolean)

    YANG Description: Specify whether the SAP address assignment is under the
responsibility of management and orchestration functions
or not. If it is set to True, management and
orchestration functions are responsible for assigning
addresses to the access points instantiated from this
SAPD.
    """
        return self.__address_assignment

    def _set_address_assignment(self, v, load=False):
        """
    Setter method for address_assignment, mapped from YANG variable /nsd/nsd/sapd/address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_assignment() directly.

    YANG Description: Specify whether the SAP address assignment is under the
responsibility of management and orchestration functions
or not. If it is set to True, management and
orchestration functions are responsible for assigning
addresses to the access points instantiated from this
SAPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_assignment(self):
        self.__address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="address-assignment",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_virtual_link_desc(self):
        """
    Getter method for virtual_link_desc, mapped from YANG variable /nsd/nsd/sapd/virtual_link_desc (leafref)

    YANG Description: References the descriptor of the NS VL instance to
which the SAP instantiated from this SAPD connects to.
    """
        return self.__virtual_link_desc

    def _set_virtual_link_desc(self, v, load=False):
        """
    Setter method for virtual_link_desc, mapped from YANG variable /nsd/nsd/sapd/virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_desc() directly.

    YANG Description: References the descriptor of the NS VL instance to
which the SAP instantiated from this SAPD connects to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-desc", parent=self,
                             choice=('cpd-or-virtual-link', 'virtual-link-desc'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc", parent=self, choice=('cpd-or-virtual-link', 'virtual-link-desc'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_desc(self):
        self.__virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc",
                                                parent=self, choice=('cpd-or-virtual-link', 'virtual-link-desc'),
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_vnf(self):
        """
    Getter method for vnf, mapped from YANG variable /nsd/nsd/sapd/vnf (container)
    """
        return self.__vnf

    def _set_vnf(self, v, load=False):
        """
    Setter method for vnf, mapped from YANG variable /nsd/nsd/sapd/vnf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_vnf_etsi_nfv_nsd__nsd_nsd_sapd_vnf, is_container='container', yang_name="vnf",
                             parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_sapd_vnf, is_container='container', yang_name="vnf", parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__vnf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf(self):
        self.__vnf = YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_sapd_vnf, is_container='container', yang_name="vnf",
                                  parent=self, choice=('cpd-or-virtual-link', 'vnf'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)

    def _get_pnf(self):
        """
    Getter method for pnf, mapped from YANG variable /nsd/nsd/sapd/pnf (container)
    """
        return self.__pnf

    def _set_pnf(self, v, load=False):
        """
    Setter method for pnf, mapped from YANG variable /nsd/nsd/sapd/pnf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_pnf_etsi_nfv_nsd__nsd_nsd_sapd_pnf, is_container='container', yang_name="pnf",
                             parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_sapd_pnf, is_container='container', yang_name="pnf", parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__pnf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf(self):
        self.__pnf = YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_sapd_pnf, is_container='container', yang_name="pnf",
                                  parent=self, choice=('cpd-or-virtual-link', 'pnf'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)

    def _get_ns(self):
        """
    Getter method for ns, mapped from YANG variable /nsd/nsd/sapd/ns (container)
    """
        return self.__ns

    def _set_ns(self, v, load=False):
        """
    Setter method for ns, mapped from YANG variable /nsd/nsd/sapd/ns (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_ns_etsi_nfv_nsd__nsd_nsd_sapd_ns, is_container='container', yang_name="ns",
                             parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_sapd_ns, is_container='container', yang_name="ns", parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__ns = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns(self):
        self.__ns = YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_sapd_ns, is_container='container', yang_name="ns",
                                 parent=self, choice=('cpd-or-virtual-link', 'ns'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, extensions=None,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                 yang_type='container', is_config=True)

    def _get_floating_ip_required(self):
        """
    Getter method for floating_ip_required, mapped from YANG variable /nsd/nsd/sapd/floating_ip_required (boolean)

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
        return self.__floating_ip_required

    def _set_floating_ip_required(self, v, load=False):
        """
    Setter method for floating_ip_required, mapped from YANG variable /nsd/nsd/sapd/floating_ip_required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_required() directly.

    YANG Description: Boolean parameter to indicate whether the CP must be exposed.
A public IP address will be allocated to this CP if exposed is true.
The default is false meaning a floating IP address is not required.
It must be explicitly asked for a floating IP address to be allocated.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_required must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_required = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_required(self):
        self.__floating_ip_required = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-required",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:osm:yang:augments:ns-various',
                                                   defining_module='ns-various', yang_type='boolean', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    address_assignment = __builtin__.property(_get_address_assignment, _set_address_assignment)
    virtual_link_desc = __builtin__.property(_get_virtual_link_desc, _set_virtual_link_desc)
    vnf = __builtin__.property(_get_vnf, _set_vnf)
    pnf = __builtin__.property(_get_pnf, _set_pnf)
    ns = __builtin__.property(_get_ns, _set_ns)
    floating_ip_required = __builtin__.property(_get_floating_ip_required, _set_floating_ip_required)

    __choices__ = {'cpd-or-virtual-link': {'virtual-link-desc': ['virtual_link_desc'], 'vnf': ['vnf'], 'pnf': ['pnf'],
                                           'ns': ['ns']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('address_assignment', address_assignment), ('virtual_link_desc', virtual_link_desc), ('vnf', vnf),
         ('pnf', pnf), ('ns', ns), ('floating_ip_required', floating_ip_required), ])


class yc_connectivity_type_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_connectivity_type(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/virtual-link-desc/connectivity-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__layer_protocol', '__flow_pattern',)

    _yang_name = 'connectivity-type'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='flow-pattern', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'virtual-link-desc', 'connectivity-type']

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type/layer_protocol (identityref)

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)

    def _get_flow_pattern(self):
        """
    Getter method for flow_pattern, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        return self.__flow_pattern

    def _set_flow_pattern(self, v, load=False):
        """
    Setter method for flow_pattern, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_pattern is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_pattern() directly.

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ),
                             is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='flow-pattern', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flow_pattern must be of a type compatible with flow-pattern""",
                'defined-type': "etsi-nfv-nsd:flow-pattern",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}},), is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='flow-pattern', is_config=True)""",
            })

        self.__flow_pattern = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flow_pattern(self):
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='flow-pattern', is_config=True)

    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    flow_pattern = __builtin__.property(_get_flow_pattern, _set_flow_pattern)

    _pyangbind_elements = OrderedDict([('layer_protocol', layer_protocol), ('flow_pattern', flow_pattern), ])


class yc_qos_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df_qos(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/virtual-link-desc/df/qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The QoS information element specifies quality of
service parameters applicable to a VL.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__latency', '__packet_delay_variation', '__packet_loss_ratio', '__priority',)

    _yang_name = 'qos'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)
        self.__priority = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'virtual-link-desc', 'df', 'qos']

    def _get_latency(self):
        """
    Getter method for latency, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/latency (uint32)

    YANG Description: Specifies the maximum latency in ms.
    """
        return self.__latency

    def _set_latency(self, v, load=False):
        """
    Setter method for latency, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/latency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency() directly.

    YANG Description: Specifies the maximum latency in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="latency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """latency must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__latency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_latency(self):
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    def _get_packet_delay_variation(self):
        """
    Getter method for packet_delay_variation, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/packet_delay_variation (uint32)

    YANG Description: Specifies the maximum jitter in ms.
    """
        return self.__packet_delay_variation

    def _set_packet_delay_variation(self, v, load=False):
        """
    Setter method for packet_delay_variation, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/packet_delay_variation (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_delay_variation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_delay_variation() directly.

    YANG Description: Specifies the maximum jitter in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="packet-delay-variation",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_delay_variation must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__packet_delay_variation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_delay_variation(self):
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    def _get_packet_loss_ratio(self):
        """
    Getter method for packet_loss_ratio, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/packet_loss_ratio (decimal64)

    YANG Description: Specifies the maximum packet loss ratio.
    """
        return self.__packet_loss_ratio

    def _set_packet_loss_ratio(self, v, load=False):
        """
    Setter method for packet_loss_ratio, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/packet_loss_ratio (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_loss_ratio() directly.

    YANG Description: Specifies the maximum packet loss ratio.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}),
                             is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_loss_ratio must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='decimal64', is_config=True)""",
            })

        self.__packet_loss_ratio = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_loss_ratio(self):
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='decimal64', is_config=True)

    def _get_priority(self):
        """
    Getter method for priority, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/priority (uint32)

    YANG Description: Specifies the priority level in case of
congestion on the underlying physical links.
    """
        return self.__priority

    def _set_priority(self, v, load=False):
        """
    Setter method for priority, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos/priority (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_priority is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_priority() directly.

    YANG Description: Specifies the priority level in case of
congestion on the underlying physical links.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="priority", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """priority must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__priority = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_priority(self):
        self.__priority = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="priority", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='uint32', is_config=True)

    latency = __builtin__.property(_get_latency, _set_latency)
    packet_delay_variation = __builtin__.property(_get_packet_delay_variation, _set_packet_delay_variation)
    packet_loss_ratio = __builtin__.property(_get_packet_loss_ratio, _set_packet_loss_ratio)
    priority = __builtin__.property(_get_priority, _set_priority)

    _pyangbind_elements = OrderedDict([('latency', latency), ('packet_delay_variation', packet_delay_variation),
                                       ('packet_loss_ratio', packet_loss_ratio), ('priority', priority), ])


class yc_df_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/virtual-link-desc/df. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The VirtualLinkDf information element specifies
properties for instantiating a VL according to a
specific flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__qos', '__service_availability_level',)

    _yang_name = 'df'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df_qos, is_container='container',
                                  yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)
        self.__service_availability_level = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'level-1': {}, 'level-2': {}, 'level-3': {}}, ), is_leaf=True,
            yang_name="service-availability-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'virtual-link-desc', 'df']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/id (string)

    YANG Description: Identifies this VirtualLinkDf information element
within a VLD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies this VirtualLinkDf information element
within a VLD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_qos(self):
        """
    Getter method for qos, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos (container)

    YANG Description: The QoS information element specifies quality of
service parameters applicable to a VL.
    """
        return self.__qos

    def _set_qos(self, v, load=False):
        """
    Setter method for qos, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: The QoS information element specifies quality of
service parameters applicable to a VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_qos_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df_qos, is_container='container',
                             yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """qos must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__qos = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_qos(self):
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df_qos, is_container='container',
                                  yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                  yang_type='container', is_config=True)

    def _get_service_availability_level(self):
        """
    Getter method for service_availability_level, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/service_availability_level (enumeration)

    YANG Description: Specifies one of the three levels defined in ETSI
ETSI GS NFV-REL 001 [i.5]
  * Level 1.
  * Level 2.
  * Level 3.
    """
        return self.__service_availability_level

    def _set_service_availability_level(self, v, load=False):
        """
    Setter method for service_availability_level, mapped from YANG variable /nsd/nsd/virtual_link_desc/df/service_availability_level (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service_availability_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service_availability_level() directly.

    YANG Description: Specifies one of the three levels defined in ETSI
ETSI GS NFV-REL 001 [i.5]
  * Level 1.
  * Level 2.
  * Level 3.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'level-1': {}, 'level-2': {},
                                                                          'level-3': {}}, ), is_leaf=True,
                             yang_name="service-availability-level", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """service_availability_level must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'level-1': {}, 'level-2': {}, 'level-3': {}},), is_leaf=True, yang_name="service-availability-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__service_availability_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_service_availability_level(self):
        self.__service_availability_level = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'level-1': {}, 'level-2': {}, 'level-3': {}}, ), is_leaf=True,
            yang_name="service-availability-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    qos = __builtin__.property(_get_qos, _set_qos)
    service_availability_level = __builtin__.property(_get_service_availability_level, _set_service_availability_level)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('qos', qos), ('service_availability_level', service_availability_level), ])


class yc_provider_network_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_provider_network(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/virtual-link-desc/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
    __slots__ = ('_path_helper', '_extmethods', '__physical_network', '__segmentation_id',)

    _yang_name = 'provider-network'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                               defining_module='ns-vld', yang_type='string', is_config=True)
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
            defining_module='ns-vld', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'virtual-link-desc', 'provider-network']

    def _get_physical_network(self):
        """
    Getter method for physical_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        return self.__physical_network

    def _set_physical_network(self, v, load=False):
        """
    Setter method for physical_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """physical_network must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='string', is_config=True)""",
            })

        self.__physical_network = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_physical_network(self):
        self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                               defining_module='ns-vld', yang_type='string', is_config=True)

    def _get_segmentation_id(self):
        """
    Getter method for segmentation_id, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
        return self.__segmentation_id

    def _set_segmentation_id(self, v, load=False):
        """
    Setter method for segmentation_id, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="segmentation_id",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                             defining_module='ns-vld', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """segmentation_id must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='uint32', is_config=True)""",
            })

        self.__segmentation_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_segmentation_id(self):
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
            defining_module='ns-vld', yang_type='uint32', is_config=True)

    physical_network = __builtin__.property(_get_physical_network, _set_physical_network)
    segmentation_id = __builtin__.property(_get_segmentation_id, _set_segmentation_id)

    _pyangbind_elements = OrderedDict([('physical_network', physical_network), ('segmentation_id', segmentation_id), ])


class yc_virtual_link_desc_etsi_nfv_nsd__nsd_nsd_virtual_link_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/virtual-link-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the constituent VLDs.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__connectivity_type', '__df', '__test_access', '__description',
                 '__signature', '__algorithm', '__certificate', '__provider_network', '__mgmt_network',
                 '__vim_network_name',)

    _yang_name = 'virtual-link-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df, yang_name="df", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="df", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__test_access = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'none': {},
                                                                                    'passive-monitoring': {},
                                                                                    'active': {}}, ), is_leaf=True,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='enumeration', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_provider_network, is_container='container',
            yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld',
            defining_module='ns-vld', yang_type='container', is_config=True)
        self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                           yang_name="mgmt-network", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                                           yang_type='boolean', is_config=True)
        self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                               defining_module='ns-vld', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'virtual-link-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/virtual_link_desc/id (string)

    YANG Description: Identifier of the NsVirtualLinkDesc information element.
It uniquely identifies a VLD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/virtual_link_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of the NsVirtualLinkDesc information element.
It uniquely identifies a VLD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_connectivity_type(self):
        """
    Getter method for connectivity_type, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type (container)
    """
        return self.__connectivity_type

    def _set_connectivity_type(self, v, load=False):
        """
    Setter method for connectivity_type, mapped from YANG variable /nsd/nsd/virtual_link_desc/connectivity_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectivity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectivity_type() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_connectivity_type_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_connectivity_type,
                             is_container='container', yang_name="connectivity-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """connectivity_type must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_connectivity_type_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_connectivity_type, is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__connectivity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_connectivity_type(self):
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_df(self):
        """
    Getter method for df, mapped from YANG variable /nsd/nsd/virtual_link_desc/df (list)

    YANG Description: The VirtualLinkDf information element specifies
properties for instantiating a VL according to a
specific flavour.
    """
        return self.__df

    def _set_df(self, v, load=False):
        """
    Setter method for df, mapped from YANG variable /nsd/nsd/virtual_link_desc/df (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df() directly.

    YANG Description: The VirtualLinkDf information element specifies
properties for instantiating a VL according to a
specific flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df, yang_name="df",
                                               parent=self, is_container='list', user_ordered=False,
                                               path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """df must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_df_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df, yang_name="df", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__df = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_df(self):
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_df, yang_name="df", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="df", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_test_access(self):
        """
    Getter method for test_access, mapped from YANG variable /nsd/nsd/virtual_link_desc/test_access (enumeration)

    YANG Description: Specifies test access facilities expected on the VL.
    """
        return self.__test_access

    def _set_test_access(self, v, load=False):
        """
    Setter method for test_access, mapped from YANG variable /nsd/nsd/virtual_link_desc/test_access (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_access() directly.

    YANG Description: Specifies test access facilities expected on the VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'none': {}, 'passive-monitoring': {},
                                                                          'active': {}}, ), is_leaf=True,
                             yang_name="test-access", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """test_access must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'none': {}, 'passive-monitoring': {}, 'active': {}},), is_leaf=True, yang_name="test-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__test_access = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_test_access(self):
        self.__test_access = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'none': {},
                                                                                    'passive-monitoring': {},
                                                                                    'active': {}}, ), is_leaf=True,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='enumeration', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/nsd/virtual_link_desc/description (string)

    YANG Description: Provides human-readable information on the purpose of
the virtual link (e.g. VL for control plane traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/nsd/virtual_link_desc/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of
the virtual link (e.g. VL for control plane traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_signature(self):
        """
    Getter method for signature, mapped from YANG variable /nsd/nsd/virtual_link_desc/signature (string)

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        return self.__signature

    def _set_signature(self, v, load=False):
        """
    Setter method for signature, mapped from YANG variable /nsd/nsd/virtual_link_desc/signature (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_signature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_signature() directly.

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """signature must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__signature = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_signature(self):
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_algorithm(self):
        """
    Getter method for algorithm, mapped from YANG variable /nsd/nsd/virtual_link_desc/algorithm (string)

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        return self.__algorithm

    def _set_algorithm(self, v, load=False):
        """
    Setter method for algorithm, mapped from YANG variable /nsd/nsd/virtual_link_desc/algorithm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """algorithm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__algorithm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_algorithm(self):
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_certificate(self):
        """
    Getter method for certificate, mapped from YANG variable /nsd/nsd/virtual_link_desc/certificate (string)

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        return self.__certificate

    def _set_certificate(self, v, load=False):
        """
    Setter method for certificate, mapped from YANG variable /nsd/nsd/virtual_link_desc/certificate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificate() directly.

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """certificate must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__certificate = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_certificate(self):
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_provider_network(self):
        """
    Getter method for provider_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network (container)

    YANG Description: Container for the provider network.
    """
        return self.__provider_network

    def _set_provider_network(self, v, load=False):
        """
    Setter method for provider_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_provider_network_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_provider_network,
                             is_container='container', yang_name="provider-network", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """provider_network must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_provider_network_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='container', is_config=True)""",
            })

        self.__provider_network = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_provider_network(self):
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_etsi_nfv_nsd__nsd_nsd_virtual_link_desc_provider_network, is_container='container',
            yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld',
            defining_module='ns-vld', yang_type='container', is_config=True)

    def _get_mgmt_network(self):
        """
    Getter method for mgmt_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/mgmt_network (boolean)

    YANG Description: Flag indicating whether this network is a VIM management network
    """
        return self.__mgmt_network

    def _set_mgmt_network(self, v, load=False):
        """
    Setter method for mgmt_network, mapped from YANG variable /nsd/nsd/virtual_link_desc/mgmt_network (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_network() directly.

    YANG Description: Flag indicating whether this network is a VIM management network
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                             defining_module='ns-vld', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mgmt_network must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='boolean', is_config=True)""",
            })

        self.__mgmt_network = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mgmt_network(self):
        self.__mgmt_network = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                           yang_name="mgmt-network", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                                           yang_type='boolean', is_config=True)

    def _get_vim_network_name(self):
        """
    Getter method for vim_network_name, mapped from YANG variable /nsd/nsd/virtual_link_desc/vim_network_name (string)

    YANG Description: Name of network in VIM account. This is used to indicate
pre-provisioned network name in cloud account.
    """
        return self.__vim_network_name

    def _set_vim_network_name(self, v, load=False):
        """
    Setter method for vim_network_name, mapped from YANG variable /nsd/nsd/virtual_link_desc/vim_network_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_network_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_network_name() directly.

    YANG Description: Name of network in VIM account. This is used to indicate
pre-provisioned network name in cloud account.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vim_network_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='string', is_config=True)""",
            })

        self.__vim_network_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vim_network_name(self):
        self.__vim_network_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-network-name",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                               defining_module='ns-vld', yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    connectivity_type = __builtin__.property(_get_connectivity_type, _set_connectivity_type)
    df = __builtin__.property(_get_df, _set_df)
    test_access = __builtin__.property(_get_test_access, _set_test_access)
    description = __builtin__.property(_get_description, _set_description)
    signature = __builtin__.property(_get_signature, _set_signature)
    algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
    certificate = __builtin__.property(_get_certificate, _set_certificate)
    provider_network = __builtin__.property(_get_provider_network, _set_provider_network)
    mgmt_network = __builtin__.property(_get_mgmt_network, _set_mgmt_network)
    vim_network_name = __builtin__.property(_get_vim_network_name, _set_vim_network_name)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('connectivity_type', connectivity_type), ('df', df), ('test_access', test_access),
         ('description', description), ('signature', signature), ('algorithm', algorithm), ('certificate', certificate),
         ('provider_network', provider_network), ('mgmt_network', mgmt_network),
         ('vim_network_name', vim_network_name), ])


class yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/vnf-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnf_profile_id',)

    _yang_name = 'vnf-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                                             choice=('constituent-base-element-id', 'vnf-profile'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                             defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'vnf-profile']

    def _get_vnf_profile_id(self):
        """
    Getter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf_profile/vnf_profile_id (leafref)
    """
        return self.__vnf_profile_id

    def _set_vnf_profile_id(self, v, load=False):
        """
    Setter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf_profile/vnf_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_profile_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                             choice=('constituent-base-element-id', 'vnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self, choice=('constituent-base-element-id', 'vnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_profile_id(self):
        self.__vnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                                             choice=('constituent-base-element-id', 'vnf-profile'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                             defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    vnf_profile_id = __builtin__.property(_get_vnf_profile_id, _set_vnf_profile_id)

    __choices__ = {'constituent-base-element-id': {'vnf-profile': ['vnf_profile_id']}}
    _pyangbind_elements = OrderedDict([('vnf_profile_id', vnf_profile_id), ])


class yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/pnf-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__pnf_profile_id',)

    _yang_name = 'pnf-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__pnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-profile-id", parent=self,
                                             choice=('constituent-base-element-id', 'pnf-profile'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                             defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'pnf-profile']

    def _get_pnf_profile_id(self):
        """
    Getter method for pnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf_profile/pnf_profile_id (leafref)
    """
        return self.__pnf_profile_id

    def _set_pnf_profile_id(self, v, load=False):
        """
    Setter method for pnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf_profile/pnf_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf_profile_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pnf-profile-id", parent=self,
                             choice=('constituent-base-element-id', 'pnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-profile-id", parent=self, choice=('constituent-base-element-id', 'pnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnf_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf_profile_id(self):
        self.__pnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-profile-id", parent=self,
                                             choice=('constituent-base-element-id', 'pnf-profile'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                             defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    pnf_profile_id = __builtin__.property(_get_pnf_profile_id, _set_pnf_profile_id)

    __choices__ = {'constituent-base-element-id': {'pnf-profile': ['pnf_profile_id']}}
    _pyangbind_elements = OrderedDict([('pnf_profile_id', pnf_profile_id), ])


class yc_ns_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/ns-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__ns_profile_id',)

    _yang_name = 'ns-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ns_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                                            choice=('constituent-base-element-id', 'ns-profile'),
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'ns-profile']

    def _get_ns_profile_id(self):
        """
    Getter method for ns_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns_profile/ns_profile_id (leafref)
    """
        return self.__ns_profile_id

    def _set_ns_profile_id(self, v, load=False):
        """
    Setter method for ns_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns_profile/ns_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_profile_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                             choice=('constituent-base-element-id', 'ns-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self, choice=('constituent-base-element-id', 'ns-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ns_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_profile_id(self):
        self.__ns_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                                            choice=('constituent-base-element-id', 'ns-profile'),
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    ns_profile_id = __builtin__.property(_get_ns_profile_id, _set_ns_profile_id)

    __choices__ = {'constituent-base-element-id': {'ns-profile': ['ns_profile_id']}}
    _pyangbind_elements = OrderedDict([('ns_profile_id', ns_profile_id), ])


class yc_vnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/vnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnfd_id', '__cpd_id',)

    _yang_name = 'vnf'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                                     choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'vnf']

    def _get_vnfd_id(self):
        """
    Getter method for vnfd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf/vnfd_id (leafref)
    """
        return self.__vnfd_id

    def _set_vnfd_id(self, v, load=False):
        """
    Setter method for vnfd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf/vnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                             choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self, choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd_id(self):
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_cpd_id(self):
        """
    Getter method for cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf/cpd_id (leafref)
    """
        return self.__cpd_id

    def _set_cpd_id(self, v, load=False):
        """
    Setter method for cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf/cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                             choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd_id(self):
        self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                                     choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    vnfd_id = __builtin__.property(_get_vnfd_id, _set_vnfd_id)
    cpd_id = __builtin__.property(_get_cpd_id, _set_cpd_id)

    __choices__ = {'constituent-cpd-id': {'vnf': ['vnfd_id', 'cpd_id']}}
    _pyangbind_elements = OrderedDict([('vnfd_id', vnfd_id), ('cpd_id', cpd_id), ])


class yc_pnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/pnf. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__pnfd_id', '__pnf_cpd_id',)

    _yang_name = 'pnf'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__pnf_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-cpd-id", parent=self,
                                         choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'pnf']

    def _get_pnfd_id(self):
        """
    Getter method for pnfd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf/pnfd_id (leafref)
    """
        return self.__pnfd_id

    def _set_pnfd_id(self, v, load=False):
        """
    Setter method for pnfd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf/pnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnfd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                             choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self, choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnfd_id(self):
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_pnf_cpd_id(self):
        """
    Getter method for pnf_cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf/pnf_cpd_id (leafref)
    """
        return self.__pnf_cpd_id

    def _set_pnf_cpd_id(self, v, load=False):
        """
    Setter method for pnf_cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf/pnf_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pnf-cpd-id", parent=self,
                             choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-cpd-id", parent=self, choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnf_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf_cpd_id(self):
        self.__pnf_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnf-cpd-id", parent=self,
                                         choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

    pnfd_id = __builtin__.property(_get_pnfd_id, _set_pnfd_id)
    pnf_cpd_id = __builtin__.property(_get_pnf_cpd_id, _set_pnf_cpd_id)

    __choices__ = {'constituent-cpd-id': {'pnf': ['pnfd_id', 'pnf_cpd_id']}}
    _pyangbind_elements = OrderedDict([('pnfd_id', pnfd_id), ('pnf_cpd_id', pnf_cpd_id), ])


class yc_ns_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool/ns. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__nsd_id', '__sap_cpd_id',)

    _yang_name = 'ns'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)
        self.__sap_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sap-cpd-id", parent=self,
                                         choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool', 'ns']

    def _get_nsd_id(self):
        """
    Getter method for nsd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns/nsd_id (leafref)
    """
        return self.__nsd_id

    def _set_nsd_id(self, v, load=False):
        """
    Setter method for nsd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns/nsd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                             choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nsd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self, choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nsd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nsd_id(self):
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    def _get_sap_cpd_id(self):
        """
    Getter method for sap_cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns/sap_cpd_id (leafref)
    """
        return self.__sap_cpd_id

    def _set_sap_cpd_id(self, v, load=False):
        """
    Setter method for sap_cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns/sap_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sap_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sap_cpd_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="sap-cpd-id", parent=self,
                             choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sap_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sap-cpd-id", parent=self, choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__sap_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sap_cpd_id(self):
        self.__sap_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sap-cpd-id", parent=self,
                                         choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='leafref', is_config=True)

    nsd_id = __builtin__.property(_get_nsd_id, _set_nsd_id)
    sap_cpd_id = __builtin__.property(_get_sap_cpd_id, _set_sap_cpd_id)

    __choices__ = {'constituent-cpd-id': {'ns': ['nsd_id', 'sap_cpd_id']}}
    _pyangbind_elements = OrderedDict([('nsd_id', nsd_id), ('sap_cpd_id', sap_cpd_id), ])


class yc_cpd_pool_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/cpd-pool. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a pool of descriptors of connection points
attached to one of the constituent VNFs and PNFs and/or
one of the SAPs of the parent NS or of a nested NS.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__vnf_profile', '__pnf_profile', '__ns_profile', '__vnf', '__pnf',
        '__ns',)

    _yang_name = 'cpd-pool'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vnf_profile = YANGDynClass(base=yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf_profile,
                                          is_container='container', yang_name="vnf-profile", parent=self,
                                          choice=('constituent-base-element-id', 'vnf-profile'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)
        self.__pnf_profile = YANGDynClass(base=yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf_profile,
                                          is_container='container', yang_name="pnf-profile", parent=self,
                                          choice=('constituent-base-element-id', 'pnf-profile'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)
        self.__ns_profile = YANGDynClass(base=yc_ns_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns_profile,
                                         is_container='container', yang_name="ns-profile", parent=self,
                                         choice=('constituent-base-element-id', 'ns-profile'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, extensions=None,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='container', is_config=True)
        self.__vnf = YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf, is_container='container',
                                  yang_name="vnf", parent=self, choice=('constituent-cpd-id', 'vnf'),
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__pnf = YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf, is_container='container',
                                  yang_name="pnf", parent=self, choice=('constituent-cpd-id', 'pnf'),
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        self.__ns = YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns, is_container='container',
                                 yang_name="ns", parent=self, choice=('constituent-cpd-id', 'ns'),
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'cpd-pool']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/id (string)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vnf_profile(self):
        """
    Getter method for vnf_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf_profile (container)
    """
        return self.__vnf_profile

    def _set_vnf_profile(self, v, load=False):
        """
    Setter method for vnf_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf_profile,
                             is_container='container', yang_name="vnf-profile", parent=self,
                             choice=('constituent-base-element-id', 'vnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_profile must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf_profile, is_container='container', yang_name="vnf-profile", parent=self, choice=('constituent-base-element-id', 'vnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__vnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_profile(self):
        self.__vnf_profile = YANGDynClass(base=yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf_profile,
                                          is_container='container', yang_name="vnf-profile", parent=self,
                                          choice=('constituent-base-element-id', 'vnf-profile'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)

    def _get_pnf_profile(self):
        """
    Getter method for pnf_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf_profile (container)
    """
        return self.__pnf_profile

    def _set_pnf_profile(self, v, load=False):
        """
    Setter method for pnf_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf_profile,
                             is_container='container', yang_name="pnf-profile", parent=self,
                             choice=('constituent-base-element-id', 'pnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf_profile must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf_profile, is_container='container', yang_name="pnf-profile", parent=self, choice=('constituent-base-element-id', 'pnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__pnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf_profile(self):
        self.__pnf_profile = YANGDynClass(base=yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf_profile,
                                          is_container='container', yang_name="pnf-profile", parent=self,
                                          choice=('constituent-base-element-id', 'pnf-profile'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                          yang_type='container', is_config=True)

    def _get_ns_profile(self):
        """
    Getter method for ns_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns_profile (container)
    """
        return self.__ns_profile

    def _set_ns_profile(self, v, load=False):
        """
    Setter method for ns_profile, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns_profile (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_ns_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns_profile,
                             is_container='container', yang_name="ns-profile", parent=self,
                             choice=('constituent-base-element-id', 'ns-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_profile must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_ns_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns_profile, is_container='container', yang_name="ns-profile", parent=self, choice=('constituent-base-element-id', 'ns-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__ns_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_profile(self):
        self.__ns_profile = YANGDynClass(base=yc_ns_profile_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns_profile,
                                         is_container='container', yang_name="ns-profile", parent=self,
                                         choice=('constituent-base-element-id', 'ns-profile'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, extensions=None,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                         yang_type='container', is_config=True)

    def _get_vnf(self):
        """
    Getter method for vnf, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf (container)
    """
        return self.__vnf

    def _set_vnf(self, v, load=False):
        """
    Setter method for vnf, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/vnf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_vnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf, is_container='container',
                             yang_name="vnf", parent=self, choice=('constituent-cpd-id', 'vnf'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf, is_container='container', yang_name="vnf", parent=self, choice=('constituent-cpd-id', 'vnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__vnf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf(self):
        self.__vnf = YANGDynClass(base=yc_vnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_vnf, is_container='container',
                                  yang_name="vnf", parent=self, choice=('constituent-cpd-id', 'vnf'),
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_pnf(self):
        """
    Getter method for pnf, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf (container)
    """
        return self.__pnf

    def _set_pnf(self, v, load=False):
        """
    Setter method for pnf, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/pnf (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_pnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf, is_container='container',
                             yang_name="pnf", parent=self, choice=('constituent-cpd-id', 'pnf'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf, is_container='container', yang_name="pnf", parent=self, choice=('constituent-cpd-id', 'pnf'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__pnf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf(self):
        self.__pnf = YANGDynClass(base=yc_pnf_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_pnf, is_container='container',
                                  yang_name="pnf", parent=self, choice=('constituent-cpd-id', 'pnf'),
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    def _get_ns(self):
        """
    Getter method for ns, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns (container)
    """
        return self.__ns

    def _set_ns(self, v, load=False):
        """
    Setter method for ns, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool/ns (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_ns_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns, is_container='container',
                             yang_name="ns", parent=self, choice=('constituent-cpd-id', 'ns'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns, is_container='container', yang_name="ns", parent=self, choice=('constituent-cpd-id', 'ns'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__ns = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns(self):
        self.__ns = YANGDynClass(base=yc_ns_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool_ns, is_container='container',
                                 yang_name="ns", parent=self, choice=('constituent-cpd-id', 'ns'),
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vnf_profile = __builtin__.property(_get_vnf_profile, _set_vnf_profile)
    pnf_profile = __builtin__.property(_get_pnf_profile, _set_pnf_profile)
    ns_profile = __builtin__.property(_get_ns_profile, _set_ns_profile)
    vnf = __builtin__.property(_get_vnf, _set_vnf)
    pnf = __builtin__.property(_get_pnf, _set_pnf)
    ns = __builtin__.property(_get_ns, _set_ns)

    __choices__ = {'constituent-base-element-id': {'vnf-profile': ['vnf_profile'], 'pnf-profile': ['pnf_profile'],
                                                   'ns-profile': ['ns_profile']},
                   'constituent-cpd-id': {'vnf': ['vnf'], 'pnf': ['pnf'], 'ns': ['ns']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('vnf_profile', vnf_profile), ('pnf_profile', pnf_profile), ('ns_profile', ns_profile),
         ('vnf', vnf), ('pnf', pnf), ('ns', ns), ])


class yc_constituent_profile_elements_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id_constituent_profile_elements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/nfpd/position-desc-id/cp-profile-id/constituent-profile-elements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the constituents of the CpProfile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__cpd_id',)

    _yang_name = 'constituent-profile-elements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'nfpd', 'position-desc-id', 'cp-profile-id', 'constituent-profile-elements']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements/id (string)

    YANG Description: Specifies the constituents of the CpProfile.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Specifies the constituents of the CpProfile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_cpd_id(self):
        """
    Getter method for cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements/cpd_id (string)

    YANG Description: References the VNF external CPD for a given
VnfProfile, or the PNF external CPD for a given
PnfProfile, or a NS SAPD for a give NsProfile
identified by the constituentBasedElementId.
    """
        return self.__cpd_id

    def _set_cpd_id(self, v, load=False):
        """
    Setter method for cpd_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements/cpd_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_id() directly.

    YANG Description: References the VNF external CPD for a given
VnfProfile, or the PNF external CPD for a given
PnfProfile, or a NS SAPD for a give NsProfile
identified by the constituentBasedElementId.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd_id(self):
        self.__cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    cpd_id = __builtin__.property(_get_cpd_id, _set_cpd_id)

    _pyangbind_elements = OrderedDict([('id', id), ('cpd_id', cpd_id), ])


class yc_cp_profile_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/nfpd/position-desc-id/cp-profile-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: References the profile of a connection point to be
traversed by the traffic flows matching the criteria.
This shall be a connection point attached to one of
the constituent VNFs and PNFs of the parent VNFFG,
or a SAP of one of the constituent nested NSs of the
parent VNFFG.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__constituent_profile_elements',)

    _yang_name = 'cp-profile-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__constituent_profile_elements = YANGDynClass(base=YANGListType("id",
                                                                             yc_constituent_profile_elements_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id_constituent_profile_elements,
                                                                             yang_name="constituent-profile-elements",
                                                                             parent=self, is_container='list',
                                                                             user_ordered=False,
                                                                             path_helper=self._path_helper,
                                                                             yang_keys='id', extensions=None),
                                                           is_container='list',
                                                           yang_name="constituent-profile-elements", parent=self,
                                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                                           register_paths=True, extensions=None,
                                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                           defining_module='etsi-nfv-nsd', yang_type='list',
                                                           is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'nfpd', 'position-desc-id', 'cp-profile-id']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/id (string)

    YANG Description: Identifier of this CpProfile information element.
It uniquely identifies a CpProfile.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this CpProfile information element.
It uniquely identifies a CpProfile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_constituent_profile_elements(self):
        """
    Getter method for constituent_profile_elements, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements (list)

    YANG Description: Specifies the constituents of the CpProfile.
    """
        return self.__constituent_profile_elements

    def _set_constituent_profile_elements(self, v, load=False):
        """
    Setter method for constituent_profile_elements, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id/constituent_profile_elements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_profile_elements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_profile_elements() directly.

    YANG Description: Specifies the constituents of the CpProfile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_constituent_profile_elements_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id_constituent_profile_elements,
                                                  yang_name="constituent-profile-elements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="constituent-profile-elements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_profile_elements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_constituent_profile_elements_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id_constituent_profile_elements, yang_name="constituent-profile-elements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="constituent-profile-elements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__constituent_profile_elements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_profile_elements(self):
        self.__constituent_profile_elements = YANGDynClass(base=YANGListType("id",
                                                                             yc_constituent_profile_elements_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id_constituent_profile_elements,
                                                                             yang_name="constituent-profile-elements",
                                                                             parent=self, is_container='list',
                                                                             user_ordered=False,
                                                                             path_helper=self._path_helper,
                                                                             yang_keys='id', extensions=None),
                                                           is_container='list',
                                                           yang_name="constituent-profile-elements", parent=self,
                                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                                           register_paths=True, extensions=None,
                                                           namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                           defining_module='etsi-nfv-nsd', yang_type='list',
                                                           is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    constituent_profile_elements = __builtin__.property(_get_constituent_profile_elements,
                                                        _set_constituent_profile_elements)

    _pyangbind_elements = OrderedDict([('id', id), ('constituent_profile_elements', constituent_profile_elements), ])


class yc_position_desc_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/nfpd/position-desc-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a position in the NFP in terms of one or
more CP profiles and rules for distributing the
traffic among CP and SAP instances created from the
CPD or SAPD associated to these profiles. This shall
be connection point profile, which is either a CPD
associated with the VnfProfile of a constituent VNF,
or a CPD associated with the PnfProfile of a
constituent PNF, or a SAPD associated with the
NsProfile of a nested NS. The related VnfProfile,
PnfProfile and NsProfile shall be included in the
parent VNFFGD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__cp_profile_id',)

    _yang_name = 'position-desc-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__cp_profile_id = YANGDynClass(
            base=YANGListType("id", yc_cp_profile_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id,
                              yang_name="cp-profile-id", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="cp-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'nfpd', 'position-desc-id']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/id (string)

    YANG Description: Identifier of this NfpPositionDesc element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this NfpPositionDesc element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_cp_profile_id(self):
        """
    Getter method for cp_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id (list)

    YANG Description: References the profile of a connection point to be
traversed by the traffic flows matching the criteria.
This shall be a connection point attached to one of
the constituent VNFs and PNFs of the parent VNFFG,
or a SAP of one of the constituent nested NSs of the
parent VNFFG.
    """
        return self.__cp_profile_id

    def _set_cp_profile_id(self, v, load=False):
        """
    Setter method for cp_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id/cp_profile_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cp_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cp_profile_id() directly.

    YANG Description: References the profile of a connection point to be
traversed by the traffic flows matching the criteria.
This shall be a connection point attached to one of
the constituent VNFs and PNFs of the parent VNFFG,
or a SAP of one of the constituent nested NSs of the
parent VNFFG.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_cp_profile_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id,
                                                  yang_name="cp-profile-id", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="cp-profile-id",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cp_profile_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_cp_profile_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id, yang_name="cp-profile-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cp-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__cp_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cp_profile_id(self):
        self.__cp_profile_id = YANGDynClass(
            base=YANGListType("id", yc_cp_profile_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id_cp_profile_id,
                              yang_name="cp-profile-id", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="cp-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    cp_profile_id = __builtin__.property(_get_cp_profile_id, _set_cp_profile_id)

    _pyangbind_elements = OrderedDict([('id', id), ('cp_profile_id', cp_profile_id), ])


class yc_nfpd_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd/nfpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network forwarding path associated to the VNFFG.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__rule', '__position_desc_id',)

    _yang_name = 'nfpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__rule = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rule", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__position_desc_id = YANGDynClass(
            base=YANGListType("id", yc_position_desc_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id,
                              yang_name="position-desc-id", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="position-desc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd', 'nfpd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/id (string)

    YANG Description: Identifies this nfpd information element within a
VNFFGD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies this nfpd information element within a
VNFFGD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_rule(self):
        """
    Getter method for rule, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/rule (string)

    YANG Description: Provides an NFP classification and selection rule.
The rule may be expressed as a criteria constructed
out of atomic assertions linked by Boolean operators
AND, OR and NOT.
    """
        return self.__rule

    def _set_rule(self, v, load=False):
        """
    Setter method for rule, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/rule (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.

    YANG Description: Provides an NFP classification and selection rule.
The rule may be expressed as a criteria constructed
out of atomic assertions linked by Boolean operators
AND, OR and NOT.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """rule must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_rule(self):
        self.__rule = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="rule", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_position_desc_id(self):
        """
    Getter method for position_desc_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id (list)

    YANG Description: Describes a position in the NFP in terms of one or
more CP profiles and rules for distributing the
traffic among CP and SAP instances created from the
CPD or SAPD associated to these profiles. This shall
be connection point profile, which is either a CPD
associated with the VnfProfile of a constituent VNF,
or a CPD associated with the PnfProfile of a
constituent PNF, or a SAPD associated with the
NsProfile of a nested NS. The related VnfProfile,
PnfProfile and NsProfile shall be included in the
parent VNFFGD.
    """
        return self.__position_desc_id

    def _set_position_desc_id(self, v, load=False):
        """
    Setter method for position_desc_id, mapped from YANG variable /nsd/nsd/vnffgd/nfpd/position_desc_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position_desc_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position_desc_id() directly.

    YANG Description: Describes a position in the NFP in terms of one or
more CP profiles and rules for distributing the
traffic among CP and SAP instances created from the
CPD or SAPD associated to these profiles. This shall
be connection point profile, which is either a CPD
associated with the VnfProfile of a constituent VNF,
or a CPD associated with the PnfProfile of a
constituent PNF, or a SAPD associated with the
NsProfile of a nested NS. The related VnfProfile,
PnfProfile and NsProfile shall be included in the
parent VNFFGD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_position_desc_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id,
                                                  yang_name="position-desc-id", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="position-desc-id",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """position_desc_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_position_desc_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id, yang_name="position-desc-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="position-desc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__position_desc_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_position_desc_id(self):
        self.__position_desc_id = YANGDynClass(
            base=YANGListType("id", yc_position_desc_id_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd_position_desc_id,
                              yang_name="position-desc-id", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="position-desc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    rule = __builtin__.property(_get_rule, _set_rule)
    position_desc_id = __builtin__.property(_get_position_desc_id, _set_position_desc_id)

    _pyangbind_elements = OrderedDict([('id', id), ('rule', rule), ('position_desc_id', position_desc_id), ])


class yc_vnffgd_etsi_nfv_nsd__nsd_nsd_vnffgd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/vnffgd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the descriptors of the applicable forwarding
graphs.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__vnf_profile_id', '__pnf_profile_id', '__nested_ns_profile_id',
        '__virtual_link_profile_id', '__cpd_pool', '__nfpd',)

    _yang_name = 'vnffgd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vnf_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="vnf-profile-id", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)
        self.__pnf_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="pnf-profile-id", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)
        self.__nested_ns_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="nested-ns-profile-id", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)
        self.__cpd_pool = YANGDynClass(
            base=YANGListType("id", yc_cpd_pool_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool, yang_name="cpd-pool",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="cpd-pool", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__nfpd = YANGDynClass(
            base=YANGListType("id", yc_nfpd_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd, yang_name="nfpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="nfpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'vnffgd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/vnffgd/id (string)

    YANG Description: Identifier of this Vnffgd information element. It
uniquely identifies a VNFFGD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/vnffgd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Vnffgd information element. It
uniquely identifies a VNFFGD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vnf_profile_id(self):
        """
    Getter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/vnf_profile_id (leafref)

    YANG Description: References the VnfProfile of a constituent VNF.
    """
        return self.__vnf_profile_id

    def _set_vnf_profile_id(self, v, load=False):
        """
    Setter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/vnf_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_profile_id() directly.

    YANG Description: References the VnfProfile of a constituent VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vnf-profile-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vnf-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_profile_id(self):
        self.__vnf_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="vnf-profile-id", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)

    def _get_pnf_profile_id(self):
        """
    Getter method for pnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/pnf_profile_id (leafref)

    YANG Description: References the PnfProfile of a constituent PNF.
    """
        return self.__pnf_profile_id

    def _set_pnf_profile_id(self, v, load=False):
        """
    Setter method for pnf_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/pnf_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf_profile_id() directly.

    YANG Description: References the PnfProfile of a constituent PNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="pnf-profile-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pnf-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnf_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf_profile_id(self):
        self.__pnf_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="pnf-profile-id", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)

    def _get_nested_ns_profile_id(self):
        """
    Getter method for nested_ns_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/nested_ns_profile_id (leafref)

    YANG Description: References the NsProfile of a nestedNS.
    """
        return self.__nested_ns_profile_id

    def _set_nested_ns_profile_id(self, v, load=False):
        """
    Setter method for nested_ns_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/nested_ns_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nested_ns_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nested_ns_profile_id() directly.

    YANG Description: References the NsProfile of a nestedNS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="nested-ns-profile-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nested_ns_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nested-ns-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nested_ns_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nested_ns_profile_id(self):
        self.__nested_ns_profile_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="nested-ns-profile-id", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_virtual_link_profile_id(self):
        """
    Getter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/virtual_link_profile_id (leafref)

    YANG Description: References the Virtual Link Profile of a constituent
  VL.
    """
        return self.__virtual_link_profile_id

    def _set_virtual_link_profile_id(self, v, load=False):
        """
    Setter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/vnffgd/virtual_link_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile_id() directly.

    YANG Description: References the Virtual Link Profile of a constituent
  VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile_id(self):
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)

    def _get_cpd_pool(self):
        """
    Getter method for cpd_pool, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool (list)

    YANG Description: Describes a pool of descriptors of connection points
attached to one of the constituent VNFs and PNFs and/or
one of the SAPs of the parent NS or of a nested NS.
    """
        return self.__cpd_pool

    def _set_cpd_pool(self, v, load=False):
        """
    Setter method for cpd_pool, mapped from YANG variable /nsd/nsd/vnffgd/cpd_pool (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_pool() directly.

    YANG Description: Describes a pool of descriptors of connection points
attached to one of the constituent VNFs and PNFs and/or
one of the SAPs of the parent NS or of a nested NS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_cpd_pool_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool,
                                                  yang_name="cpd-pool", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="cpd-pool",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd_pool must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_cpd_pool_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool, yang_name="cpd-pool", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="cpd-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__cpd_pool = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd_pool(self):
        self.__cpd_pool = YANGDynClass(
            base=YANGListType("id", yc_cpd_pool_etsi_nfv_nsd__nsd_nsd_vnffgd_cpd_pool, yang_name="cpd-pool",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="cpd-pool", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_nfpd(self):
        """
    Getter method for nfpd, mapped from YANG variable /nsd/nsd/vnffgd/nfpd (list)

    YANG Description: The network forwarding path associated to the VNFFG.
    """
        return self.__nfpd

    def _set_nfpd(self, v, load=False):
        """
    Setter method for nfpd, mapped from YANG variable /nsd/nsd/vnffgd/nfpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nfpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nfpd() directly.

    YANG Description: The network forwarding path associated to the VNFFG.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_nfpd_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd, yang_name="nfpd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="nfpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nfpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_nfpd_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd, yang_name="nfpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nfpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__nfpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nfpd(self):
        self.__nfpd = YANGDynClass(
            base=YANGListType("id", yc_nfpd_etsi_nfv_nsd__nsd_nsd_vnffgd_nfpd, yang_name="nfpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="nfpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vnf_profile_id = __builtin__.property(_get_vnf_profile_id, _set_vnf_profile_id)
    pnf_profile_id = __builtin__.property(_get_pnf_profile_id, _set_pnf_profile_id)
    nested_ns_profile_id = __builtin__.property(_get_nested_ns_profile_id, _set_nested_ns_profile_id)
    virtual_link_profile_id = __builtin__.property(_get_virtual_link_profile_id, _set_virtual_link_profile_id)
    cpd_pool = __builtin__.property(_get_cpd_pool, _set_cpd_pool)
    nfpd = __builtin__.property(_get_nfpd, _set_nfpd)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('vnf_profile_id', vnf_profile_id), ('pnf_profile_id', pnf_profile_id),
         ('nested_ns_profile_id', nested_ns_profile_id), ('virtual_link_profile_id', virtual_link_profile_id),
         ('cpd_pool', cpd_pool), ('nfpd', nfpd), ])


class yc_lifecycle_management_script_etsi_nfv_nsd__nsd_nsd_lifecycle_management_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/lifecycle-management-script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__event', '__script',)

    _yang_name = 'lifecycle-management-script'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__event = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                    defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'lifecycle-management-script']

    def _get_event(self):
        """
    Getter method for event, mapped from YANG variable /nsd/nsd/lifecycle_management_script/event (string)
    """
        return self.__event

    def _set_event(self, v, load=False):
        """
    Setter method for event, mapped from YANG variable /nsd/nsd/lifecycle_management_script/event (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="event", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """event must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__event = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_event(self):
        self.__event = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="event", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                    defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /nsd/nsd/lifecycle_management_script/script (string)
    """
        return self.__script

    def _set_script(self, v, load=False):
        """
    Setter method for script, mapped from YANG variable /nsd/nsd/lifecycle_management_script/script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='string', is_config=True)

    event = __builtin__.property(_get_event, _set_event)
    script = __builtin__.property(_get_script, _set_script)

    _pyangbind_elements = OrderedDict([('event', event), ('script', script), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/vnf-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'vnf-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_affinity_or_anti_affinity_group(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/vnf-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfProfile belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'vnf-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/vnf_profile/affinity_or_anti_affinity_group/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/vnf_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity_constituent_cpd_id(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/vnf-profile/virtual-link-connectivity/constituent-cpd-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__constituent_base_element_id', '__constituent_cpd_id', '__ip_address',)

    _yang_name = 'constituent-cpd-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                          defining_module='ns-vld', yang_type='leafref', is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                                 namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                 defining_module='ns-vld', yang_type='leafref', is_config=True)
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="ip-address", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                         defining_module='ns-vld', yang_type='inet:ip-address', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'vnf-profile', 'virtual-link-connectivity', 'constituent-cpd-id']

    def _get_constituent_base_element_id(self):
        """
    Getter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)

    YANG Description: Reference to the profile of an NS constituent.
    """
        return self.__constituent_base_element_id

    def _set_constituent_base_element_id(self, v, load=False):
        """
    Setter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_base_element_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_base_element_id() directly.

    YANG Description: Reference to the profile of an NS constituent.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_base_element_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_base_element_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_base_element_id(self):
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                          defining_module='ns-vld', yang_type='leafref', is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                                 namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                 defining_module='ns-vld', yang_type='leafref', is_config=True)

    def _get_ip_address(self):
        """
    Getter method for ip_address, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/ip_address (inet:ip-address)

    YANG Description: IP address assigned to the internal connection point
    """
        return self.__ip_address

    def _set_ip_address(self, v, load=False):
        """
    Setter method for ip_address, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address assigned to the internal connection point
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
                'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                      RestrictedClassType(base_type=six.text_type, restriction_dict={
                                          'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                             is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld',
                             yang_type='inet:ip-address', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address must be of a type compatible with inet:ip-address""",
                'defined-type': "inet:ip-address",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='inet:ip-address', is_config=True)""",
            })

        self.__ip_address = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="ip-address", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-vld',
                                         defining_module='ns-vld', yang_type='inet:ip-address', is_config=True)

    constituent_base_element_id = __builtin__.property(_get_constituent_base_element_id,
                                                       _set_constituent_base_element_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)
    ip_address = __builtin__.property(_get_ip_address, _set_ip_address)

    _pyangbind_elements = OrderedDict(
        [('constituent_base_element_id', constituent_base_element_id), ('constituent_cpd_id', constituent_cpd_id),
         ('ip_address', ip_address), ])


class yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/vnf-profile/virtual-link-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the connection information of the VNF, it
contains connection relationship between a VNF
connection point and a NS Virtual Link.
  """
    __slots__ = ('_path_helper', '_extmethods', '__virtual_link_profile_id', '__constituent_cpd_id',)

    _yang_name = 'virtual-link-connectivity'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id constituent_cpd_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id constituent-cpd-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                 defining_module='ns-vld', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'vnf-profile', 'virtual-link-connectivity']

    def _get_virtual_link_profile_id(self):
        """
    Getter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)

    YANG Description: Reference an NS VL profile.
    """
        return self.__virtual_link_profile_id

    def _set_virtual_link_profile_id(self, v, load=False):
        """
    Setter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile_id() directly.

    YANG Description: Reference an NS VL profile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile_id(self):
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id (list)

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity/constituent_cpd_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("constituent_base_element_id constituent_cpd_id",
                                                  yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                  yang_name="constituent-cpd-id", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='constituent-base-element-id constituent-cpd-id',
                                                  extensions=None), is_container='list', yang_name="constituent-cpd-id",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld',
                             defining_module='ns-vld', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("constituent_base_element_id constituent_cpd_id",yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity_constituent_cpd_id, yang_name="constituent-cpd-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='constituent-base-element-id constituent-cpd-id', extensions=None), is_container='list', yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-vld', defining_module='ns-vld', yang_type='list', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id constituent_cpd_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id constituent-cpd-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:osm:yang:augments:ns-vld',
                                                 defining_module='ns-vld', yang_type='list', is_config=True)

    virtual_link_profile_id = __builtin__.property(_get_virtual_link_profile_id, _set_virtual_link_profile_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)

    _pyangbind_elements = OrderedDict(
        [('virtual_link_profile_id', virtual_link_profile_id), ('constituent_cpd_id', constituent_cpd_id), ])


class yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_df_vnf_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/vnf-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VNF profile to be used for the NS flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__vnfd_id', '__flavour_id', '__instantiation_level',
                 '__min_number_of_instances', '__max_number_of_instances', '__local_affinity_or_anti_affinity_rule',
                 '__affinity_or_anti_affinity_group', '__virtual_link_connectivity',)

    _yang_name = 'vnf-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__flavour_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="instantiation-level",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'vnf-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/vnf_profile/id (string)

    YANG Description: Identifier of this vnfProfile information element. It
uniquely identifies a VnfProfile.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/vnf_profile/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this vnfProfile information element. It
uniquely identifies a VnfProfile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vnfd_id(self):
        """
    Getter method for vnfd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/vnfd_id (leafref)

    YANG Description: References a VNFD.
    """
        return self.__vnfd_id

    def _set_vnfd_id(self, v, load=False):
        """
    Setter method for vnfd_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/vnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id() directly.

    YANG Description: References a VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd_id(self):
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_flavour_id(self):
        """
    Getter method for flavour_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/flavour_id (leafref)

    YANG Description: Identifies a flavour within the VNFD.
    """
        return self.__flavour_id

    def _set_flavour_id(self, v, load=False):
        """
    Setter method for flavour_id, mapped from YANG variable /nsd/nsd/df/vnf_profile/flavour_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour_id() directly.

    YANG Description: Identifies a flavour within the VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__flavour_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour_id(self):
        self.__flavour_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_instantiation_level(self):
        """
    Getter method for instantiation_level, mapped from YANG variable /nsd/nsd/df/vnf_profile/instantiation_level (leafref)

    YANG Description: Identifier of the instantiation level of the VNF DF
to be used for instantiation. If not present, the
default instantiation level as declared in the VNFD
shall be used.
    """
        return self.__instantiation_level

    def _set_instantiation_level(self, v, load=False):
        """
    Setter method for instantiation_level, mapped from YANG variable /nsd/nsd/df/vnf_profile/instantiation_level (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiation_level() directly.

    YANG Description: Identifier of the instantiation level of the VNF DF
to be used for instantiation. If not present, the
default instantiation level as declared in the VNFD
shall be used.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="instantiation-level", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiation_level must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiation_level(self):
        self.__instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="instantiation-level",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_min_number_of_instances(self):
        """
    Getter method for min_number_of_instances, mapped from YANG variable /nsd/nsd/df/vnf_profile/min_number_of_instances (uint16)

    YANG Description: Minimum number of instances of the VNF based on this
VNFD that is permitted to exist for this VnfProfile.
    """
        return self.__min_number_of_instances

    def _set_min_number_of_instances(self, v, load=False):
        """
    Setter method for min_number_of_instances, mapped from YANG variable /nsd/nsd/df/vnf_profile/min_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_number_of_instances() directly.

    YANG Description: Minimum number of instances of the VNF based on this
VNFD that is permitted to exist for this VnfProfile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__min_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_number_of_instances(self):
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_max_number_of_instances(self):
        """
    Getter method for max_number_of_instances, mapped from YANG variable /nsd/nsd/df/vnf_profile/max_number_of_instances (uint16)

    YANG Description: Maximum number of instances of the VNF based on this
VNFD that is permitted to exist for this VnfProfile.
    """
        return self.__max_number_of_instances

    def _set_max_number_of_instances(self, v, load=False):
        """
    Setter method for max_number_of_instances, mapped from YANG variable /nsd/nsd/df/vnf_profile/max_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_number_of_instances() directly.

    YANG Description: Maximum number of instances of the VNF based on this
VNFD that is permitted to exist for this VnfProfile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__max_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_number_of_instances(self):
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/nsd/df/vnf_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/vnf_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfProfile belongs to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/vnf_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfProfile belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    def _get_virtual_link_connectivity(self):
        """
    Getter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity (list)

    YANG Description: Defines the connection information of the VNF, it
contains connection relationship between a VNF
connection point and a NS Virtual Link.
    """
        return self.__virtual_link_connectivity

    def _set_virtual_link_connectivity(self, v, load=False):
        """
    Setter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/vnf_profile/virtual_link_connectivity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_connectivity() directly.

    YANG Description: Defines the connection information of the VNF, it
contains connection relationship between a VNF
connection point and a NS Virtual Link.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("virtual_link_profile_id",
                                                  yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity,
                                                  yang_name="virtual-link-connectivity", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='virtual-link-profile-id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_connectivity must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("virtual_link_profile_id",yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity, yang_name="virtual-link-connectivity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-link-profile-id', extensions=None), is_container='list', yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_connectivity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_connectivity(self):
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_vnf_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vnfd_id = __builtin__.property(_get_vnfd_id, _set_vnfd_id)
    flavour_id = __builtin__.property(_get_flavour_id, _set_flavour_id)
    instantiation_level = __builtin__.property(_get_instantiation_level, _set_instantiation_level)
    min_number_of_instances = __builtin__.property(_get_min_number_of_instances, _set_min_number_of_instances)
    max_number_of_instances = __builtin__.property(_get_max_number_of_instances, _set_max_number_of_instances)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    virtual_link_connectivity = __builtin__.property(_get_virtual_link_connectivity, _set_virtual_link_connectivity)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('vnfd_id', vnfd_id), ('flavour_id', flavour_id), ('instantiation_level', instantiation_level),
         ('min_number_of_instances', min_number_of_instances), ('max_number_of_instances', max_number_of_instances),
         ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
         ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
         ('virtual_link_connectivity', virtual_link_connectivity), ])


class yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity_constituent_cpd_id(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/pnf-profile/virtual-link-connectivity/constituent-cpd-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
  """
    __slots__ = ('_path_helper', '_extmethods', '__constituent_base_element_id', '__constituent_cpd_id',)

    _yang_name = 'constituent-cpd-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'pnf-profile', 'virtual-link-connectivity', 'constituent-cpd-id']

    def _get_constituent_base_element_id(self):
        """
    Getter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)

    YANG Description: Reference to the profile of an NS constituent.
    """
        return self.__constituent_base_element_id

    def _set_constituent_base_element_id(self, v, load=False):
        """
    Setter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_base_element_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_base_element_id() directly.

    YANG Description: Reference to the profile of an NS constituent.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_base_element_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_base_element_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_base_element_id(self):
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        if hasattr(v, "_utype"): \
                v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    constituent_base_element_id = __builtin__.property(_get_constituent_base_element_id,
                                                       _set_constituent_base_element_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)

    _pyangbind_elements = OrderedDict(
        [('constituent_base_element_id', constituent_base_element_id), ('constituent_cpd_id', constituent_cpd_id), ])


class yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/pnf-profile/virtual-link-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the connection information of the PNF, it
contains connection relationship between a PNF
connection point and a NS Virtual Link.
  """
    __slots__ = ('_path_helper', '_extmethods', '__virtual_link_profile_id', '__constituent_cpd_id',)

    _yang_name = 'virtual-link-connectivity'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'pnf-profile', 'virtual-link-connectivity']

    def _get_virtual_link_profile_id(self):
        """
    Getter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)

    YANG Description: Reference an NS VL profile.
    """
        return self.__virtual_link_profile_id

    def _set_virtual_link_profile_id(self, v, load=False):
        """
    Setter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile_id() directly.

    YANG Description: Reference an NS VL profile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile_id(self):
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id (list)

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity/constituent_cpd_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("constituent_base_element_id",
                                                  yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                  yang_name="constituent-cpd-id", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='constituent-base-element-id', extensions=None),
                             is_container='list', yang_name="constituent-cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("constituent_base_element_id",yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity_constituent_cpd_id, yang_name="constituent-cpd-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='constituent-base-element-id', extensions=None), is_container='list', yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    virtual_link_profile_id = __builtin__.property(_get_virtual_link_profile_id, _set_virtual_link_profile_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)

    _pyangbind_elements = OrderedDict(
        [('virtual_link_profile_id', virtual_link_profile_id), ('constituent_cpd_id', constituent_cpd_id), ])


class yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_df_pnf_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/pnf-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__pnfd_id', '__virtual_link_connectivity',)

    _yang_name = 'pnf-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'pnf-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/pnf_profile/id (string)

    YANG Description: Identifier of this PnfProfile information element.
It uniquely identifies a PnfProfile.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/pnf_profile/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this PnfProfile information element.
It uniquely identifies a PnfProfile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_pnfd_id(self):
        """
    Getter method for pnfd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/pnfd_id (leafref)

    YANG Description: References a PNFD.
    """
        return self.__pnfd_id

    def _set_pnfd_id(self, v, load=False):
        """
    Setter method for pnfd_id, mapped from YANG variable /nsd/nsd/df/pnf_profile/pnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnfd_id() directly.

    YANG Description: References a PNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnfd_id(self):
        self.__pnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_virtual_link_connectivity(self):
        """
    Getter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity (list)

    YANG Description: Defines the connection information of the PNF, it
contains connection relationship between a PNF
connection point and a NS Virtual Link.
    """
        return self.__virtual_link_connectivity

    def _set_virtual_link_connectivity(self, v, load=False):
        """
    Setter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/pnf_profile/virtual_link_connectivity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_connectivity() directly.

    YANG Description: Defines the connection information of the PNF, it
contains connection relationship between a PNF
connection point and a NS Virtual Link.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("virtual_link_profile_id",
                                                  yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity,
                                                  yang_name="virtual-link-connectivity", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='virtual-link-profile-id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_connectivity must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("virtual_link_profile_id",yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity, yang_name="virtual-link-connectivity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-link-profile-id', extensions=None), is_container='list', yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_connectivity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_connectivity(self):
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_pnf_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    pnfd_id = __builtin__.property(_get_pnfd_id, _set_pnfd_id)
    virtual_link_connectivity = __builtin__.property(_get_virtual_link_connectivity, _set_virtual_link_connectivity)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('pnfd_id', pnfd_id), ('virtual_link_connectivity', virtual_link_connectivity), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_affinity_or_anti_affinity_group(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies an affinity or anti-affinity group the
VLs instantiated according to the VlProfile belong
to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_max_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_max_bitrate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/max-bitrate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'max-bitrate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'max-bitrate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements/root (uint64)

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements/root (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements/leaf (uint64)

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements/leaf (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_min_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_min_bitrate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/min-bitrate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'min-bitrate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'min-bitrate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements/root (uint64)

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements/root (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements/leaf (uint64)

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements/leaf (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_l2_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/virtual-link-protocol-data/l2-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__network_type', '__vlan_transparent', '__mtu',)

    _yang_name = 'l2-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
            yang_type='enumeration', is_config=True)
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                               defining_module='ip-profiles', yang_type='boolean', is_config=True)
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
            yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l2-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)

    YANG Description: Network name associated with this L2 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)

    def _get_network_type(self):
        """
    Getter method for network_type, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        return self.__network_type

    def _set_network_type(self, v, load=False):
        """
    Setter method for network_type, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_type() directly.

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {},
                                                                          'gre': {}}, ), is_leaf=True,
                             yang_name="network-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_type must be of a type compatible with enumeration""",
                'defined-type': "ip-profiles:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='enumeration', is_config=True)""",
            })

        self.__network_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_type(self):
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
            yang_type='enumeration', is_config=True)

    def _get_vlan_transparent(self):
        """
    Getter method for vlan_transparent, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        return self.__vlan_transparent

    def _set_vlan_transparent(self, v, load=False):
        """
    Setter method for vlan_transparent, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_transparent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_transparent() directly.

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vlan_transparent must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='boolean', is_config=True)""",
            })

        self.__vlan_transparent = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vlan_transparent(self):
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                               defining_module='ip-profiles', yang_type='boolean', is_config=True)

    def _get_mtu(self):
        """
    Getter method for mtu, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        return self.__mtu

    def _set_mtu(self, v, load=False):
        """
    Setter method for mtu, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16), is_leaf=True, yang_name="mtu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mtu must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='uint16', is_config=True)""",
            })

        self.__mtu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mtu(self):
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
            yang_type='uint16', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    network_type = __builtin__.property(_get_network_type, _set_network_type)
    vlan_transparent = __builtin__.property(_get_vlan_transparent, _set_vlan_transparent)
    mtu = __builtin__.property(_get_mtu, _set_mtu)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('network_type', network_type), ('vlan_transparent', vlan_transparent), ('mtu', mtu), ])


class yc_l3_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/virtual-link-protocol-data/l3-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__ip_version', '__cidr', '__ip_allocation_pools', '__gateway_ip',
        '__dhcp_enabled', '__ipv6_address_mode', '__security_group',)

    _yang_name = 'l3-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                         defining_module='ip-profiles', yang_type='enumeration', is_config=True)
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                                  defining_module='ip-profiles', yang_type='string', is_config=True)
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                         defining_module='ip-profiles', yang_type='inet:ip-address', is_config=True)
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                           defining_module='ip-profiles', yang_type='boolean', is_config=True)
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
            defining_module='ip-profiles', yang_type='enumeration', is_config=True)
        self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various',
                                             defining_module='ns-various', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l3-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)

    YANG Description: Network name associated with this L3 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)

    def _get_ip_version(self):
        """
    Getter method for ip_version, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)

    YANG Description: Specifies IP version of this L3 protocol.
Value:
 IPV4.
 IPV6.
    """
        return self.__ip_version

    def _set_ip_version(self, v, load=False):
        """
    Setter method for ip_version, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.

    YANG Description: Specifies IP version of this L3 protocol.
Value:
 IPV4.
 IPV6.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_version must be of a type compatible with enumeration""",
                'defined-type': "ip-profiles:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_version(self):
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                         defining_module='ip-profiles', yang_type='enumeration', is_config=True)

    def _get_cidr(self):
        """
    Getter method for cidr, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        return self.__cidr

    def _set_cidr(self, v, load=False):
        """
    Setter method for cidr, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cidr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cidr() directly.

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cidr must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='string', is_config=True)""",
            })

        self.__cidr = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cidr(self):
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                                   yang_type='string', is_config=True)

    def _get_ip_allocation_pools(self):
        """
    Getter method for ip_allocation_pools, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        return self.__ip_allocation_pools

    def _set_ip_allocation_pools(self, v, load=False):
        """
    Setter method for ip_allocation_pools, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_allocation_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_allocation_pools() directly.

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_allocation_pools must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='string', is_config=True)""",
            })

        self.__ip_allocation_pools = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_allocation_pools(self):
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                                  defining_module='ip-profiles', yang_type='string', is_config=True)

    def _get_gateway_ip(self):
        """
    Getter method for gateway_ip, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        return self.__gateway_ip

    def _set_gateway_ip(self, v, load=False):
        """
    Setter method for gateway_ip, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_ip() directly.

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
                'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                      RestrictedClassType(base_type=six.text_type, restriction_dict={
                                          'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                             is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='inet:ip-address', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """gateway_ip must be of a type compatible with inet:ip-address""",
                'defined-type': "inet:ip-address",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='inet:ip-address', is_config=True)""",
            })

        self.__gateway_ip = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_gateway_ip(self):
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                         defining_module='ip-profiles', yang_type='inet:ip-address', is_config=True)

    def _get_dhcp_enabled(self):
        """
    Getter method for dhcp_enabled, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        return self.__dhcp_enabled

    def _set_dhcp_enabled(self, v, load=False):
        """
    Setter method for dhcp_enabled, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enabled() directly.

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                             defining_module='ip-profiles', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """dhcp_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='boolean', is_config=True)""",
            })

        self.__dhcp_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_dhcp_enabled(self):
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:ip-profiles',
                                           defining_module='ip-profiles', yang_type='boolean', is_config=True)

    def _get_ipv6_address_mode(self):
        """
    Getter method for ipv6_address_mode, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)

    YANG Description: Specifies IPv6 address mode. Possible values:
 SLAAC.
 DHCPV6-STATEFUL.
 DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        return self.__ipv6_address_mode

    def _set_ipv6_address_mode(self, v, load=False):
        """
    Setter method for ipv6_address_mode, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address_mode() directly.

    YANG Description: Specifies IPv6 address mode. Possible values:
 SLAAC.
 DHCPV6-STATEFUL.
 DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'slaac': {}, 'dhcpv6-stateful': {},
                                                                          'dhcpv6-stateless': {}}, ), is_leaf=True,
                             yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ipv6_address_mode must be of a type compatible with enumeration""",
                'defined-type': "ip-profiles:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}},), is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='enumeration', is_config=True)""",
            })

        self.__ipv6_address_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ipv6_address_mode(self):
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
            defining_module='ip-profiles', yang_type='enumeration', is_config=True)

    def _get_security_group(self):
        """
    Getter method for security_group, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/security_group (string)

    YANG Description: Name of the security group
    """
        return self.__security_group

    def _set_security_group(self, v, load=False):
        """
    Setter method for security_group, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various', yang_type='string', is_config=True)""",
            })

        self.__security_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group(self):
        self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various',
                                             defining_module='ns-various', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
    cidr = __builtin__.property(_get_cidr, _set_cidr)
    ip_allocation_pools = __builtin__.property(_get_ip_allocation_pools, _set_ip_allocation_pools)
    gateway_ip = __builtin__.property(_get_gateway_ip, _set_gateway_ip)
    dhcp_enabled = __builtin__.property(_get_dhcp_enabled, _set_dhcp_enabled)
    ipv6_address_mode = __builtin__.property(_get_ipv6_address_mode, _set_ipv6_address_mode)
    security_group = __builtin__.property(_get_security_group, _set_security_group)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('ip_version', ip_version), ('cidr', cidr), ('ip_allocation_pools', ip_allocation_pools),
         ('gateway_ip', gateway_ip), ('dhcp_enabled', dhcp_enabled), ('ipv6_address_mode', ipv6_address_mode),
         ('security_group', security_group), ])


class yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile/virtual-link-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__associated_layer_protocol', '__l2_protocol_data', '__l3_protocol_data',)

    _yang_name = 'virtual-link-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
            defining_module='ip-profiles', yang_type='identityref', is_config=True)
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "ip-profiles:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ip-profiles',
            defining_module='ip-profiles', yang_type='identityref', is_config=True)

    def _get_l2_protocol_data(self):
        """
    Getter method for l2_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        return self.__l2_protocol_data

    def _set_l2_protocol_data(self, v, load=False):
        """
    Setter method for l2_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_protocol_data() directly.

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
                             is_container='container', yang_name="l2-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                             defining_module='ip-profiles', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data, is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container', is_config=True)""",
            })

        self.__l2_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_protocol_data(self):
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)

    def _get_l3_protocol_data(self):
        """
    Getter method for l3_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        return self.__l3_protocol_data

    def _set_l3_protocol_data(self, v, load=False):
        """
    Setter method for l3_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_protocol_data() directly.

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
                             is_container='container', yang_name="l3-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                             defining_module='ip-profiles', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data, is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container', is_config=True)""",
            })

        self.__l3_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_protocol_data(self):
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    l2_protocol_data = __builtin__.property(_get_l2_protocol_data, _set_l2_protocol_data)
    l3_protocol_data = __builtin__.property(_get_l3_protocol_data, _set_l3_protocol_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('l2_protocol_data', l2_protocol_data),
         ('l3_protocol_data', l3_protocol_data), ])


class yc_virtual_link_profile_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/virtual-link-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: VL profile to be used for the NS flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__virtual_link_desc_id', '__flavour_id',
                 '__local_affinity_or_anti_affinity_rule', '__affinity_or_anti_affinity_group',
                 '__max_bitrate_requirements', '__min_bitrate_requirements', '__virtual_link_protocol_data',)

    _yang_name = 'virtual-link-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__virtual_link_desc_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc-id",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__flavour_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)
        self.__max_bitrate_requirements = YANGDynClass(
            base=yc_max_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_max_bitrate_requirements,
            is_container='container', yang_name="max-bitrate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__min_bitrate_requirements = YANGDynClass(
            base=yc_min_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_min_bitrate_requirements,
            is_container='container', yang_name="min-bitrate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'virtual-link-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/id (string)

    YANG Description: Uniquely identifies this VirtualLinkProfile
information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies this VirtualLinkProfile
information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_virtual_link_desc_id(self):
        """
    Getter method for virtual_link_desc_id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_desc_id (leafref)

    YANG Description: Uniquely references a VLD.
    """
        return self.__virtual_link_desc_id

    def _set_virtual_link_desc_id(self, v, load=False):
        """
    Setter method for virtual_link_desc_id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_desc_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_desc_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_desc_id() directly.

    YANG Description: Uniquely references a VLD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-desc-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_desc_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_desc_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_desc_id(self):
        self.__virtual_link_desc_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-desc-id",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_flavour_id(self):
        """
    Getter method for flavour_id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/flavour_id (leafref)

    YANG Description: Identifies a flavour within the VLD.
    """
        return self.__flavour_id

    def _set_flavour_id(self, v, load=False):
        """
    Setter method for flavour_id, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/flavour_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour_id() directly.

    YANG Description: Identifies a flavour within the VLD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__flavour_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour_id(self):
        self.__flavour_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-id", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                   defining_module='etsi-nfv-nsd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifies an affinity or anti-affinity group the
VLs instantiated according to the VlProfile belong
to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifies an affinity or anti-affinity group the
VLs instantiated according to the VlProfile belong
to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({ \
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    def _get_max_bitrate_requirements(self):
        """
    Getter method for max_bitrate_requirements, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements (container)

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__max_bitrate_requirements

    def _set_max_bitrate_requirements(self, v, load=False):
        """
    Setter method for max_bitrate_requirements, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/max_bitrate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_bitrate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_bitrate_requirements() directly.

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_max_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_max_bitrate_requirements,
                             is_container='container', yang_name="max-bitrate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_bitrate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_max_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_max_bitrate_requirements, is_container='container', yang_name="max-bitrate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__max_bitrate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_bitrate_requirements(self):
        self.__max_bitrate_requirements = YANGDynClass(
            base=yc_max_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_max_bitrate_requirements,
            is_container='container', yang_name="max-bitrate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_min_bitrate_requirements(self):
        """
    Getter method for min_bitrate_requirements, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements (container)

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__min_bitrate_requirements

    def _set_min_bitrate_requirements(self, v, load=False):
        """
    Setter method for min_bitrate_requirements, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/min_bitrate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_bitrate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_bitrate_requirements() directly.

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_min_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_min_bitrate_requirements,
                             is_container='container', yang_name="min-bitrate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_bitrate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_min_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_min_bitrate_requirements, is_container='container', yang_name="min-bitrate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__min_bitrate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_bitrate_requirements(self):
        self.__min_bitrate_requirements = YANGDynClass(
            base=yc_min_bitrate_requirements_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_min_bitrate_requirements,
            is_container='container', yang_name="min-bitrate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_virtual_link_protocol_data(self):
        """
    Getter method for virtual_link_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data (container)

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        return self.__virtual_link_protocol_data

    def _set_virtual_link_protocol_data(self, v, load=False):
        """
    Setter method for virtual_link_protocol_data, mapped from YANG variable /nsd/nsd/df/virtual_link_profile/virtual_link_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_protocol_data() directly.

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data,
                             is_container='container', yang_name="virtual-link-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles',
                             defining_module='ip-profiles', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data, is_container='container', yang_name="virtual-link-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container', is_config=True)""",
            })

        self.__virtual_link_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_protocol_data(self):
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ip-profiles', defining_module='ip-profiles', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    virtual_link_desc_id = __builtin__.property(_get_virtual_link_desc_id, _set_virtual_link_desc_id)
    flavour_id = __builtin__.property(_get_flavour_id, _set_flavour_id)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    max_bitrate_requirements = __builtin__.property(_get_max_bitrate_requirements, _set_max_bitrate_requirements)
    min_bitrate_requirements = __builtin__.property(_get_min_bitrate_requirements, _set_min_bitrate_requirements)
    virtual_link_protocol_data = __builtin__.property(_get_virtual_link_protocol_data, _set_virtual_link_protocol_data)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('virtual_link_desc_id', virtual_link_desc_id), ('flavour_id', flavour_id),
         ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
         ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
         ('max_bitrate_requirements', max_bitrate_requirements), ('min_bitrate_requirements', min_bitrate_requirements),
         ('virtual_link_protocol_data', virtual_link_protocol_data), ])


class yc_scaling_aspect_etsi_nfv_nsd__nsd_nsd_df_scaling_aspect(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/scaling-aspect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scaling aspects supported by this DF of the NS.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__description', '__scaling_level',)

    _yang_name = 'scaling-aspect'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__scaling_level = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-level", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'scaling-aspect']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/scaling_aspect/id (string)

    YANG Description: Identifier of this NsScalingAspect information element.
It uniquely identifies the NS scaling aspect in an
NSD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/scaling_aspect/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this NsScalingAspect information element.
It uniquely identifies the NS scaling aspect in an
NSD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/df/scaling_aspect/name (string)

    YANG Description: Provides a human readable name of the NS scaling
aspect.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/df/scaling_aspect/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name of the NS scaling
aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/nsd/df/scaling_aspect/description (string)

    YANG Description: Provides a human readable description of the NS
scaling aspect.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/nsd/df/scaling_aspect/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the NS
scaling aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_scaling_level(self):
        """
    Getter method for scaling_level, mapped from YANG variable /nsd/nsd/df/scaling_aspect/scaling_level (leafref)

    YANG Description: Describes the details of an NS level.
    """
        return self.__scaling_level

    def _set_scaling_level(self, v, load=False):
        """
    Setter method for scaling_level, mapped from YANG variable /nsd/nsd/df/scaling_aspect/scaling_level (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_level() directly.

    YANG Description: Describes the details of an NS level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="scaling-level", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_level must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__scaling_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_level(self):
        self.__scaling_level = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-level", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    scaling_level = __builtin__.property(_get_scaling_level, _set_scaling_level)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('description', description), ('scaling_level', scaling_level), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_affinity_or_anti_affinity_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies affinity or anti-affinity relationship
applicable between the VNF instances created using
different VNFDs, the Virtual Link instances created
using different NsVirtualLinkDescs or the nested NS
instances created using different NSDs in the same
affinity or anti-affinity group.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__type', '__scope',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='affinity-type', is_config=True)
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='affinity-scope', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/id (string)

    YANG Description: Identifier of Identifier of this
AffinityOrAntiAffinityGroup information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of Identifier of this
AffinityOrAntiAffinityGroup information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/type (affinity-type)

    YANG Description: Specifies the type of relationship that the members of
the group have: 'affinity' or 'anti-affinity.'
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of relationship that the members of
the group have: 'affinity' or 'anti-affinity.'
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-nsd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-type', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='affinity-type', is_config=True)

    def _get_scope(self):
        """
    Getter method for scope, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/scope (affinity-scope)

    YANG Description: Specifies the scope of the affinity or anti-affinity
relationship e.g. a NFVI node, an NFVI PoP, etc.
    """
        return self.__scope

    def _set_scope(self, v, load=False):
        """
    Setter method for scope, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group/scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scope() directly.

    YANG Description: Specifies the scope of the affinity or anti-affinity
relationship e.g. a NFVI node, an NFVI PoP, etc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-nsd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scope(self):
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                    yang_type='affinity-scope', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    type = __builtin__.property(_get_type, _set_type)
    scope = __builtin__.property(_get_scope, _set_scope)

    _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('scope', scope), ])


class yc_vnf_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_vnf_to_level_mapping(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-instantiation-level/vnf-to-level-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the profile of the VNFs involved in this NS
level and, for each of them, the required number of
instances.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnf_profile_id', '__number_of_instances',)

    _yang_name = 'vnf-to-level-mapping'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, is_keyval=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-instantiation-level', 'vnf-to-level-mapping']

    def _get_vnf_profile_id(self):
        """
    Getter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping/vnf_profile_id (leafref)

    YANG Description: Identifies the profile to be used for a VNF
involved in an NS level.
    """
        return self.__vnf_profile_id

    def _set_vnf_profile_id(self, v, load=False):
        """
    Setter method for vnf_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping/vnf_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_profile_id() directly.

    YANG Description: Identifies the profile to be used for a VNF
involved in an NS level.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_profile_id(self):
        self.__vnf_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-profile-id", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, is_keyval=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping/number_of_instances (uint32)

    YANG Description: Specifies the number of VNF instances required for
an NS level.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping/number_of_instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Specifies the number of VNF instances required for
an NS level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True, yang_name="number-of-instances",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    vnf_profile_id = __builtin__.property(_get_vnf_profile_id, _set_vnf_profile_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict(
        [('vnf_profile_id', vnf_profile_id), ('number_of_instances', number_of_instances), ])


class yc_virtual_link_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_virtual_link_to_level_mapping(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-instantiation-level/virtual-link-to-level-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the profile of the VLs involved in this NS
level and, for each of them, the needed bandwidth.
  """
    __slots__ = ('_path_helper', '_extmethods', '__virtual_link_profile_id', '__root', '__leaf',)

    _yang_name = 'virtual-link-to-level-mapping'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-instantiation-level', 'virtual-link-to-level-mapping']

    def _get_virtual_link_profile_id(self):
        """
    Getter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/virtual_link_profile_id (leafref)

    YANG Description: Identifies the profile to be used for a VL involved
in an NS level.
    """
        return self.__virtual_link_profile_id

    def _set_virtual_link_profile_id(self, v, load=False):
        """
    Setter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/virtual_link_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile_id() directly.

    YANG Description: Identifies the profile to be used for a VL involved
in an NS level.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile_id(self):
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/root (uint64)

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/root (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Specifies the throughput requirement of
the link (e.g. bitrate of E-Line, root bitrate
of E-Tree, aggregate capacity of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="root", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/leaf (uint64)

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping/leaf (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Specifies the throughput requirement of
leaf connections to the link when
applicable to the connectivity type (e.g. for
E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="leaf", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint64',
            is_config=True)

    virtual_link_profile_id = __builtin__.property(_get_virtual_link_profile_id, _set_virtual_link_profile_id)
    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict(
        [('virtual_link_profile_id', virtual_link_profile_id), ('root', root), ('leaf', leaf), ])


class yc_ns_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_ns_to_level_mapping(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-instantiation-level/ns-to-level-mapping. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the profile of the nested NSs involved in
this NS level and, for each of them, the required
number of instances.
  """
    __slots__ = ('_path_helper', '_extmethods', '__ns_profile_id', '__number_of_instances',)

    _yang_name = 'ns-to-level-mapping'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ns_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, is_keyval=True,
                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                            yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-instantiation-level', 'ns-to-level-mapping']

    def _get_ns_profile_id(self):
        """
    Getter method for ns_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping/ns_profile_id (leafref)

    YANG Description: Identifies the profile to be used for a nested NS
involved in the NS level.
    """
        return self.__ns_profile_id

    def _set_ns_profile_id(self, v, load=False):
        """
    Setter method for ns_profile_id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping/ns_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_profile_id() directly.

    YANG Description: Identifies the profile to be used for a nested NS
involved in the NS level.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ns_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_profile_id(self):
        self.__ns_profile_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-profile-id", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, is_keyval=True,
                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                            yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping/number_of_instances (uint32)

    YANG Description: Specifies the number of nested NS instances required
for the NS scale level.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping/number_of_instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Specifies the number of nested NS instances required
for the NS scale level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True, yang_name="number-of-instances",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    ns_profile_id = __builtin__.property(_get_ns_profile_id, _set_ns_profile_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict(
        [('ns_profile_id', ns_profile_id), ('number_of_instances', number_of_instances), ])


class yc_ns_instantiation_level_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-instantiation-level. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the details of an NS level.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__description', '__vnf_to_level_mapping',
        '__virtual_link_to_level_mapping',
        '__ns_to_level_mapping',)

    _yang_name = 'ns-instantiation-level'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vnf_to_level_mapping = YANGDynClass(base=YANGListType("vnf_profile_id",
                                                                     yc_vnf_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_vnf_to_level_mapping,
                                                                     yang_name="vnf-to-level-mapping", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper,
                                                                     yang_keys='vnf-profile-id', extensions=None),
                                                   is_container='list', yang_name="vnf-to-level-mapping", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__virtual_link_to_level_mapping = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                              yc_virtual_link_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_virtual_link_to_level_mapping,
                                                                              yang_name="virtual-link-to-level-mapping",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='virtual-link-profile-id',
                                                                              extensions=None), is_container='list',
                                                            yang_name="virtual-link-to-level-mapping", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)
        self.__ns_to_level_mapping = YANGDynClass(base=YANGListType("ns_profile_id",
                                                                    yc_ns_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_ns_to_level_mapping,
                                                                    yang_name="ns-to-level-mapping", parent=self,
                                                                    is_container='list', user_ordered=False,
                                                                    path_helper=self._path_helper,
                                                                    yang_keys='ns-profile-id', extensions=None),
                                                  is_container='list', yang_name="ns-to-level-mapping", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, extensions=None,
                                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-instantiation-level']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/id (string)

    YANG Description: Identifier of this NsLevel information element. It
uniquely identifies an NS level within the DF.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this NsLevel information element. It
uniquely identifies an NS level within the DF.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/description (string)

    YANG Description: Human readable description of the NS level.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the NS level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vnf_to_level_mapping(self):
        """
    Getter method for vnf_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping (list)

    YANG Description: Specifies the profile of the VNFs involved in this NS
level and, for each of them, the required number of
instances.
    """
        return self.__vnf_to_level_mapping

    def _set_vnf_to_level_mapping(self, v, load=False):
        """
    Setter method for vnf_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/vnf_to_level_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_to_level_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_to_level_mapping() directly.

    YANG Description: Specifies the profile of the VNFs involved in this NS
level and, for each of them, the required number of
instances.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("vnf_profile_id",
                                                  yc_vnf_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_vnf_to_level_mapping,
                                                  yang_name="vnf-to-level-mapping", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='vnf-profile-id', extensions=None), is_container='list',
                             yang_name="vnf-to-level-mapping", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_to_level_mapping must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("vnf_profile_id",yc_vnf_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_vnf_to_level_mapping, yang_name="vnf-to-level-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vnf-profile-id', extensions=None), is_container='list', yang_name="vnf-to-level-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vnf_to_level_mapping = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_to_level_mapping(self):
        self.__vnf_to_level_mapping = YANGDynClass(base=YANGListType("vnf_profile_id",
                                                                     yc_vnf_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_vnf_to_level_mapping,
                                                                     yang_name="vnf-to-level-mapping", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper,
                                                                     yang_keys='vnf-profile-id', extensions=None),
                                                   is_container='list', yang_name="vnf-to-level-mapping", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_virtual_link_to_level_mapping(self):
        """
    Getter method for virtual_link_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping (list)

    YANG Description: Specifies the profile of the VLs involved in this NS
level and, for each of them, the needed bandwidth.
    """
        return self.__virtual_link_to_level_mapping

    def _set_virtual_link_to_level_mapping(self, v, load=False):
        """
    Setter method for virtual_link_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/virtual_link_to_level_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_to_level_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_to_level_mapping() directly.

    YANG Description: Specifies the profile of the VLs involved in this NS
level and, for each of them, the needed bandwidth.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("virtual_link_profile_id",
                                                  yc_virtual_link_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_virtual_link_to_level_mapping,
                                                  yang_name="virtual-link-to-level-mapping", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='virtual-link-profile-id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-link-to-level-mapping", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_to_level_mapping must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("virtual_link_profile_id",yc_virtual_link_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_virtual_link_to_level_mapping, yang_name="virtual-link-to-level-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-link-profile-id', extensions=None), is_container='list', yang_name="virtual-link-to-level-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_to_level_mapping = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_to_level_mapping(self):
        self.__virtual_link_to_level_mapping = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                              yc_virtual_link_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_virtual_link_to_level_mapping,
                                                                              yang_name="virtual-link-to-level-mapping",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='virtual-link-profile-id',
                                                                              extensions=None), is_container='list',
                                                            yang_name="virtual-link-to-level-mapping", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                            defining_module='etsi-nfv-nsd', yang_type='list',
                                                            is_config=True)

    def _get_ns_to_level_mapping(self):
        """
    Getter method for ns_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping (list)

    YANG Description: Specifies the profile of the nested NSs involved in
this NS level and, for each of them, the required
number of instances.
    """
        return self.__ns_to_level_mapping

    def _set_ns_to_level_mapping(self, v, load=False):
        """
    Setter method for ns_to_level_mapping, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level/ns_to_level_mapping (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_to_level_mapping is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_to_level_mapping() directly.

    YANG Description: Specifies the profile of the nested NSs involved in
this NS level and, for each of them, the required
number of instances.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("ns_profile_id",
                                                  yc_ns_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_ns_to_level_mapping,
                                                  yang_name="ns-to-level-mapping", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='ns-profile-id', extensions=None), is_container='list',
                             yang_name="ns-to-level-mapping", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_to_level_mapping must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("ns_profile_id",yc_ns_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_ns_to_level_mapping, yang_name="ns-to-level-mapping", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='ns-profile-id', extensions=None), is_container='list', yang_name="ns-to-level-mapping", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__ns_to_level_mapping = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_to_level_mapping(self):
        self.__ns_to_level_mapping = YANGDynClass(base=YANGListType("ns_profile_id",
                                                                    yc_ns_to_level_mapping_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level_ns_to_level_mapping,
                                                                    yang_name="ns-to-level-mapping", parent=self,
                                                                    is_container='list', user_ordered=False,
                                                                    path_helper=self._path_helper,
                                                                    yang_keys='ns-profile-id', extensions=None),
                                                  is_container='list', yang_name="ns-to-level-mapping", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, extensions=None,
                                                  namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vnf_to_level_mapping = __builtin__.property(_get_vnf_to_level_mapping, _set_vnf_to_level_mapping)
    virtual_link_to_level_mapping = __builtin__.property(_get_virtual_link_to_level_mapping,
                                                         _set_virtual_link_to_level_mapping)
    ns_to_level_mapping = __builtin__.property(_get_ns_to_level_mapping, _set_ns_to_level_mapping)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('vnf_to_level_mapping', vnf_to_level_mapping),
         ('virtual_link_to_level_mapping', virtual_link_to_level_mapping),
         ('ns_to_level_mapping', ns_to_level_mapping), ])


class yc_affinity_or_anti_affinity_group_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_affinity_or_anti_affinity_group_id(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-profile/affinity-or-anti-affinity-group-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies an affinity or anti-affinity group the NSs
created according to this NsProfile belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-profile', 'affinity-or-anti-affinity-group-id']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/ns_profile/affinity_or_anti_affinity_group_id/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/ns_profile/affinity_or_anti_affinity_group_id/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity_constituent_cpd_id(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-profile/virtual-link-connectivity/constituent-cpd-id. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
  """
    __slots__ = ('_path_helper', '_extmethods', '__constituent_base_element_id', '__constituent_cpd_id',)

    _yang_name = 'constituent-cpd-id'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-profile', 'virtual-link-connectivity', 'constituent-cpd-id']

    def _get_constituent_base_element_id(self):
        """
    Getter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)

    YANG Description: Reference to the profile of an NS constituent.
    """
        return self.__constituent_base_element_id

    def _set_constituent_base_element_id(self, v, load=False):
        """
    Setter method for constituent_base_element_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id/constituent_base_element_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_base_element_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_base_element_id() directly.

    YANG Description: Reference to the profile of an NS constituent.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_base_element_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-base-element-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_base_element_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_base_element_id(self):
        self.__constituent_base_element_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="constituent-base-element-id", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True, is_keyval=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id/constituent_cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: A reference to the descriptor of a connection point
attached to one of the constituent VNFs and PNFs or to
the descriptor of a NS SAP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="constituent-cpd-id",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    constituent_base_element_id = __builtin__.property(_get_constituent_base_element_id,
                                                       _set_constituent_base_element_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)

    _pyangbind_elements = OrderedDict(
        [('constituent_base_element_id', constituent_base_element_id), ('constituent_cpd_id', constituent_cpd_id), ])


class yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-profile/virtual-link-connectivity. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__virtual_link_profile_id', '__constituent_cpd_id',)

    _yang_name = 'virtual-link-connectivity'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-profile', 'virtual-link-connectivity']

    def _get_virtual_link_profile_id(self):
        """
    Getter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)

    YANG Description: Reference an NS VL profile.
    """
        return self.__virtual_link_profile_id

    def _set_virtual_link_profile_id(self, v, load=False):
        """
    Setter method for virtual_link_profile_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/virtual_link_profile_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile_id() directly.

    YANG Description: Reference an NS VL profile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-link-profile-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_profile_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile_id(self):
        self.__virtual_link_profile_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="virtual-link-profile-id", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, is_keyval=True,
                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                      defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                      is_config=True)

    def _get_constituent_cpd_id(self):
        """
    Getter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id (list)

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        return self.__constituent_cpd_id

    def _set_constituent_cpd_id(self, v, load=False):
        """
    Setter method for constituent_cpd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity/constituent_cpd_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_constituent_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_constituent_cpd_id() directly.

    YANG Description: Describes a connection point on a VNF/PNF or a SAP
which connects to virtual links instantiated from
the profile identified in the virtualLinkProfileId
attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("constituent_base_element_id",
                                                  yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity_constituent_cpd_id,
                                                  yang_name="constituent-cpd-id", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='constituent-base-element-id', extensions=None),
                             is_container='list', yang_name="constituent-cpd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """constituent_cpd_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("constituent_base_element_id",yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity_constituent_cpd_id, yang_name="constituent-cpd-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='constituent-base-element-id', extensions=None), is_container='list', yang_name="constituent-cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__constituent_cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_constituent_cpd_id(self):
        self.__constituent_cpd_id = YANGDynClass(base=YANGListType("constituent_base_element_id",
                                                                   yc_constituent_cpd_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity_constituent_cpd_id,
                                                                   yang_name="constituent-cpd-id", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper,
                                                                   yang_keys='constituent-base-element-id',
                                                                   extensions=None), is_container='list',
                                                 yang_name="constituent-cpd-id", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    virtual_link_profile_id = __builtin__.property(_get_virtual_link_profile_id, _set_virtual_link_profile_id)
    constituent_cpd_id = __builtin__.property(_get_constituent_cpd_id, _set_constituent_cpd_id)

    _pyangbind_elements = OrderedDict(
        [('virtual_link_profile_id', virtual_link_profile_id), ('constituent_cpd_id', constituent_cpd_id), ])


class yc_ns_profile_etsi_nfv_nsd__nsd_nsd_df_ns_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/ns-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies a NS Profile supported by this NS DF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__nsd_id', '__ns_df_id', '__instantiation_level_id',
                 '__min_number_of_instances', '__max_number_of_instances', '__affinity_or_anti_affinity_group_id',
                 '__virtual_link_connectivity',)

    _yang_name = 'ns-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)
        self.__ns_df_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-df-id", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='leafref', is_config=True)
        self.__instantiation_level_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="instantiation-level-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__affinity_or_anti_affinity_group_id = YANGDynClass(base=YANGListType("id",
                                                                                   yc_affinity_or_anti_affinity_group_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_affinity_or_anti_affinity_group_id,
                                                                                   yang_name="affinity-or-anti-affinity-group-id",
                                                                                   parent=self, is_container='list',
                                                                                   user_ordered=False,
                                                                                   path_helper=self._path_helper,
                                                                                   yang_keys='id', extensions=None),
                                                                 is_container='list',
                                                                 yang_name="affinity-or-anti-affinity-group-id",
                                                                 parent=self, path_helper=self._path_helper,
                                                                 extmethods=self._extmethods, register_paths=True,
                                                                 extensions=None,
                                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                 defining_module='etsi-nfv-nsd', yang_type='list',
                                                                 is_config=True)
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'ns-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/ns_profile/id (string)

    YANG Description: Identifies an NS profile.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/ns_profile/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies an NS profile.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_nsd_id(self):
        """
    Getter method for nsd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/nsd_id (leafref)

    YANG Description: Identifies the NSD applicable to NS instantiated
according to this profile.
    """
        return self.__nsd_id

    def _set_nsd_id(self, v, load=False):
        """
    Setter method for nsd_id, mapped from YANG variable /nsd/nsd/df/ns_profile/nsd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd_id() directly.

    YANG Description: Identifies the NSD applicable to NS instantiated
according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nsd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nsd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nsd_id(self):
        self.__nsd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nsd-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                     yang_type='leafref', is_config=True)

    def _get_ns_df_id(self):
        """
    Getter method for ns_df_id, mapped from YANG variable /nsd/nsd/df/ns_profile/ns_df_id (leafref)

    YANG Description: Identifies the applicable network service DF within
the scope of the NSD.
    """
        return self.__ns_df_id

    def _set_ns_df_id(self, v, load=False):
        """
    Setter method for ns_df_id, mapped from YANG variable /nsd/nsd/df/ns_profile/ns_df_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_df_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_df_id() directly.

    YANG Description: Identifies the applicable network service DF within
the scope of the NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="ns-df-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_df_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-df-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__ns_df_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_df_id(self):
        self.__ns_df_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="ns-df-id", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='leafref', is_config=True)

    def _get_instantiation_level_id(self):
        """
    Getter method for instantiation_level_id, mapped from YANG variable /nsd/nsd/df/ns_profile/instantiation_level_id (leafref)

    YANG Description: Identifies the NS level within the referenced NS DF to
be used in the context of the parent NS instantiation.
If not present, the default NS instantiation level as
declared in the referenced NSD shall be used.
    """
        return self.__instantiation_level_id

    def _set_instantiation_level_id(self, v, load=False):
        """
    Setter method for instantiation_level_id, mapped from YANG variable /nsd/nsd/df/ns_profile/instantiation_level_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiation_level_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiation_level_id() directly.

    YANG Description: Identifies the NS level within the referenced NS DF to
be used in the context of the parent NS instantiation.
If not present, the default NS instantiation level as
declared in the referenced NSD shall be used.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="instantiation-level-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiation_level_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="instantiation-level-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__instantiation_level_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiation_level_id(self):
        self.__instantiation_level_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="instantiation-level-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                     is_config=True)

    def _get_min_number_of_instances(self):
        """
    Getter method for min_number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_profile/min_number_of_instances (uint16)

    YANG Description: Minimum number of nested NS instances based on the
referenced NSD that is permitted to exist for this
NsProfile.
    """
        return self.__min_number_of_instances

    def _set_min_number_of_instances(self, v, load=False):
        """
    Setter method for min_number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_profile/min_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_number_of_instances() directly.

    YANG Description: Minimum number of nested NS instances based on the
referenced NSD that is permitted to exist for this
NsProfile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__min_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_number_of_instances(self):
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_max_number_of_instances(self):
        """
    Getter method for max_number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_profile/max_number_of_instances (uint16)

    YANG Description: Maximum number of nested NS instances based on the
referenced NSD that is permitted to exist for this
NsProfile.
    """
        return self.__max_number_of_instances

    def _set_max_number_of_instances(self, v, load=False):
        """
    Setter method for max_number_of_instances, mapped from YANG variable /nsd/nsd/df/ns_profile/max_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_number_of_instances() directly.

    YANG Description: Maximum number of nested NS instances based on the
referenced NSD that is permitted to exist for this
NsProfile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__max_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_number_of_instances(self):
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_affinity_or_anti_affinity_group_id(self):
        """
    Getter method for affinity_or_anti_affinity_group_id, mapped from YANG variable /nsd/nsd/df/ns_profile/affinity_or_anti_affinity_group_id (list)

    YANG Description: Identifies an affinity or anti-affinity group the NSs
created according to this NsProfile belongs to.
    """
        return self.__affinity_or_anti_affinity_group_id

    def _set_affinity_or_anti_affinity_group_id(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group_id, mapped from YANG variable /nsd/nsd/df/ns_profile/affinity_or_anti_affinity_group_id (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group_id() directly.

    YANG Description: Identifies an affinity or anti-affinity group the NSs
created according to this NsProfile belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_affinity_or_anti_affinity_group_id,
                                                  yang_name="affinity-or-anti-affinity-group-id", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group_id must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_affinity_or_anti_affinity_group_id, yang_name="affinity-or-anti-affinity-group-id", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group_id(self):
        self.__affinity_or_anti_affinity_group_id = YANGDynClass(base=YANGListType("id",
                                                                                   yc_affinity_or_anti_affinity_group_id_etsi_nfv_nsd__nsd_nsd_df_ns_profile_affinity_or_anti_affinity_group_id,
                                                                                   yang_name="affinity-or-anti-affinity-group-id",
                                                                                   parent=self, is_container='list',
                                                                                   user_ordered=False,
                                                                                   path_helper=self._path_helper,
                                                                                   yang_keys='id', extensions=None),
                                                                 is_container='list',
                                                                 yang_name="affinity-or-anti-affinity-group-id",
                                                                 parent=self, path_helper=self._path_helper,
                                                                 extmethods=self._extmethods, register_paths=True,
                                                                 extensions=None,
                                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                                 defining_module='etsi-nfv-nsd', yang_type='list',
                                                                 is_config=True)

    def _get_virtual_link_connectivity(self):
        """
    Getter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity (list)
    """
        return self.__virtual_link_connectivity

    def _set_virtual_link_connectivity(self, v, load=False):
        """
    Setter method for virtual_link_connectivity, mapped from YANG variable /nsd/nsd/df/ns_profile/virtual_link_connectivity (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_connectivity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_connectivity() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("virtual_link_profile_id",
                                                  yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity,
                                                  yang_name="virtual-link-connectivity", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='virtual-link-profile-id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_connectivity must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("virtual_link_profile_id",yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity, yang_name="virtual-link-connectivity", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='virtual-link-profile-id', extensions=None), is_container='list', yang_name="virtual-link-connectivity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_connectivity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_connectivity(self):
        self.__virtual_link_connectivity = YANGDynClass(base=YANGListType("virtual_link_profile_id",
                                                                          yc_virtual_link_connectivity_etsi_nfv_nsd__nsd_nsd_df_ns_profile_virtual_link_connectivity,
                                                                          yang_name="virtual-link-connectivity",
                                                                          parent=self, is_container='list',
                                                                          user_ordered=False,
                                                                          path_helper=self._path_helper,
                                                                          yang_keys='virtual-link-profile-id',
                                                                          extensions=None), is_container='list',
                                                        yang_name="virtual-link-connectivity", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True, extensions=None,
                                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                        defining_module='etsi-nfv-nsd', yang_type='list',
                                                        is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    nsd_id = __builtin__.property(_get_nsd_id, _set_nsd_id)
    ns_df_id = __builtin__.property(_get_ns_df_id, _set_ns_df_id)
    instantiation_level_id = __builtin__.property(_get_instantiation_level_id, _set_instantiation_level_id)
    min_number_of_instances = __builtin__.property(_get_min_number_of_instances, _set_min_number_of_instances)
    max_number_of_instances = __builtin__.property(_get_max_number_of_instances, _set_max_number_of_instances)
    affinity_or_anti_affinity_group_id = __builtin__.property(_get_affinity_or_anti_affinity_group_id,
                                                              _set_affinity_or_anti_affinity_group_id)
    virtual_link_connectivity = __builtin__.property(_get_virtual_link_connectivity, _set_virtual_link_connectivity)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('nsd_id', nsd_id), ('ns_df_id', ns_df_id), ('instantiation_level_id', instantiation_level_id),
         ('min_number_of_instances', min_number_of_instances), ('max_number_of_instances', max_number_of_instances),
         ('affinity_or_anti_affinity_group_id', affinity_or_anti_affinity_group_id),
         ('virtual_link_connectivity', virtual_link_connectivity), ])


class yc_dependencies_etsi_nfv_nsd__nsd_nsd_df_dependencies(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/dependencies. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the order in which instances of the VNFs and/or
nested NSs have to be created.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__primary_vnf_profile', '__primary_ns_profile',
        '__secondary_vnf_profile',
        '__secondary_ns_profile',)

    _yang_name = 'dependencies'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__primary_vnf_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-vnf-profile",
                                                  parent=self, choice=('primary-id', 'primary-vnf-profile'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__primary_ns_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-ns-profile",
                                                 parent=self, choice=('primary-id', 'primary-ns-profile'),
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__secondary_vnf_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-vnf-profile",
                                                    parent=self, choice=('secondary-id', 'secondary-vnf-profile'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__secondary_ns_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-ns-profile",
                                                   parent=self, choice=('secondary-id', 'secondary-ns-profile'),
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'dependencies']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/dependencies/id (string)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/dependencies/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_primary_vnf_profile(self):
        """
    Getter method for primary_vnf_profile, mapped from YANG variable /nsd/nsd/df/dependencies/primary_vnf_profile (leafref)
    """
        return self.__primary_vnf_profile

    def _set_primary_vnf_profile(self, v, load=False):
        """
    Setter method for primary_vnf_profile, mapped from YANG variable /nsd/nsd/df/dependencies/primary_vnf_profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_vnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_vnf_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="primary-vnf-profile", parent=self,
                             choice=('primary-id', 'primary-vnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """primary_vnf_profile must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-vnf-profile", parent=self, choice=('primary-id', 'primary-vnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__primary_vnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_primary_vnf_profile(self):
        self.__primary_vnf_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-vnf-profile",
                                                  parent=self, choice=('primary-id', 'primary-vnf-profile'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                  defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_primary_ns_profile(self):
        """
    Getter method for primary_ns_profile, mapped from YANG variable /nsd/nsd/df/dependencies/primary_ns_profile (leafref)
    """
        return self.__primary_ns_profile

    def _set_primary_ns_profile(self, v, load=False):
        """
    Setter method for primary_ns_profile, mapped from YANG variable /nsd/nsd/df/dependencies/primary_ns_profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_primary_ns_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_primary_ns_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="primary-ns-profile", parent=self,
                             choice=('primary-id', 'primary-ns-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """primary_ns_profile must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-ns-profile", parent=self, choice=('primary-id', 'primary-ns-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__primary_ns_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_primary_ns_profile(self):
        self.__primary_ns_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="primary-ns-profile",
                                                 parent=self, choice=('primary-id', 'primary-ns-profile'),
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_secondary_vnf_profile(self):
        """
    Getter method for secondary_vnf_profile, mapped from YANG variable /nsd/nsd/df/dependencies/secondary_vnf_profile (leafref)
    """
        return self.__secondary_vnf_profile

    def _set_secondary_vnf_profile(self, v, load=False):
        """
    Setter method for secondary_vnf_profile, mapped from YANG variable /nsd/nsd/df/dependencies/secondary_vnf_profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_vnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_vnf_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="secondary-vnf-profile", parent=self,
                             choice=('secondary-id', 'secondary-vnf-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """secondary_vnf_profile must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-vnf-profile", parent=self, choice=('secondary-id', 'secondary-vnf-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__secondary_vnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_secondary_vnf_profile(self):
        self.__secondary_vnf_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-vnf-profile",
                                                    parent=self, choice=('secondary-id', 'secondary-vnf-profile'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_secondary_ns_profile(self):
        """
    Getter method for secondary_ns_profile, mapped from YANG variable /nsd/nsd/df/dependencies/secondary_ns_profile (leafref)
    """
        return self.__secondary_ns_profile

    def _set_secondary_ns_profile(self, v, load=False):
        """
    Setter method for secondary_ns_profile, mapped from YANG variable /nsd/nsd/df/dependencies/secondary_ns_profile (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_secondary_ns_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_secondary_ns_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="secondary-ns-profile", parent=self,
                             choice=('secondary-id', 'secondary-ns-profile'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """secondary_ns_profile must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-ns-profile", parent=self, choice=('secondary-id', 'secondary-ns-profile'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__secondary_ns_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_secondary_ns_profile(self):
        self.__secondary_ns_profile = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="secondary-ns-profile",
                                                   parent=self, choice=('secondary-id', 'secondary-ns-profile'),
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    primary_vnf_profile = __builtin__.property(_get_primary_vnf_profile, _set_primary_vnf_profile)
    primary_ns_profile = __builtin__.property(_get_primary_ns_profile, _set_primary_ns_profile)
    secondary_vnf_profile = __builtin__.property(_get_secondary_vnf_profile, _set_secondary_vnf_profile)
    secondary_ns_profile = __builtin__.property(_get_secondary_ns_profile, _set_secondary_ns_profile)

    __choices__ = {
        'primary-id': {'primary-vnf-profile': ['primary_vnf_profile'], 'primary-ns-profile': ['primary_ns_profile']},
        'secondary-id': {'secondary-vnf-profile': ['secondary_vnf_profile'],
                         'secondary-ns-profile': ['secondary_ns_profile']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('primary_vnf_profile', primary_vnf_profile), ('primary_ns_profile', primary_ns_profile),
         ('secondary_vnf_profile', secondary_vnf_profile), ('secondary_ns_profile', secondary_ns_profile), ])


class yc_vnf_indicator_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info_vnf_indicator_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/monitored-info/vnf-indicator-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Uniquely identifies this VNF Indicator information
element.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnfd_id', '__vnf_indicator',)

    _yang_name = 'vnf-indicator-info'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__vnf_indicator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-indicator", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'monitored-info', 'vnf-indicator-info']

    def _get_vnfd_id(self):
        """
    Getter method for vnfd_id, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info/vnfd_id (leafref)

    YANG Description: Identifies a VNFD.
    """
        return self.__vnfd_id

    def _set_vnfd_id(self, v, load=False):
        """
    Setter method for vnfd_id, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info/vnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id() directly.

    YANG Description: Identifies a VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd_id(self):
        self.__vnfd_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnfd-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_vnf_indicator(self):
        """
    Getter method for vnf_indicator, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info/vnf_indicator (leafref)

    YANG Description: Identifies a VNF indicator within the VNFD.
    """
        return self.__vnf_indicator

    def _set_vnf_indicator(self, v, load=False):
        """
    Setter method for vnf_indicator, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info/vnf_indicator (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_indicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_indicator() directly.

    YANG Description: Identifies a VNF indicator within the VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-indicator", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_indicator must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-indicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_indicator = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_indicator(self):
        self.__vnf_indicator = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-indicator", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                            defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    vnfd_id = __builtin__.property(_get_vnfd_id, _set_vnfd_id)
    vnf_indicator = __builtin__.property(_get_vnf_indicator, _set_vnf_indicator)

    _pyangbind_elements = OrderedDict([('vnfd_id', vnfd_id), ('vnf_indicator', vnf_indicator), ])


class yc_monitoring_parameter_etsi_nfv_nsd__nsd_nsd_df_monitored_info_monitoring_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/monitored-info/monitoring-parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                 yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="collection-period",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'monitored-info', 'monitoring-parameter']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/id (string)

    YANG Description: Unique identifier of this monitoring parameter
information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this monitoring parameter
information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                 yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/performance_metric (string)

    YANG Description: Defines the virtualised resource-related performance
metric.
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Defines the virtualised resource-related performance
metric.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/collection_period (string)

    YANG Description: An attribute that describes the periodicity at
which to collect the performance information.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter/collection_period (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the periodicity at
which to collect the performance information.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="collection-period", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="collection-period",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_monitored_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df/monitored-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__vnf_indicator_info', '__monitoring_parameter',)

    _yang_name = 'monitored-info'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__vnf_indicator_info = YANGDynClass(
            base=yc_vnf_indicator_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info_vnf_indicator_info,
            is_container='container', yang_name="vnf-indicator-info", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__monitoring_parameter = YANGDynClass(
            base=yc_monitoring_parameter_etsi_nfv_nsd__nsd_nsd_df_monitored_info_monitoring_parameter,
            is_container='container', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df', 'monitored-info']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/monitored_info/id (string)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/monitored_info/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_vnf_indicator_info(self):
        """
    Getter method for vnf_indicator_info, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info (container)

    YANG Description: Uniquely identifies this VNF Indicator information
element.
    """
        return self.__vnf_indicator_info

    def _set_vnf_indicator_info(self, v, load=False):
        """
    Setter method for vnf_indicator_info, mapped from YANG variable /nsd/nsd/df/monitored_info/vnf_indicator_info (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_indicator_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_indicator_info() directly.

    YANG Description: Uniquely identifies this VNF Indicator information
element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_vnf_indicator_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info_vnf_indicator_info,
                             is_container='container', yang_name="vnf-indicator-info", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_indicator_info must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vnf_indicator_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info_vnf_indicator_info, is_container='container', yang_name="vnf-indicator-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__vnf_indicator_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_indicator_info(self):
        self.__vnf_indicator_info = YANGDynClass(
            base=yc_vnf_indicator_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info_vnf_indicator_info,
            is_container='container', yang_name="vnf-indicator-info", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_monitoring_parameter(self):
        """
    Getter method for monitoring_parameter, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter (container)
    """
        return self.__monitoring_parameter

    def _set_monitoring_parameter(self, v, load=False):
        """
    Setter method for monitoring_parameter, mapped from YANG variable /nsd/nsd/df/monitored_info/monitoring_parameter (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameter() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_monitoring_parameter_etsi_nfv_nsd__nsd_nsd_df_monitored_info_monitoring_parameter,
                             is_container='container', yang_name="monitoring-parameter", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameter must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_monitoring_parameter_etsi_nfv_nsd__nsd_nsd_df_monitored_info_monitoring_parameter, is_container='container', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__monitoring_parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameter(self):
        self.__monitoring_parameter = YANGDynClass(
            base=yc_monitoring_parameter_etsi_nfv_nsd__nsd_nsd_df_monitored_info_monitoring_parameter,
            is_container='container', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vnf_indicator_info = __builtin__.property(_get_vnf_indicator_info, _set_vnf_indicator_info)
    monitoring_parameter = __builtin__.property(_get_monitoring_parameter, _set_monitoring_parameter)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('vnf_indicator_info', vnf_indicator_info), ('monitoring_parameter', monitoring_parameter), ])


class yc_df_etsi_nfv_nsd__nsd_nsd_df(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/df. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies a DF within the scope of an NSD.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__flavour_key', '__vnf_profile', '__pnf_profile',
        '__virtual_link_profile',
        '__scaling_aspect', '__affinity_or_anti_affinity_group', '__ns_instantiation_level',
        '__default_instantiation_level', '__ns_profile', '__dependencies', '__monitored_info',)

    _yang_name = 'df'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__flavour_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-key", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)
        self.__vnf_profile = YANGDynClass(
            base=YANGListType("id", yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_df_vnf_profile, yang_name="vnf-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vnf-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__pnf_profile = YANGDynClass(
            base=YANGListType("id", yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_df_pnf_profile, yang_name="pnf-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="pnf-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id", yc_virtual_link_profile_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_nsd_df_scaling_aspect,
                              yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)
        self.__ns_instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_ns_instantiation_level_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level,
                              yang_name="ns-instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="ns-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)
        self.__ns_profile = YANGDynClass(
            base=YANGListType("id", yc_ns_profile_etsi_nfv_nsd__nsd_nsd_df_ns_profile, yang_name="ns-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="ns-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__dependencies = YANGDynClass(
            base=YANGListType("id", yc_dependencies_etsi_nfv_nsd__nsd_nsd_df_dependencies, yang_name="dependencies",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="dependencies",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__monitored_info = YANGDynClass(
            base=YANGListType("id", yc_monitored_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info,
                              yang_name="monitored-info", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitored-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'df']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/df/id (string)

    YANG Description: Identifies this NsDf information element. It identifies
a NS DF within the NSD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/df/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies this NsDf information element. It identifies
a NS DF within the NSD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_flavour_key(self):
        """
    Getter method for flavour_key, mapped from YANG variable /nsd/nsd/df/flavour_key (leafref)

    YANG Description: Assurance parameter against which this flavour is being
described.

The key can be a combination of multiple assurance
parameters with a logical relationship between them.
The parameters should be present as a monitoredInfo
attribute in the NSD.
    """
        return self.__flavour_key

    def _set_flavour_key(self, v, load=False):
        """
    Setter method for flavour_key, mapped from YANG variable /nsd/nsd/df/flavour_key (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour_key() directly.

    YANG Description: Assurance parameter against which this flavour is being
described.

The key can be a combination of multiple assurance
parameters with a logical relationship between them.
The parameters should be present as a monitoredInfo
attribute in the NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="flavour-key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour_key must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__flavour_key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour_key(self):
        self.__flavour_key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour-key", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)

    def _get_vnf_profile(self):
        """
    Getter method for vnf_profile, mapped from YANG variable /nsd/nsd/df/vnf_profile (list)

    YANG Description: VNF profile to be used for the NS flavour.
    """
        return self.__vnf_profile

    def _set_vnf_profile(self, v, load=False):
        """
    Setter method for vnf_profile, mapped from YANG variable /nsd/nsd/df/vnf_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_profile() directly.

    YANG Description: VNF profile to be used for the NS flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_df_vnf_profile,
                                                  yang_name="vnf-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vnf-profile",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_df_vnf_profile, yang_name="vnf-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnf-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_profile(self):
        self.__vnf_profile = YANGDynClass(
            base=YANGListType("id", yc_vnf_profile_etsi_nfv_nsd__nsd_nsd_df_vnf_profile, yang_name="vnf-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vnf-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_pnf_profile(self):
        """
    Getter method for pnf_profile, mapped from YANG variable /nsd/nsd/df/pnf_profile (list)
    """
        return self.__pnf_profile

    def _set_pnf_profile(self, v, load=False):
        """
    Setter method for pnf_profile, mapped from YANG variable /nsd/nsd/df/pnf_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnf_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnf_profile() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_df_pnf_profile,
                                                  yang_name="pnf-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="pnf-profile",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnf_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_df_pnf_profile, yang_name="pnf-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="pnf-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__pnf_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnf_profile(self):
        self.__pnf_profile = YANGDynClass(
            base=YANGListType("id", yc_pnf_profile_etsi_nfv_nsd__nsd_nsd_df_pnf_profile, yang_name="pnf-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="pnf-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_virtual_link_profile(self):
        """
    Getter method for virtual_link_profile, mapped from YANG variable /nsd/nsd/df/virtual_link_profile (list)

    YANG Description: VL profile to be used for the NS flavour.
    """
        return self.__virtual_link_profile

    def _set_virtual_link_profile(self, v, load=False):
        """
    Setter method for virtual_link_profile, mapped from YANG variable /nsd/nsd/df/virtual_link_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile() directly.

    YANG Description: VL profile to be used for the NS flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_virtual_link_profile_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile,
                                                  yang_name="virtual-link-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_link_profile_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile, yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile(self):
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id", yc_virtual_link_profile_etsi_nfv_nsd__nsd_nsd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_scaling_aspect(self):
        """
    Getter method for scaling_aspect, mapped from YANG variable /nsd/nsd/df/scaling_aspect (list)

    YANG Description: The scaling aspects supported by this DF of the NS.
    """
        return self.__scaling_aspect

    def _set_scaling_aspect(self, v, load=False):
        """
    Setter method for scaling_aspect, mapped from YANG variable /nsd/nsd/df/scaling_aspect (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_aspect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_aspect() directly.

    YANG Description: The scaling aspects supported by this DF of the NS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_nsd_df_scaling_aspect,
                                                  yang_name="scaling-aspect", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="scaling-aspect",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_aspect must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_scaling_aspect_etsi_nfv_nsd__nsd_nsd_df_scaling_aspect, yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__scaling_aspect = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_aspect(self):
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_nsd__nsd_nsd_df_scaling_aspect,
                              yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group (list)

    YANG Description: Specifies affinity or anti-affinity relationship
applicable between the VNF instances created using
different VNFDs, the Virtual Link instances created
using different NsVirtualLinkDescs or the nested NS
instances created using different NSDs in the same
affinity or anti-affinity group.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /nsd/nsd/df/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Specifies affinity or anti-affinity relationship
applicable between the VNF instances created using
different VNFDs, the Virtual Link instances created
using different NsVirtualLinkDescs or the nested NS
instances created using different NSDs in the same
affinity or anti-affinity group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_nsd__nsd_nsd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                              defining_module='etsi-nfv-nsd', yang_type='list',
                                                              is_config=True)

    def _get_ns_instantiation_level(self):
        """
    Getter method for ns_instantiation_level, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level (list)

    YANG Description: Describes the details of an NS level.
    """
        return self.__ns_instantiation_level

    def _set_ns_instantiation_level(self, v, load=False):
        """
    Setter method for ns_instantiation_level, mapped from YANG variable /nsd/nsd/df/ns_instantiation_level (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_instantiation_level() directly.

    YANG Description: Describes the details of an NS level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_ns_instantiation_level_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level,
                                                  yang_name="ns-instantiation-level", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="ns-instantiation-level", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_instantiation_level must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_ns_instantiation_level_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level, yang_name="ns-instantiation-level", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ns-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__ns_instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_instantiation_level(self):
        self.__ns_instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_ns_instantiation_level_etsi_nfv_nsd__nsd_nsd_df_ns_instantiation_level,
                              yang_name="ns-instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="ns-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_default_instantiation_level(self):
        """
    Getter method for default_instantiation_level, mapped from YANG variable /nsd/nsd/df/default_instantiation_level (leafref)

    YANG Description: Identifies the NS level which represents the default NS
instantiation level for this DF. It shall be present if
there are multiple 'nsIinstantiationLevel' entries.
    """
        return self.__default_instantiation_level

    def _set_default_instantiation_level(self, v, load=False):
        """
    Setter method for default_instantiation_level, mapped from YANG variable /nsd/nsd/df/default_instantiation_level (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_instantiation_level() directly.

    YANG Description: Identifies the NS level which represents the default NS
instantiation level for this DF. It shall be present if
there are multiple 'nsIinstantiationLevel' entries.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_instantiation_level must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__default_instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_instantiation_level(self):
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                          defining_module='etsi-nfv-nsd', yang_type='leafref',
                                                          is_config=True)

    def _get_ns_profile(self):
        """
    Getter method for ns_profile, mapped from YANG variable /nsd/nsd/df/ns_profile (list)

    YANG Description: Specifies a NS Profile supported by this NS DF.
    """
        return self.__ns_profile

    def _set_ns_profile(self, v, load=False):
        """
    Setter method for ns_profile, mapped from YANG variable /nsd/nsd/df/ns_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_profile() directly.

    YANG Description: Specifies a NS Profile supported by this NS DF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_ns_profile_etsi_nfv_nsd__nsd_nsd_df_ns_profile,
                                                  yang_name="ns-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="ns-profile",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_ns_profile_etsi_nfv_nsd__nsd_nsd_df_ns_profile, yang_name="ns-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ns-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__ns_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_profile(self):
        self.__ns_profile = YANGDynClass(
            base=YANGListType("id", yc_ns_profile_etsi_nfv_nsd__nsd_nsd_df_ns_profile, yang_name="ns-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="ns-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_dependencies(self):
        """
    Getter method for dependencies, mapped from YANG variable /nsd/nsd/df/dependencies (list)

    YANG Description: Specifies the order in which instances of the VNFs and/or
nested NSs have to be created.
    """
        return self.__dependencies

    def _set_dependencies(self, v, load=False):
        """
    Setter method for dependencies, mapped from YANG variable /nsd/nsd/df/dependencies (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dependencies is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dependencies() directly.

    YANG Description: Specifies the order in which instances of the VNFs and/or
nested NSs have to be created.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_dependencies_etsi_nfv_nsd__nsd_nsd_df_dependencies,
                                                  yang_name="dependencies", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="dependencies",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """dependencies must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_dependencies_etsi_nfv_nsd__nsd_nsd_df_dependencies, yang_name="dependencies", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="dependencies", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__dependencies = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_dependencies(self):
        self.__dependencies = YANGDynClass(
            base=YANGListType("id", yc_dependencies_etsi_nfv_nsd__nsd_nsd_df_dependencies, yang_name="dependencies",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="dependencies",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_monitored_info(self):
        """
    Getter method for monitored_info, mapped from YANG variable /nsd/nsd/df/monitored_info (list)
    """
        return self.__monitored_info

    def _set_monitored_info(self, v, load=False):
        """
    Setter method for monitored_info, mapped from YANG variable /nsd/nsd/df/monitored_info (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitored_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitored_info() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_monitored_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info,
                                                  yang_name="monitored-info", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="monitored-info",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitored_info must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitored_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info, yang_name="monitored-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitored-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__monitored_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitored_info(self):
        self.__monitored_info = YANGDynClass(
            base=YANGListType("id", yc_monitored_info_etsi_nfv_nsd__nsd_nsd_df_monitored_info,
                              yang_name="monitored-info", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitored-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    flavour_key = __builtin__.property(_get_flavour_key, _set_flavour_key)
    vnf_profile = __builtin__.property(_get_vnf_profile, _set_vnf_profile)
    pnf_profile = __builtin__.property(_get_pnf_profile, _set_pnf_profile)
    virtual_link_profile = __builtin__.property(_get_virtual_link_profile, _set_virtual_link_profile)
    scaling_aspect = __builtin__.property(_get_scaling_aspect, _set_scaling_aspect)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    ns_instantiation_level = __builtin__.property(_get_ns_instantiation_level, _set_ns_instantiation_level)
    default_instantiation_level = __builtin__.property(_get_default_instantiation_level,
                                                       _set_default_instantiation_level)
    ns_profile = __builtin__.property(_get_ns_profile, _set_ns_profile)
    dependencies = __builtin__.property(_get_dependencies, _set_dependencies)
    monitored_info = __builtin__.property(_get_monitored_info, _set_monitored_info)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('flavour_key', flavour_key), ('vnf_profile', vnf_profile), ('pnf_profile', pnf_profile),
         ('virtual_link_profile', virtual_link_profile), ('scaling_aspect', scaling_aspect),
         ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
         ('ns_instantiation_level', ns_instantiation_level),
         ('default_instantiation_level', default_instantiation_level), ('ns_profile', ns_profile),
         ('dependencies', dependencies), ('monitored_info', monitored_info), ])


class yc_script_etsi_nfv_nsd__nsd_nsd_ns_configuration_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__script_type',)

    _yang_name = 'script'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'rift': {}}, ), is_leaf=True,
                                          yang_name="script-type", parent=self, choice=('config-method', 'script'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                          defining_module='ns-configuration', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'script']

    def _get_script_type(self):
        """
    Getter method for script_type, mapped from YANG variable /nsd/nsd/ns_configuration/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        return self.__script_type

    def _set_script_type(self, v, load=False):
        """
    Setter method for script_type, mapped from YANG variable /nsd/nsd/ns_configuration/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'rift': {}}, ), is_leaf=True,
                             yang_name="script-type", parent=self, choice=('config-method', 'script'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_type must be of a type compatible with enumeration""",
                'defined-type': "ns-configuration:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=('config-method', 'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='enumeration', is_config=True)""",
            })

        self.__script_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_type(self):
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'rift': {}}, ), is_leaf=True,
                                          yang_name="script-type", parent=self, choice=('config-method', 'script'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                          defining_module='ns-configuration', yang_type='enumeration', is_config=True)

    script_type = __builtin__.property(_get_script_type, _set_script_type)

    __choices__ = {'config-method': {'script': ['script_type']}}
    _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_juju(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__charm', '__proxy', '__cloud',)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='boolean', is_config=True)
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /nsd/nsd/ns_configuration/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self, v, load=False):
        """
    Setter method for charm, mapped from YANG variable /nsd/nsd/ns_configuration/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__charm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /nsd/nsd/ns_configuration/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self, v, load=False):
        """
    Setter method for proxy, mapped from YANG variable /nsd/nsd/ns_configuration/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='boolean', is_config=True)""",
            })

        self.__proxy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='boolean', is_config=True)

    def _get_cloud(self):
        """
    Getter method for cloud, mapped from YANG variable /nsd/nsd/ns_configuration/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        return self.__cloud

    def _set_cloud(self, v, load=False):
        """
    Setter method for cloud, mapped from YANG variable /nsd/nsd/ns_configuration/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'lxd': {}, 'k8s': {}}, ),
                             default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud must be of a type compatible with enumeration""",
                'defined-type': "ns-configuration:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lxd': {}, 'k8s': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='enumeration', is_config=True)""",
            })

        self.__cloud = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud(self):
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='enumeration', is_config=True)

    charm = __builtin__.property(_get_charm, _set_charm)
    proxy = __builtin__.property(_get_proxy, _set_proxy)
    cloud = __builtin__.property(_get_cloud, _set_cloud)

    __choices__ = {'config-method': {'juju': ['charm', 'proxy', 'cloud']}}
    _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list_juju(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__charm', '__proxy', '__cloud',)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('execution-environment-model', 'juju'),
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='boolean', is_config=True)
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'execution-environment-list', 'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self, v, load=False):
        """
    Setter method for charm, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__charm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self, v, load=False):
        """
    Setter method for proxy, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='boolean', is_config=True)""",
            })

        self.__proxy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('execution-environment-model', 'juju'),
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='boolean', is_config=True)

    def _get_cloud(self):
        """
    Getter method for cloud, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        return self.__cloud

    def _set_cloud(self, v, load=False):
        """
    Setter method for cloud, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'lxd': {}, 'k8s': {}}, ),
                             default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud must be of a type compatible with enumeration""",
                'defined-type': "ns-configuration:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lxd': {}, 'k8s': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='enumeration', is_config=True)""",
            })

        self.__cloud = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud(self):
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='enumeration', is_config=True)

    charm = __builtin__.property(_get_charm, _set_charm)
    proxy = __builtin__.property(_get_proxy, _set_proxy)
    cloud = __builtin__.property(_get_cloud, _set_cloud)

    __choices__ = {'execution-environment-model': {'juju': ['charm', 'proxy', 'cloud']}}
    _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__juju', '__helm_chart', '__helm_version', '__metric_service',
                 '__external_connection_point_ref',)

    _yang_name = 'execution-environment-list'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                 namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                 defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__juju = YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list_juju,
                                   is_container='container', yang_name="juju", parent=self,
                                   choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, extensions=None,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='container', is_config=True)
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('execution-environment-model', 'helm-chart'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                         defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='enumeration', is_config=True)
        self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                                             choice=('config-method', 'execution-environment-list'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True,
                                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                             defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            choice=('config-method', 'execution-environment-list'),
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                            defining_module='ns-configuration', yang_type='string',
                                                            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'execution-environment-list']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                 namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                 defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju (container)
    """
        return self.__juju

    def _set_juju(self, v, load=False):
        """
    Setter method for juju, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list_juju,
                             is_container='container', yang_name="juju", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='container', is_config=True)""",
            })

        self.__juju = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list_juju,
                                   is_container='container', yang_name="juju", parent=self,
                                   choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, extensions=None,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='container', is_config=True)

    def _get_helm_chart(self):
        """
    Getter method for helm_chart, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
        return self.__helm_chart

    def _set_helm_chart(self, v, load=False):
        """
    Setter method for helm_chart, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                             choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_chart must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__helm_chart = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_chart(self):
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('execution-environment-model', 'helm-chart'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                         defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_helm_version(self):
        """
    Getter method for helm_version, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/helm_version (enumeration)

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        return self.__helm_version

    def _set_helm_version(self, v, load=False):
        """
    Setter method for helm_version, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/helm_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_version() directly.

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'v2': {}, 'v3': {}}, ),
                             default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self,
                             choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_version must be of a type compatible with enumeration""",
                'defined-type': "ns-configuration:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'v2': {}, 'v3': {}},), default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='enumeration', is_config=True)""",
            })

        self.__helm_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_version(self):
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='enumeration', is_config=True)

    def _get_metric_service(self):
        """
    Getter method for metric_service, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
        return self.__metric_service

    def _set_metric_service(self, v, load=False):
        """
    Setter method for metric_service, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metric_service must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__metric_service = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metric_service(self):
        self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                                             choice=('config-method', 'execution-environment-list'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True,
                                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                             defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_external_connection_point_ref(self):
        """
    Getter method for external_connection_point_ref, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/external_connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
        return self.__external_connection_point_ref

    def _set_external_connection_point_ref(self, v, load=False):
        """
    Setter method for external_connection_point_ref, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list/external_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref",
                             parent=self, choice=('config-method', 'execution-environment-list'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """external_connection_point_ref must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__external_connection_point_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_external_connection_point_ref(self):
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            choice=('config-method', 'execution-environment-list'),
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                            defining_module='ns-configuration', yang_type='string',
                                                            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    juju = __builtin__.property(_get_juju, _set_juju)
    helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
    helm_version = __builtin__.property(_get_helm_version, _set_helm_version)
    metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
    external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref,
                                                         _set_external_connection_point_ref)

    __choices__ = {
        'config-method': {'execution-environment-list': ['id', 'metric_service', 'external_connection_point_ref']},
        'execution-environment-model': {'juju': ['juju'], 'helm-chart': ['helm_chart', 'helm_version']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('juju', juju), ('helm_chart', helm_chart), ('helm_version', helm_version),
         ('metric_service', metric_service), ('external_connection_point_ref', external_connection_point_ref), ])


class yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__data_type', '__mandatory', '__default_value', '__parameter_pool',
        '__read_only', '__hidden',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='boolean', is_config=True)
        self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                            defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True,
                                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                             defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='boolean', is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                     defining_module='ns-configuration', yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'config-primitive', 'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self, v, load=False):
        """
    Setter method for mandatory, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='boolean', is_config=True)""",
            })

        self.__mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='boolean', is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self, v, load=False):
        """
    Setter method for default_value, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__default_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True,
                                            namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                            defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self, v, load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__parameter_pool = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True,
                                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                             defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self, v, load=False):
        """
    Setter method for read_only, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='boolean', is_config=True)""",
            })

        self.__read_only = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='boolean', is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self, v, load=False):
        """
    Setter method for hidden, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='boolean', is_config=True)""",
            })

        self.__hidden = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                     defining_module='ns-configuration', yang_type='boolean', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
    default_value = __builtin__.property(_get_default_value, _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only, _set_read_only)
    hidden = __builtin__.property(_get_hidden, _set_hidden)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value),
         ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__execution_environment_ref', '__execution_environment_primitive',
        '__parameter', '__user_defined_script',)

    _yang_name = 'config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)
        self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True,
                                                              yang_name="execution-environment-primitive", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                              defining_module='ns-configuration', yang_type='string',
                                                              is_config=True)
        self.__parameter = YANGDynClass(
            base=YANGListType("name", yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive_parameter,
                              yang_name="parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'config-primitive']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)

    def _get_execution_environment_primitive(self):
        """
    Getter method for execution_environment_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
        return self.__execution_environment_primitive

    def _set_execution_environment_primitive(self, v, load=False):
        """
    Setter method for execution_environment_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_primitive must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__execution_environment_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_primitive(self):
        self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True,
                                                              yang_name="execution-environment-primitive", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                              defining_module='ns-configuration', yang_type='string',
                                                              is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(
            base=YANGListType("name", yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive_parameter,
                              yang_name="parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive,
                                                           _set_execution_environment_primitive)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref),
                                       ('execution_environment_primitive', execution_environment_primitive),
                                       ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__data_type', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'initial-config-primitive', 'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, choice=('primitive-type', 'primitive-definition'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    value = __builtin__.property(_get_value, _set_value)

    __choices__ = {'primitive-type': {'primitive-definition': ['name', 'data_type', 'value']}}
    _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
    __slots__ = ('_path_helper', '_extmethods', '__seq', '__name', '__execution_environment_ref', '__parameter',
                 '__user_defined_script',)

    _yang_name = 'initial-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='uint64', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        choice=('primitive-type', 'primitive-definition'),
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None, choice=False),
                                        is_container='list', yang_name="parameter", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, choice=('primitive-type', 'primitive-definition'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'initial-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self, v, load=False):
        """
    Setter method for seq, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="seq", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='uint64', is_config=True)""",
            })

        self.__seq = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='uint64', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        choice=('primitive-type', 'primitive-definition'),
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None, choice=False), is_container='list',
                             yang_name="parameter", parent=self, choice=('primitive-type', 'primitive-definition'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None, choice=False),
                                        is_container='list', yang_name="parameter", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, choice=('primitive-type', 'primitive-definition'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

    seq = __builtin__.property(_get_seq, _set_seq)
    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    __choices__ = {'primitive-type': {
        'primitive-definition': ['name', 'execution_environment_ref', 'parameter', 'user_defined_script']}}
    _pyangbind_elements = OrderedDict(
        [('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref),
         ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__data_type', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'terminate-config-primitive', 'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='common:parameter-data-type',
                                        is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                    defining_module='ns-configuration', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
    __slots__ = ('_path_helper', '_extmethods', '__seq', '__name', '__execution_environment_ref', '__parameter',
                 '__user_defined_script',)

    _yang_name = 'terminate-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='uint64', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'terminate-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self, v, load=False):
        """
    Setter method for seq, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="seq", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='uint64', is_config=True)""",
            })

        self.__seq = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='uint64', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                        defining_module='ns-configuration', yang_type='leafref',
                                                        is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                        defining_module='ns-configuration', yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                  defining_module='ns-configuration', yang_type='string',
                                                  is_config=True)

    seq = __builtin__.property(_get_seq, _set_seq)
    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    _pyangbind_elements = OrderedDict(
        [('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref),
         ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_etsi_nfv_nsd__nsd_nsd_ns_configuration_metrics(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFC related metrics
  """
    __slots__ = ('_path_helper', '_extmethods', '__name',)

    _yang_name = 'metrics'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'metrics']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)

    _pyangbind_elements = OrderedDict([('name', name), ])


class yc_entities_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation_entities(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/relation/entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__endpoint',)

    _yang_name = 'entities'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                 defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                       defining_module='ns-configuration', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'relation', 'entities']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities/id (string)

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                 defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_endpoint(self):
        """
    Getter method for endpoint, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities/endpoint (string)

    YANG Description: Endpoint name defining the relation.
    """
        return self.__endpoint

    def _set_endpoint(self, v, load=False):
        """
    Setter method for endpoint, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities/endpoint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Endpoint name defining the relation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """endpoint must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__endpoint = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_endpoint(self):
        self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                       defining_module='ns-configuration', yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    endpoint = __builtin__.property(_get_endpoint, _set_endpoint)

    _pyangbind_elements = OrderedDict([('id', id), ('endpoint', endpoint), ])


class yc_relation_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between elements in this descriptor.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__entities',)

    _yang_name = 'relation'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)
        self.__entities = YANGDynClass(
            base=YANGListType("id", yc_entities_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation_entities,
                              yang_name="entities", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration', 'relation']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/relation/name (string)

    YANG Description: Name of the relation.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/ns_configuration/relation/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relation.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='string', is_config=True)

    def _get_entities(self):
        """
    Getter method for entities, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities (list)

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
        return self.__entities

    def _set_entities(self, v, load=False):
        """
    Setter method for entities, mapped from YANG variable /nsd/nsd/ns_configuration/relation/entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entities() directly.

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_entities_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation_entities,
                                                  yang_name="entities", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="entities",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """entities must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_entities_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__entities = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_entities(self):
        self.__entities = YANGDynClass(
            base=YANGListType("id", yc_entities_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation_entities,
                              yang_name="entities", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    entities = __builtin__.property(_get_entities, _set_entities)

    _pyangbind_elements = OrderedDict([('name', name), ('entities', entities), ])


class yc_ns_configuration_etsi_nfv_nsd__nsd_nsd_ns_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd/ns-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Information about NS configuration.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__script', '__juju', '__execution_environment_list', '__config_primitive',
        '__initial_config_primitive', '__terminate_config_primitive', '__metrics', '__relation',)

    _yang_name = 'ns-configuration'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__script = YANGDynClass(base=yc_script_etsi_nfv_nsd__nsd_nsd_ns_configuration_script,
                                     is_container='container', yang_name="script", parent=self,
                                     choice=('config-method', 'script'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True, extensions=None,
                                     namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                     defining_module='ns-configuration', yang_type='container', is_config=True)
        self.__juju = YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_juju, is_container='container',
                                   yang_name="juju", parent=self, choice=('config-method', 'juju'),
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='container', is_config=True)
        self.__execution_environment_list = YANGDynClass(base=YANGListType("id",
                                                                           yc_execution_environment_list_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list,
                                                                           yang_name="execution-environment-list",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='id', extensions=None,
                                                                           choice=False), is_container='list',
                                                         yang_name="execution-environment-list", parent=self,
                                                         choice=('config-method', 'execution-environment-list'),
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True, extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                         defining_module='ns-configuration', yang_type='list',
                                                         is_config=True)
        self.__config_primitive = YANGDynClass(
            base=YANGListType("name", yc_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive,
                              yang_name="config-primitive", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                         yc_initial_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive,
                                                                         yang_name="initial-config-primitive",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='seq',
                                                                         extensions=None), is_container='list',
                                                       yang_name="initial-config-primitive", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                       defining_module='ns-configuration', yang_type='list',
                                                       is_config=True)
        self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                           yc_terminate_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive,
                                                                           yang_name="terminate-config-primitive",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='seq', extensions=None),
                                                         is_container='list', yang_name="terminate-config-primitive",
                                                         parent=self, path_helper=self._path_helper,
                                                         extmethods=self._extmethods, register_paths=True,
                                                         extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                         defining_module='ns-configuration', yang_type='list',
                                                         is_config=True)
        self.__metrics = YANGDynClass(
            base=YANGListType("name", yc_metrics_etsi_nfv_nsd__nsd_nsd_ns_configuration_metrics, yang_name="metrics",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='list', is_config=True)
        self.__relation = YANGDynClass(
            base=YANGListType("name", yc_relation_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation, yang_name="relation",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name', extensions=None), is_container='list', yang_name="relation",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd', 'ns-configuration']

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /nsd/nsd/ns_configuration/script (container)
    """
        return self.__script

    def _set_script(self, v, load=False):
        """
    Setter method for script, mapped from YANG variable /nsd/nsd/ns_configuration/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_script_etsi_nfv_nsd__nsd_nsd_ns_configuration_script, is_container='container',
                             yang_name="script", parent=self, choice=('config-method', 'script'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_script_etsi_nfv_nsd__nsd_nsd_ns_configuration_script, is_container='container', yang_name="script", parent=self, choice=('config-method', 'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='container', is_config=True)""",
            })

        self.__script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=yc_script_etsi_nfv_nsd__nsd_nsd_ns_configuration_script,
                                     is_container='container', yang_name="script", parent=self,
                                     choice=('config-method', 'script'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True, extensions=None,
                                     namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                     defining_module='ns-configuration', yang_type='container', is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /nsd/nsd/ns_configuration/juju (container)
    """
        return self.__juju

    def _set_juju(self, v, load=False):
        """
    Setter method for juju, mapped from YANG variable /nsd/nsd/ns_configuration/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_juju, is_container='container',
                             yang_name="juju", parent=self, choice=('config-method', 'juju'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_juju, is_container='container', yang_name="juju", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='container', is_config=True)""",
            })

        self.__juju = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(base=yc_juju_etsi_nfv_nsd__nsd_nsd_ns_configuration_juju, is_container='container',
                                   yang_name="juju", parent=self, choice=('config-method', 'juju'),
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                   defining_module='ns-configuration', yang_type='container', is_config=True)

    def _get_execution_environment_list(self):
        """
    Getter method for execution_environment_list, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list (list)
    """
        return self.__execution_environment_list

    def _set_execution_environment_list(self, v, load=False):
        """
    Setter method for execution_environment_list, mapped from YANG variable /nsd/nsd/ns_configuration/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_execution_environment_list_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list,
                                                  yang_name="execution-environment-list", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None,
                                                  choice=False), is_container='list',
                             yang_name="execution-environment-list", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_list must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__execution_environment_list = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_list(self):
        self.__execution_environment_list = YANGDynClass(base=YANGListType("id",
                                                                           yc_execution_environment_list_etsi_nfv_nsd__nsd_nsd_ns_configuration_execution_environment_list,
                                                                           yang_name="execution-environment-list",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='id', extensions=None,
                                                                           choice=False), is_container='list',
                                                         yang_name="execution-environment-list", parent=self,
                                                         choice=('config-method', 'execution-environment-list'),
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True, extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                         defining_module='ns-configuration', yang_type='list',
                                                         is_config=True)

    def _get_config_primitive(self):
        """
    Getter method for config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        return self.__config_primitive

    def _set_config_primitive(self, v, load=False):
        """
    Setter method for config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive,
                                                  yang_name="config-primitive", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="config-primitive",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_config_primitive(self):
        self.__config_primitive = YANGDynClass(
            base=YANGListType("name", yc_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_config_primitive,
                              yang_name="config-primitive", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

    def _get_initial_config_primitive(self):
        """
    Getter method for initial_config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
        return self.__initial_config_primitive

    def _set_initial_config_primitive(self, v, load=False):
        """
    Setter method for initial_config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("seq",
                                                  yc_initial_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive,
                                                  yang_name="initial-config-primitive", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='seq', extensions=None),
                             is_container='list', yang_name="initial-config-primitive", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """initial_config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__initial_config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_initial_config_primitive(self):
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                         yc_initial_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_initial_config_primitive,
                                                                         yang_name="initial-config-primitive",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='seq',
                                                                         extensions=None), is_container='list',
                                                       yang_name="initial-config-primitive", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                       defining_module='ns-configuration', yang_type='list',
                                                       is_config=True)

    def _get_terminate_config_primitive(self):
        """
    Getter method for terminate_config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
        return self.__terminate_config_primitive

    def _set_terminate_config_primitive(self, v, load=False):
        """
    Setter method for terminate_config_primitive, mapped from YANG variable /nsd/nsd/ns_configuration/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("seq",
                                                  yc_terminate_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive,
                                                  yang_name="terminate-config-primitive", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='seq', extensions=None),
                             is_container='list', yang_name="terminate-config-primitive", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """terminate_config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__terminate_config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_terminate_config_primitive(self):
        self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                           yc_terminate_config_primitive_etsi_nfv_nsd__nsd_nsd_ns_configuration_terminate_config_primitive,
                                                                           yang_name="terminate-config-primitive",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='seq', extensions=None),
                                                         is_container='list', yang_name="terminate-config-primitive",
                                                         parent=self, path_helper=self._path_helper,
                                                         extmethods=self._extmethods, register_paths=True,
                                                         extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                                         defining_module='ns-configuration', yang_type='list',
                                                         is_config=True)

    def _get_metrics(self):
        """
    Getter method for metrics, mapped from YANG variable /nsd/nsd/ns_configuration/metrics (list)

    YANG Description: List of VNFC related metrics
    """
        return self.__metrics

    def _set_metrics(self, v, load=False):
        """
    Setter method for metrics, mapped from YANG variable /nsd/nsd/ns_configuration/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VNFC related metrics
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name", yc_metrics_etsi_nfv_nsd__nsd_nsd_ns_configuration_metrics,
                                                  yang_name="metrics", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="metrics",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metrics must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_etsi_nfv_nsd__nsd_nsd_ns_configuration_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__metrics = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metrics(self):
        self.__metrics = YANGDynClass(
            base=YANGListType("name", yc_metrics_etsi_nfv_nsd__nsd_nsd_ns_configuration_metrics, yang_name="metrics",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration',
            yang_type='list', is_config=True)

    def _get_relation(self):
        """
    Getter method for relation, mapped from YANG variable /nsd/nsd/ns_configuration/relation (list)

    YANG Description: List of relations between elements in this descriptor.
    """
        return self.__relation

    def _set_relation(self, v, load=False):
        """
    Setter method for relation, mapped from YANG variable /nsd/nsd/ns_configuration/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between elements in this descriptor.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name", yc_relation_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation,
                                                  yang_name="relation", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="relation",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """relation must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_relation_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='list', is_config=True)""",
            })

        self.__relation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_relation(self):
        self.__relation = YANGDynClass(
            base=YANGListType("name", yc_relation_etsi_nfv_nsd__nsd_nsd_ns_configuration_relation, yang_name="relation",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='name', extensions=None), is_container='list', yang_name="relation",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
            defining_module='ns-configuration', yang_type='list', is_config=True)

    script = __builtin__.property(_get_script, _set_script)
    juju = __builtin__.property(_get_juju, _set_juju)
    execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
    config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
    initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
    terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
    metrics = __builtin__.property(_get_metrics, _set_metrics)
    relation = __builtin__.property(_get_relation, _set_relation)

    __choices__ = {'config-method': {'script': ['script'], 'juju': ['juju'],
                                     'execution-environment-list': ['execution_environment_list']}}
    _pyangbind_elements = OrderedDict(
        [('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list),
         ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive),
         ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('relation', relation), ])


class yc_nsd_etsi_nfv_nsd__nsd_nsd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The NSD information element is a deployment template whose
       instances are used by the NFVO for the lifecycle management
       of NSs.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__designer', '__version', '__name', '__invariant_id', '__nested_nsd_id',
        '__vnfd_id', '__pnfd_id', '__sapd', '__virtual_link_desc', '__vnffgd', '__autoscale_rule',
        '__lifecycle_management_script', '__df', '__signature', '__algorithm', '__certificate', '__ns_configuration',
        '__description',)

    _yang_name = 'nsd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__designer = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="designer", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__invariant_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__nested_nsd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                            yang_name="nested-nsd-id", parent=self, path_helper=self._path_helper,
                                            extmethods=self._extmethods, register_paths=True,
                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                            yang_type='leafref', is_config=True)
        self.__vnfd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="vnfd-id", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__pnfd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="pnfd-id", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)
        self.__sapd = YANGDynClass(
            base=YANGListType("id", yc_sapd_etsi_nfv_nsd__nsd_nsd_sapd, yang_name="sapd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="sapd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_link_desc_etsi_nfv_nsd__nsd_nsd_virtual_link_desc,
                              yang_name="virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        self.__vnffgd = YANGDynClass(
            base=YANGListType("id", yc_vnffgd_etsi_nfv_nsd__nsd_nsd_vnffgd, yang_name="vnffgd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="vnffgd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__autoscale_rule = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="autoscale-rule", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='string', is_config=True)
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("event", yc_lifecycle_management_script_etsi_nfv_nsd__nsd_nsd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='event', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__ns_configuration = YANGDynClass(base=yc_ns_configuration_etsi_nfv_nsd__nsd_nsd_ns_configuration,
                                               is_container='container', yang_name="ns-configuration", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                               defining_module='ns-configuration', yang_type='container',
                                               is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various',
                                          defining_module='ns-various', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'nsd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/nsd/id (string)

    YANG Description: Identifier of this NSD information element. It Globally
uniquely identifies an instance of the NSD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/nsd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this NSD information element. It Globally
uniquely identifies an instance of the NSD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_designer(self):
        """
    Getter method for designer, mapped from YANG variable /nsd/nsd/designer (string)

    YANG Description: Identifies the designer of the NSD.
    """
        return self.__designer

    def _set_designer(self, v, load=False):
        """
    Setter method for designer, mapped from YANG variable /nsd/nsd/designer (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_designer is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_designer() directly.

    YANG Description: Identifies the designer of the NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="designer", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """designer must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="designer", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__designer = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_designer(self):
        self.__designer = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="designer", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd/nsd/version (string)

    YANG Description: Identifies the version of the NSD.
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /nsd/nsd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/nsd/name (string)

    YANG Description: Provides the human readable name of the NSD.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/nsd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides the human readable name of the NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_invariant_id(self):
        """
    Getter method for invariant_id, mapped from YANG variable /nsd/nsd/invariant_id (string)

    YANG Description: Identifies an NSD in a version independent manner. This
attribute is invariant across versions of the network
service descriptor.
    """
        return self.__invariant_id

    def _set_invariant_id(self, v, load=False):
        """
    Setter method for invariant_id, mapped from YANG variable /nsd/nsd/invariant_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariant_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariant_id() directly.

    YANG Description: Identifies an NSD in a version independent manner. This
attribute is invariant across versions of the network
service descriptor.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """invariant_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__invariant_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_invariant_id(self):
        self.__invariant_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_nested_nsd_id(self):
        """
    Getter method for nested_nsd_id, mapped from YANG variable /nsd/nsd/nested_nsd_id (leafref)

    YANG Description: References the NSD of a constituent nested NS.
    """
        return self.__nested_nsd_id

    def _set_nested_nsd_id(self, v, load=False):
        """
    Setter method for nested_nsd_id, mapped from YANG variable /nsd/nsd/nested_nsd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nested_nsd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nested_nsd_id() directly.

    YANG Description: References the NSD of a constituent nested NS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="nested-nsd-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nested_nsd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nested-nsd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__nested_nsd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nested_nsd_id(self):
        self.__nested_nsd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                            yang_name="nested-nsd-id", parent=self, path_helper=self._path_helper,
                                            extmethods=self._extmethods, register_paths=True,
                                            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                            yang_type='leafref', is_config=True)

    def _get_vnfd_id(self):
        """
    Getter method for vnfd_id, mapped from YANG variable /nsd/nsd/vnfd_id (leafref)

    YANG Description: References the VNFD of a constituent VNF.
    """
        return self.__vnfd_id

    def _set_vnfd_id(self, v, load=False):
        """
    Setter method for vnfd_id, mapped from YANG variable /nsd/nsd/vnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd_id() directly.

    YANG Description: References the VNFD of a constituent VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vnfd-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vnfd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__vnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd_id(self):
        self.__vnfd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="vnfd-id", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_pnfd_id(self):
        """
    Getter method for pnfd_id, mapped from YANG variable /nsd/nsd/pnfd_id (leafref)

    YANG Description: References the PNFD of a constituent PNF.
    """
        return self.__pnfd_id

    def _set_pnfd_id(self, v, load=False):
        """
    Setter method for pnfd_id, mapped from YANG variable /nsd/nsd/pnfd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnfd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnfd_id() directly.

    YANG Description: References the PNFD of a constituent PNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="pnfd-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnfd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="pnfd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='leafref', is_config=True)""",
            })

        self.__pnfd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnfd_id(self):
        self.__pnfd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="pnfd-id", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='leafref', is_config=True)

    def _get_sapd(self):
        """
    Getter method for sapd, mapped from YANG variable /nsd/nsd/sapd (list)

    YANG Description: Provides the descriptor of a service access point of the
network service.
    """
        return self.__sapd

    def _set_sapd(self, v, load=False):
        """
    Setter method for sapd, mapped from YANG variable /nsd/nsd/sapd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sapd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sapd() directly.

    YANG Description: Provides the descriptor of a service access point of the
network service.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_sapd_etsi_nfv_nsd__nsd_nsd_sapd, yang_name="sapd", parent=self,
                                               is_container='list', user_ordered=False, path_helper=self._path_helper,
                                               yang_keys='id', extensions=None), is_container='list', yang_name="sapd",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sapd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_sapd_etsi_nfv_nsd__nsd_nsd_sapd, yang_name="sapd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="sapd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__sapd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sapd(self):
        self.__sapd = YANGDynClass(
            base=YANGListType("id", yc_sapd_etsi_nfv_nsd__nsd_nsd_sapd, yang_name="sapd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="sapd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_virtual_link_desc(self):
        """
    Getter method for virtual_link_desc, mapped from YANG variable /nsd/nsd/virtual_link_desc (list)

    YANG Description: Provides the constituent VLDs.
    """
        return self.__virtual_link_desc

    def _set_virtual_link_desc(self, v, load=False):
        """
    Setter method for virtual_link_desc, mapped from YANG variable /nsd/nsd/virtual_link_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_desc() directly.

    YANG Description: Provides the constituent VLDs.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_virtual_link_desc_etsi_nfv_nsd__nsd_nsd_virtual_link_desc,
                                                  yang_name="virtual-link-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="virtual-link-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_link_desc_etsi_nfv_nsd__nsd_nsd_virtual_link_desc, yang_name="virtual-link-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_desc(self):
        self.__virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_link_desc_etsi_nfv_nsd__nsd_nsd_virtual_link_desc,
                              yang_name="virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    def _get_vnffgd(self):
        """
    Getter method for vnffgd, mapped from YANG variable /nsd/nsd/vnffgd (list)

    YANG Description: Provides the descriptors of the applicable forwarding
graphs.
    """
        return self.__vnffgd

    def _set_vnffgd(self, v, load=False):
        """
    Setter method for vnffgd, mapped from YANG variable /nsd/nsd/vnffgd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnffgd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnffgd() directly.

    YANG Description: Provides the descriptors of the applicable forwarding
graphs.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vnffgd_etsi_nfv_nsd__nsd_nsd_vnffgd, yang_name="vnffgd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnffgd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnffgd_etsi_nfv_nsd__nsd_nsd_vnffgd, yang_name="vnffgd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnffgd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vnffgd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnffgd(self):
        self.__vnffgd = YANGDynClass(
            base=YANGListType("id", yc_vnffgd_etsi_nfv_nsd__nsd_nsd_vnffgd, yang_name="vnffgd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="vnffgd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_autoscale_rule(self):
        """
    Getter method for autoscale_rule, mapped from YANG variable /nsd/nsd/autoscale_rule (string)
    """
        return self.__autoscale_rule

    def _set_autoscale_rule(self, v, load=False):
        """
    Setter method for autoscale_rule, mapped from YANG variable /nsd/nsd/autoscale_rule (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_autoscale_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_autoscale_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="autoscale-rule", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """autoscale_rule must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="autoscale-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__autoscale_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_autoscale_rule(self):
        self.__autoscale_rule = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                             yang_name="autoscale-rule", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='string', is_config=True)

    def _get_lifecycle_management_script(self):
        """
    Getter method for lifecycle_management_script, mapped from YANG variable /nsd/nsd/lifecycle_management_script (list)
    """
        return self.__lifecycle_management_script

    def _set_lifecycle_management_script(self, v, load=False):
        """
    Setter method for lifecycle_management_script, mapped from YANG variable /nsd/nsd/lifecycle_management_script (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifecycle_management_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifecycle_management_script() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("event",
                                                  yc_lifecycle_management_script_etsi_nfv_nsd__nsd_nsd_lifecycle_management_script,
                                                  yang_name="lifecycle-management-script", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='event', extensions=None),
                             is_container='list', yang_name="lifecycle-management-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lifecycle_management_script must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("event",yc_lifecycle_management_script_etsi_nfv_nsd__nsd_nsd_lifecycle_management_script, yang_name="lifecycle-management-script", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='event', extensions=None), is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__lifecycle_management_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lifecycle_management_script(self):
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("event", yc_lifecycle_management_script_etsi_nfv_nsd__nsd_nsd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='event', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_df(self):
        """
    Getter method for df, mapped from YANG variable /nsd/nsd/df (list)

    YANG Description: Identifies a DF within the scope of an NSD.
    """
        return self.__df

    def _set_df(self, v, load=False):
        """
    Setter method for df, mapped from YANG variable /nsd/nsd/df (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df() directly.

    YANG Description: Identifies a DF within the scope of an NSD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_df, yang_name="df", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """df must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_df_etsi_nfv_nsd__nsd_nsd_df, yang_name="df", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__df = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_df(self):
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_nsd__nsd_nsd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_signature(self):
        """
    Getter method for signature, mapped from YANG variable /nsd/nsd/signature (string)

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        return self.__signature

    def _set_signature(self, v, load=False):
        """
    Setter method for signature, mapped from YANG variable /nsd/nsd/signature (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_signature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_signature() directly.

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """signature must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__signature = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_signature(self):
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_algorithm(self):
        """
    Getter method for algorithm, mapped from YANG variable /nsd/nsd/algorithm (string)

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        return self.__algorithm

    def _set_algorithm(self, v, load=False):
        """
    Setter method for algorithm, mapped from YANG variable /nsd/nsd/algorithm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """algorithm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__algorithm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_algorithm(self):
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_certificate(self):
        """
    Getter method for certificate, mapped from YANG variable /nsd/nsd/certificate (string)

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        return self.__certificate

    def _set_certificate(self, v, load=False):
        """
    Setter method for certificate, mapped from YANG variable /nsd/nsd/certificate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificate() directly.

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """certificate must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__certificate = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_certificate(self):
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_ns_configuration(self):
        """
    Getter method for ns_configuration, mapped from YANG variable /nsd/nsd/ns_configuration (container)

    YANG Description: Information about NS configuration.
    """
        return self.__ns_configuration

    def _set_ns_configuration(self, v, load=False):
        """
    Setter method for ns_configuration, mapped from YANG variable /nsd/nsd/ns_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ns_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ns_configuration() directly.

    YANG Description: Information about NS configuration.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_ns_configuration_etsi_nfv_nsd__nsd_nsd_ns_configuration,
                             is_container='container', yang_name="ns-configuration", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration',
                             defining_module='ns-configuration', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ns_configuration must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_ns_configuration_etsi_nfv_nsd__nsd_nsd_ns_configuration, is_container='container', yang_name="ns-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:ns-configuration', defining_module='ns-configuration', yang_type='container', is_config=True)""",
            })

        self.__ns_configuration = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ns_configuration(self):
        self.__ns_configuration = YANGDynClass(base=yc_ns_configuration_etsi_nfv_nsd__nsd_nsd_ns_configuration,
                                               is_container='container', yang_name="ns-configuration", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:ns-configuration',
                                               defining_module='ns-configuration', yang_type='container',
                                               is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/nsd/description (string)
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/nsd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various', defining_module='ns-various', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:ns-various',
                                          defining_module='ns-various', yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    designer = __builtin__.property(_get_designer, _set_designer)
    version = __builtin__.property(_get_version, _set_version)
    name = __builtin__.property(_get_name, _set_name)
    invariant_id = __builtin__.property(_get_invariant_id, _set_invariant_id)
    nested_nsd_id = __builtin__.property(_get_nested_nsd_id, _set_nested_nsd_id)
    vnfd_id = __builtin__.property(_get_vnfd_id, _set_vnfd_id)
    pnfd_id = __builtin__.property(_get_pnfd_id, _set_pnfd_id)
    sapd = __builtin__.property(_get_sapd, _set_sapd)
    virtual_link_desc = __builtin__.property(_get_virtual_link_desc, _set_virtual_link_desc)
    vnffgd = __builtin__.property(_get_vnffgd, _set_vnffgd)
    autoscale_rule = __builtin__.property(_get_autoscale_rule, _set_autoscale_rule)
    lifecycle_management_script = __builtin__.property(_get_lifecycle_management_script,
                                                       _set_lifecycle_management_script)
    df = __builtin__.property(_get_df, _set_df)
    signature = __builtin__.property(_get_signature, _set_signature)
    algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
    certificate = __builtin__.property(_get_certificate, _set_certificate)
    ns_configuration = __builtin__.property(_get_ns_configuration, _set_ns_configuration)
    description = __builtin__.property(_get_description, _set_description)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('designer', designer), ('version', version), ('name', name), ('invariant_id', invariant_id),
         ('nested_nsd_id', nested_nsd_id), ('vnfd_id', vnfd_id), ('pnfd_id', pnfd_id), ('sapd', sapd),
         ('virtual_link_desc', virtual_link_desc), ('vnffgd', vnffgd), ('autoscale_rule', autoscale_rule),
         ('lifecycle_management_script', lifecycle_management_script), ('df', df), ('signature', signature),
         ('algorithm', algorithm), ('certificate', certificate), ('ns_configuration', ns_configuration),
         ('description', description), ])


class yc_l2_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l2_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/ext-cpd/protocol/address-data/l2-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
  """
    __slots__ = ('_path_helper', '_extmethods', '__mac_address_assignment',)

    _yang_name = 'l2-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'ext-cpd', 'protocol', 'address-data', 'l2-address-data']

    def _get_mac_address_assignment(self):
        """
    Getter method for mac_address_assignment, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        return self.__mac_address_assignment

    def _set_mac_address_assignment(self, v, load=False):
        """
    Setter method for mac_address_assignment, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_assignment() directly.

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__mac_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address_assignment(self):
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                     defining_module='etsi-nfv-nsd', yang_type='boolean',
                                                     is_config=True)

    mac_address_assignment = __builtin__.property(_get_mac_address_assignment, _set_mac_address_assignment)

    _pyangbind_elements = OrderedDict([('mac_address_assignment', mac_address_assignment), ])


class yc_l3_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l3_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/ext-cpd/protocol/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__ip_address_assignment', '__floating_ip_activated', '__ip_address_type',
        '__number_of_ip_addresses',)

    _yang_name = 'l3-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'ext-cpd', 'protocol', 'address-data', 'l3-address-data']

    def _get_ip_address_assignment(self):
        """
    Getter method for ip_address_assignment, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
    Setter method for ip_address_assignment, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__ip_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_floating_ip_activated(self):
        """
    Getter method for floating_ip_activated, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
    Setter method for floating_ip_activated, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_activated must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_activated = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                    defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    def _get_ip_address_type(self):
        """
    Getter method for ip_address_type, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
    Setter method for ip_address_type, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
                             yang_name="ip-address-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_address_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='enumeration', is_config=True)

    def _get_number_of_ip_addresses(self):
        """
    Getter method for number_of_ip_addresses, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
    Setter method for number_of_ip_addresses, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="number-of-ip-addresses",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_ip_addresses = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint32', is_config=True)

    ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
    floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)

    _pyangbind_elements = OrderedDict(
        [('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated),
         ('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ])


class yc_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/ext-cpd/protocol/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__l2_address_data', '__l3_address_data',)

    _yang_name = 'address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'ext-cpd', 'protocol', 'address-data']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/type (identityref)

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
   MAC address.
   IP address.
   Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_l2_address_data(self):
        """
    Getter method for l2_address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l2_address_data (container)

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
    Setter method for l2_address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l2_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l2_address_data,
                             is_container='container', yang_name="l2-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l2_address_data, is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l2_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    def _get_l3_address_data(self):
        """
    Getter method for l3_address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
    Setter method for l3_address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l3_address_data,
                             is_container='container', yang_name="l3-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__l3_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [('type', type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_protocol_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/ext-cpd/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
  """
    __slots__ = ('_path_helper', '_extmethods', '__associated_layer_protocol', '__address_data',)

    _yang_name = 'protocol'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'ext-cpd', 'protocol']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref',
            is_config=True)

    def _get_address_data(self):
        """
    Getter method for address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
    Setter method for address_data, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("type",
                                                  yc_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data,
                                                  yang_name="address-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='type',
                                                  extensions=None), is_container='list', yang_name="address-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("type",yc_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('address_data', address_data), ])


class yc_ext_cpd_etsi_nfv_nsd__nsd_pnfd_ext_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/ext-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the characteristics of one or more connection
points where to connect the PNF to a VL.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__layer_protocol', '__role', '__description', '__protocol',
        '__trunk_mode',)

    _yang_name = 'ext-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'ext-cpd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/pnfd/ext_cpd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/pnfd/ext_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/layer_protocol (identityref)

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                             yang_type='identityref', is_config=True)

    def _get_role(self):
        """
    Getter method for role, mapped from YANG variable /nsd/pnfd/ext_cpd/role (identityref)

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        return self.__role

    def _set_role(self, v, load=False):
        """
    Setter method for role, mapped from YANG variable /nsd/pnfd/ext_cpd/role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """role must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-nsd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='identityref', is_config=True)""",
            })

        self.__role = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_role(self):
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='identityref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/pnfd/ext_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/pnfd/ext_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol (list)

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /nsd/pnfd/ext_cpd/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("associated_layer_protocol",
                                                  yc_protocol_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol,
                                                  yang_name="protocol", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='associated-layer-protocol', extensions=None),
                             is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_protocol_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_nsd__nsd_pnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_trunk_mode(self):
        """
    Getter method for trunk_mode, mapped from YANG variable /nsd/pnfd/ext_cpd/trunk_mode (boolean)

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
    Setter method for trunk_mode, mapped from YANG variable /nsd/pnfd/ext_cpd/trunk_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_mode() directly.

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trunk_mode must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)""",
            })

        self.__trunk_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='boolean', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    role = __builtin__.property(_get_role, _set_role)
    description = __builtin__.property(_get_description, _set_description)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('layer_protocol', layer_protocol), ('role', role), ('description', description),
         ('protocol', protocol), ('trunk_mode', trunk_mode), ])


class yc_security_etsi_nfv_nsd__nsd_pnfd_security(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/security. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides a signature to prevent tampering.
Editor's Note: While IFA014 does specify that the PNFD
includes a security parameter. SOL001 does not have one.
We need to harmonize SOL001 & SOL006 on this point.
  """
    __slots__ = ('_path_helper', '_extmethods', '__signature', '__algorithm', '__certificate',)

    _yang_name = 'security'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'security']

    def _get_signature(self):
        """
    Getter method for signature, mapped from YANG variable /nsd/pnfd/security/signature (string)

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        return self.__signature

    def _set_signature(self, v, load=False):
        """
    Setter method for signature, mapped from YANG variable /nsd/pnfd/security/signature (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_signature is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_signature() directly.

    YANG Description: Provides the signature of the signed part of the
descriptor.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """signature must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__signature = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_signature(self):
        self.__signature = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="signature", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_algorithm(self):
        """
    Getter method for algorithm, mapped from YANG variable /nsd/pnfd/security/algorithm (string)

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        return self.__algorithm

    def _set_algorithm(self, v, load=False):
        """
    Setter method for algorithm, mapped from YANG variable /nsd/pnfd/security/algorithm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Identifies the algorithm used to compute the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """algorithm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__algorithm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_algorithm(self):
        self.__algorithm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="algorithm", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                        yang_type='string', is_config=True)

    def _get_certificate(self):
        """
    Getter method for certificate, mapped from YANG variable /nsd/pnfd/security/certificate (string)

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        return self.__certificate

    def _set_certificate(self, v, load=False):
        """
    Setter method for certificate, mapped from YANG variable /nsd/pnfd/security/certificate (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_certificate is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_certificate() directly.

    YANG Description: Provides a certificate or a reference to a certificate to
validate the signature.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """certificate must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__certificate = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_certificate(self):
        self.__certificate = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="certificate", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    signature = __builtin__.property(_get_signature, _set_signature)
    algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
    certificate = __builtin__.property(_get_certificate, _set_certificate)

    _pyangbind_elements = OrderedDict(
        [('signature', signature), ('algorithm', algorithm), ('certificate', certificate), ])


class yc_security_group_rule_etsi_nfv_nsd__nsd_pnfd_security_group_rule(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd/security-group-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines security group rules to be used by the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__direction', '__ether_type', '__protocol',
                 '__port_range_min', '__port_range_max',)

    _yang_name = 'security-group-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='enumeration', is_config=True)
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd', 'security-group-rule']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/pnfd/security_group_rule/id (string)

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/pnfd/security_group_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /nsd/pnfd/security_group_rule/description (string)

    YANG Description: Human readable description of the security group rule.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /nsd/pnfd/security_group_rule/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the security group rule.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                          defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_direction(self):
        """
    Getter method for direction, mapped from YANG variable /nsd/pnfd/security_group_rule/direction (enumeration)

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        return self.__direction

    def _set_direction(self, v, load=False):
        """
    Setter method for direction, mapped from YANG variable /nsd/pnfd/security_group_rule/direction (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ingress': {}, 'egress': {}}, ),
                             default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """direction must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ingress': {}, 'egress': {}},), default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__direction = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_direction(self):
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                        defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_ether_type(self):
        """
    Getter method for ether_type, mapped from YANG variable /nsd/pnfd/security_group_rule/ether_type (enumeration)

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        return self.__ether_type

    def _set_ether_type(self, v, load=False):
        """
    Setter method for ether_type, mapped from YANG variable /nsd/pnfd/security_group_rule/ether_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ether_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ether_type() directly.

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ether_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__ether_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ether_type(self):
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                         defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /nsd/pnfd/security_group_rule/protocol (enumeration)

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /nsd/pnfd/security_group_rule/protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                             default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-nsd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}},), default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='enumeration', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='enumeration', is_config=True)

    def _get_port_range_min(self):
        """
    Getter method for port_range_min, mapped from YANG variable /nsd/pnfd/security_group_rule/port_range_min (uint16)

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        return self.__port_range_min

    def _set_port_range_min(self, v, load=False):
        """
    Setter method for port_range_min, mapped from YANG variable /nsd/pnfd/security_group_rule/port_range_min (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_min() directly.

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(0), is_leaf=True, yang_name="port-range-min",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_min must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_min = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_min(self):
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    def _get_port_range_max(self):
        """
    Getter method for port_range_max, mapped from YANG variable /nsd/pnfd/security_group_rule/port_range_max (uint16)

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        return self.__port_range_max

    def _set_port_range_max(self, v, load=False):
        """
    Setter method for port_range_max, mapped from YANG variable /nsd/pnfd/security_group_rule/port_range_max (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_max() directly.

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(65535), is_leaf=True, yang_name="port-range-max",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_max must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(65535), is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_max = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_max(self):
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='uint16', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    direction = __builtin__.property(_get_direction, _set_direction)
    ether_type = __builtin__.property(_get_ether_type, _set_ether_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    port_range_min = __builtin__.property(_get_port_range_min, _set_port_range_min)
    port_range_max = __builtin__.property(_get_port_range_max, _set_port_range_max)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('direction', direction), ('ether_type', ether_type),
         ('protocol', protocol), ('port_range_min', port_range_min), ('port_range_max', port_range_max), ])


class yc_pnfd_etsi_nfv_nsd__nsd_pnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd/pnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Pnfd information element is a deployment template
       enabling on-boarding PNFs and referencing them from an
       NSD. It focuses on connectivity aspects only.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__function_description', '__provider', '__version', '__invariant_id',
        '__name', '__ext_cpd', '__security', '__geographical_location_info', '__security_group_rule',)

    _yang_name = 'pnfd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__function_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="function-description",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)
        self.__invariant_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_pnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__security = YANGDynClass(
            base=YANGListType("signature", yc_security_etsi_nfv_nsd__nsd_pnfd_security, yang_name="security",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='signature', extensions=None), is_container='list', yang_name="security",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)
        self.__geographical_location_info = YANGDynClass(base=six.text_type, is_leaf=True,
                                                         yang_name="geographical-location-info", parent=self,
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True,
                                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                         defining_module='etsi-nfv-nsd', yang_type='string',
                                                         is_config=True)
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_pnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd', 'pnfd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /nsd/pnfd/id (string)

    YANG Description: Identifier of this Pnfd information element. It uniquely
identifies the PNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /nsd/pnfd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Pnfd information element. It uniquely
identifies the PNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                 defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_function_description(self):
        """
    Getter method for function_description, mapped from YANG variable /nsd/pnfd/function_description (string)

    YANG Description: Describes the PNF function.
    """
        return self.__function_description

    def _set_function_description(self, v, load=False):
        """
    Setter method for function_description, mapped from YANG variable /nsd/pnfd/function_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_function_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_function_description() directly.

    YANG Description: Describes the PNF function.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="function-description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """function_description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="function-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__function_description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_function_description(self):
        self.__function_description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="function-description",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                   defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_provider(self):
        """
    Getter method for provider, mapped from YANG variable /nsd/pnfd/provider (string)

    YANG Description: Identifies the provider of the PNFD.
    """
        return self.__provider

    def _set_provider(self, v, load=False):
        """
    Setter method for provider, mapped from YANG variable /nsd/pnfd/provider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider() directly.

    YANG Description: Identifies the provider of the PNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """provider must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__provider = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_provider(self):
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                       yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /nsd/pnfd/version (string)

    YANG Description: Identifies the version of the PNFD.
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /nsd/pnfd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the PNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                      yang_type='string', is_config=True)

    def _get_invariant_id(self):
        """
    Getter method for invariant_id, mapped from YANG variable /nsd/pnfd/invariant_id (string)

    YANG Description: Identifies a PNFD in a version independent manner. This
attribute is invariant across versions of PNFD.
    """
        return self.__invariant_id

    def _set_invariant_id(self, v, load=False):
        """
    Setter method for invariant_id, mapped from YANG variable /nsd/pnfd/invariant_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_invariant_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_invariant_id() directly.

    YANG Description: Identifies a PNFD in a version independent manner. This
attribute is invariant across versions of PNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """invariant_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__invariant_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_invariant_id(self):
        self.__invariant_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="invariant-id", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                           defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /nsd/pnfd/name (string)

    YANG Description: Provides the human readable name of the PNFD.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /nsd/pnfd/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides the human readable name of the PNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                                   yang_type='string', is_config=True)

    def _get_ext_cpd(self):
        """
    Getter method for ext_cpd, mapped from YANG variable /nsd/pnfd/ext_cpd (list)

    YANG Description: Specifies the characteristics of one or more connection
points where to connect the PNF to a VL.
    """
        return self.__ext_cpd

    def _set_ext_cpd(self, v, load=False):
        """
    Setter method for ext_cpd, mapped from YANG variable /nsd/pnfd/ext_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd() directly.

    YANG Description: Specifies the characteristics of one or more connection
points where to connect the PNF to a VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_pnfd_ext_cpd, yang_name="ext-cpd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_ext_cpd_etsi_nfv_nsd__nsd_pnfd_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__ext_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd(self):
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_nsd__nsd_pnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_security(self):
        """
    Getter method for security, mapped from YANG variable /nsd/pnfd/security (list)

    YANG Description: Provides a signature to prevent tampering.
Editor's Note: While IFA014 does specify that the PNFD
includes a security parameter. SOL001 does not have one.
We need to harmonize SOL001 & SOL006 on this point.
    """
        return self.__security

    def _set_security(self, v, load=False):
        """
    Setter method for security, mapped from YANG variable /nsd/pnfd/security (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security() directly.

    YANG Description: Provides a signature to prevent tampering.
Editor's Note: While IFA014 does specify that the PNFD
includes a security parameter. SOL001 does not have one.
We need to harmonize SOL001 & SOL006 on this point.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("signature", yc_security_etsi_nfv_nsd__nsd_pnfd_security,
                                                  yang_name="security", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='signature', extensions=None), is_container='list',
                             yang_name="security", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("signature",yc_security_etsi_nfv_nsd__nsd_pnfd_security, yang_name="security", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='signature', extensions=None), is_container='list', yang_name="security", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__security = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security(self):
        self.__security = YANGDynClass(
            base=YANGListType("signature", yc_security_etsi_nfv_nsd__nsd_pnfd_security, yang_name="security",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='signature', extensions=None), is_container='list', yang_name="security",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
            yang_type='list', is_config=True)

    def _get_geographical_location_info(self):
        """
    Getter method for geographical_location_info, mapped from YANG variable /nsd/pnfd/geographical_location_info (string)

    YANG Description: It provides information about the geographical location
(e.g. geographic coordinates or address of the building,
etc.) of the PNF. The cardinality 0 is used when the
location is unknown.
Editor's Note: The type is TBD in SOL001. We need to make
a common SOL001/SOL006 decision.
    """
        return self.__geographical_location_info

    def _set_geographical_location_info(self, v, load=False):
        """
    Setter method for geographical_location_info, mapped from YANG variable /nsd/pnfd/geographical_location_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_geographical_location_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_geographical_location_info() directly.

    YANG Description: It provides information about the geographical location
(e.g. geographic coordinates or address of the building,
etc.) of the PNF. The cardinality 0 is used when the
location is unknown.
Editor's Note: The type is TBD in SOL001. We need to make
a common SOL001/SOL006 decision.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="geographical-location-info", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """geographical_location_info must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="geographical-location-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='string', is_config=True)""",
            })

        self.__geographical_location_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_geographical_location_info(self):
        self.__geographical_location_info = YANGDynClass(base=six.text_type, is_leaf=True,
                                                         yang_name="geographical-location-info", parent=self,
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True,
                                                         namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                                         defining_module='etsi-nfv-nsd', yang_type='string',
                                                         is_config=True)

    def _get_security_group_rule(self):
        """
    Getter method for security_group_rule, mapped from YANG variable /nsd/pnfd/security_group_rule (list)

    YANG Description: Defines security group rules to be used by the VNF.
    """
        return self.__security_group_rule

    def _set_security_group_rule(self, v, load=False):
        """
    Setter method for security_group_rule, mapped from YANG variable /nsd/pnfd/security_group_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule() directly.

    YANG Description: Defines security group rules to be used by the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_pnfd_security_group_rule,
                                               yang_name="security-group-rule", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="security-group-rule",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_security_group_rule_etsi_nfv_nsd__nsd_pnfd_security_group_rule, yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__security_group_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule(self):
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_nsd__nsd_pnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
            defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    function_description = __builtin__.property(_get_function_description, _set_function_description)
    provider = __builtin__.property(_get_provider, _set_provider)
    version = __builtin__.property(_get_version, _set_version)
    invariant_id = __builtin__.property(_get_invariant_id, _set_invariant_id)
    name = __builtin__.property(_get_name, _set_name)
    ext_cpd = __builtin__.property(_get_ext_cpd, _set_ext_cpd)
    security = __builtin__.property(_get_security, _set_security)
    geographical_location_info = __builtin__.property(_get_geographical_location_info, _set_geographical_location_info)
    security_group_rule = __builtin__.property(_get_security_group_rule, _set_security_group_rule)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('function_description', function_description), ('provider', provider), ('version', version),
         ('invariant_id', invariant_id), ('name', name), ('ext_cpd', ext_cpd), ('security', security),
         ('geographical_location_info', geographical_location_info), ('security_group_rule', security_group_rule), ])


class yc_nsd_etsi_nfv_nsd__nsd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnfd', '__nsd', '__pnfd',)

    _yang_name = 'nsd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd = YANGDynClass(
            base=YANGListType("id", yc_vnfd_etsi_nfv_nsd__nsd_vnfd, yang_name="vnfd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__nsd = YANGDynClass(
            base=YANGListType("id", yc_nsd_etsi_nfv_nsd__nsd_nsd, yang_name="nsd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)
        self.__pnfd = YANGDynClass(
            base=YANGListType("id", yc_pnfd_etsi_nfv_nsd__nsd_pnfd, yang_name="pnfd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="pnfd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['nsd']

    def _get_vnfd(self):
        """
    Getter method for vnfd, mapped from YANG variable /nsd/vnfd (list)

    YANG Description: A VNF Descriptor (VNFD) is a deployment template which
describes a VNF in terms of deployment and operational
behaviour requirements. It also contains connectivity,
interface and virtualised resource requirements
    """
        return self.__vnfd

    def _set_vnfd(self, v, load=False):
        """
    Setter method for vnfd, mapped from YANG variable /nsd/vnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd() directly.

    YANG Description: A VNF Descriptor (VNFD) is a deployment template which
describes a VNF in terms of deployment and operational
behaviour requirements. It also contains connectivity,
interface and virtualised resource requirements
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vnfd_etsi_nfv_nsd__nsd_vnfd, yang_name="vnfd", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vnfd_etsi_nfv_nsd__nsd_vnfd, yang_name="vnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__vnfd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd(self):
        self.__vnfd = YANGDynClass(
            base=YANGListType("id", yc_vnfd_etsi_nfv_nsd__nsd_vnfd, yang_name="vnfd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="vnfd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_nsd(self):
        """
    Getter method for nsd, mapped from YANG variable /nsd/nsd (list)

    YANG Description: The NSD information element is a deployment template whose
       instances are used by the NFVO for the lifecycle management
       of NSs.
    """
        return self.__nsd

    def _set_nsd(self, v, load=False):
        """
    Setter method for nsd, mapped from YANG variable /nsd/nsd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd() directly.

    YANG Description: The NSD information element is a deployment template whose
       instances are used by the NFVO for the lifecycle management
       of NSs.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_nsd_etsi_nfv_nsd__nsd_nsd, yang_name="nsd", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nsd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_nsd_etsi_nfv_nsd__nsd_nsd, yang_name="nsd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__nsd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nsd(self):
        self.__nsd = YANGDynClass(
            base=YANGListType("id", yc_nsd_etsi_nfv_nsd__nsd_nsd, yang_name="nsd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="nsd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    def _get_pnfd(self):
        """
    Getter method for pnfd, mapped from YANG variable /nsd/pnfd (list)

    YANG Description: The Pnfd information element is a deployment template
       enabling on-boarding PNFs and referencing them from an
       NSD. It focuses on connectivity aspects only.
    """
        return self.__pnfd

    def _set_pnfd(self, v, load=False):
        """
    Setter method for pnfd, mapped from YANG variable /nsd/pnfd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pnfd() directly.

    YANG Description: The Pnfd information element is a deployment template
       enabling on-boarding PNFs and referencing them from an
       NSD. It focuses on connectivity aspects only.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_pnfd_etsi_nfv_nsd__nsd_pnfd, yang_name="pnfd", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="pnfd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pnfd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_pnfd_etsi_nfv_nsd__nsd_pnfd, yang_name="pnfd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="pnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list', is_config=True)""",
            })

        self.__pnfd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pnfd(self):
        self.__pnfd = YANGDynClass(
            base=YANGListType("id", yc_pnfd_etsi_nfv_nsd__nsd_pnfd, yang_name="pnfd", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="pnfd", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='list',
            is_config=True)

    vnfd = __builtin__.property(_get_vnfd, _set_vnfd)
    nsd = __builtin__.property(_get_nsd, _set_nsd)
    pnfd = __builtin__.property(_get_pnfd, _set_pnfd)

    _pyangbind_elements = OrderedDict([('vnfd', vnfd), ('nsd', nsd), ('pnfd', pnfd), ])


class etsi_nfv_nsd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-nsd - based on the path /etsi-nfv-nsd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Network Services Descriptors
  """
    __slots__ = ('_path_helper', '_extmethods', '__nsd',)

    _yang_name = 'etsi-nfv-nsd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__nsd = YANGDynClass(base=yc_nsd_etsi_nfv_nsd__nsd, is_container='container', yang_name="nsd", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_nsd(self):
        """
    Getter method for nsd, mapped from YANG variable /nsd (container)
    """
        return self.__nsd

    def _set_nsd(self, v, load=False):
        """
    Setter method for nsd, mapped from YANG variable /nsd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nsd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nsd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_nsd_etsi_nfv_nsd__nsd, is_container='container', yang_name="nsd", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                             defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nsd must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_nsd_etsi_nfv_nsd__nsd, is_container='container', yang_name="nsd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd', defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)""",
            })

        self.__nsd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nsd(self):
        self.__nsd = YANGDynClass(base=yc_nsd_etsi_nfv_nsd__nsd, is_container='container', yang_name="nsd", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-nsd',
                                  defining_module='etsi-nfv-nsd', yang_type='container', is_config=True)

    nsd = __builtin__.property(_get_nsd, _set_nsd)

    _pyangbind_elements = OrderedDict([('nsd', nsd), ])


