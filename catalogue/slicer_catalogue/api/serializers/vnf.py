# -*- coding: utf-8 -*-
from operator import attrgetter
from pyangbind.lib.yangtypes import RestrictedPrecisionDecimalType
from pyangbind.lib.yangtypes import RestrictedClassType
from pyangbind.lib.yangtypes import TypedListType
from pyangbind.lib.yangtypes import YANGBool
from pyangbind.lib.yangtypes import YANGListType
from pyangbind.lib.yangtypes import YANGDynClass
from pyangbind.lib.yangtypes import ReferenceType
from pyangbind.lib.base import PybindBase
from collections import OrderedDict
from decimal import Decimal
from bitarray import bitarray
from marshmallow import Schema
from marshmallow.fields import String, Dict, Url
import six

# PY3 support of some PY2 keywords (needs improved)
if six.PY3:
    import builtins as __builtin__

    long = int
elif six.PY2:
    import __builtin__


class OnBoardVnfPackageRequestSerializer(Schema):
    name = String(required=True, error_messages={"required": "On board VNF package request without name"})
    version = String(required=True, error_messages={"required": "On board VNF package request without version"})
    provider = String(required=True, error_messages={"required": "On board VNF package request without provider"})
    checksum = String(required=True, error_messages={"required": "On board VNF package request without checksum"})
    user_defined_data = Dict(keys=String(), values=String())
    vnf_package_path = Url(required=True,
                           error_messages={"required": "On board VNF package request without package path"})


class additional_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module additional-info - based on the path /additional-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module alarm - based on the path /alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class alternative_images(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module alternative-images - based on the path /alternative-images. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class cloud_init(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module cloud-init - based on the path /cloud-init. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class common_augments(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module common-augments - based on the path /common-augments. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class day1_2(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module day1-2 - based on the path /day1-2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class epa(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module epa - based on the path /epa. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module interface - based on the path /interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ip_profiles(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ip-profiles - based on the path /ip-profiles. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class kdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module kdu - based on the path /kdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class mgmt_interface(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module mgmt-interface - based on the path /mgmt-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-configuration - based on the path /ns-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_various(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-various - based on the path /ns-various. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class ns_vld(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module ns-vld - based on the path /ns-vld. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class scaling(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module scaling - based on the path /scaling. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class various(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module various - based on the path /various. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class vip(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module vip - based on the path /vip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    _pyangbind_elements = {}


class yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/virtual-network-interface-requirement/network-interface-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'network-interface-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement', 'network-interface-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_vif_quota_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_vif_quota(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/virtual-network-interface-requirement/vif-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
  """
    __slots__ = ('_path_helper', '_extmethods', '__limit', '__reserve', '__shares',)

    _yang_name = 'vif-quota'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement', 'vif-quota']

    def _get_limit(self):
        """
    Getter method for limit, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        return self.__limit

    def _set_limit(self, v, load=False):
        """
    Setter method for limit, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="limit", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """limit must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__limit = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_limit(self):
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_reserve(self):
        """
    Getter method for reserve, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        return self.__reserve

    def _set_reserve(self, v, load=False):
        """
    Setter method for reserve, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="reserve", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """reserve must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__reserve = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_reserve(self):
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_shares(self):
        """
    Getter method for shares, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        return self.__shares

    def _set_shares(self, v, load=False):
        """
    Setter method for shares, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="shares", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """shares must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__shares = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_shares(self):
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    limit = __builtin__.property(_get_limit, _set_limit)
    reserve = __builtin__.property(_get_reserve, _set_reserve)
    shares = __builtin__.property(_get_shares, _set_shares)

    _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_virtual_interface_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_virtual_interface(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/virtual-network-interface-requirement/virtual-interface. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the virtual interface properties
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__vpci', '__bandwidth',)

    _yang_name = 'virtual-interface'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'PARAVIRT': {}, 'OM-MGMT': {},
                                                                             'PCI-PASSTHROUGH': {}, 'SR-IOV': {},
                                                                             'VIRTIO': {}, 'E1000': {}, 'RTL8139': {},
                                                                             'PCNET': {}}, ),
                                   default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                                   yang_type='enumeration', is_config=True)
        self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                                   yang_type='string', is_config=True)
        self.__bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bandwidth", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement', 'virtual-interface']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/type (enumeration)

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies the type of virtual interface
between VM and host.
PARAVIRT        : Use the default paravirtualized interface for the VIM (virtio, vmxnet3, etc.).
VIRTIO          : Deprecated! Use the traditional VIRTIO interface.
PCI-PASSTHROUGH : Use PCI-PASSTHROUGH interface.
SR-IOV          : Use SR-IOV interface.
E1000           : Emulate E1000 interface.
RTL8139         : Emulate RTL8139 interface.
PCNET           : Emulate PCNET interface.
OM-MGMT         : Deprecated! Use PARAVIRT instead and set the VNF management interface at vnfd:mgmt-interface:cp
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'PARAVIRT': {}, 'OM-MGMT': {},
                                                                          'PCI-PASSTHROUGH': {}, 'SR-IOV': {},
                                                                          'VIRTIO': {}, 'E1000': {}, 'RTL8139': {},
                                                                          'PCNET': {}}, ),
                             default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with enumeration""",
                'defined-type': "interface:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'PARAVIRT': {}, 'OM-MGMT': {}, 'PCI-PASSTHROUGH': {}, 'SR-IOV': {}, 'VIRTIO': {}, 'E1000': {}, 'RTL8139': {}, 'PCNET': {}},), default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='enumeration', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'PARAVIRT': {}, 'OM-MGMT': {},
                                                                             'PCI-PASSTHROUGH': {}, 'SR-IOV': {},
                                                                             'VIRTIO': {}, 'E1000': {}, 'RTL8139': {},
                                                                             'PCNET': {}}, ),
                                   default=six.text_type("PARAVIRT"), is_leaf=True, yang_name="type", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                                   yang_type='enumeration', is_config=True)

    def _get_vpci(self):
        """
    Getter method for vpci, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/vpci (string)

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        return self.__vpci

    def _set_vpci(self, v, load=False):
        """
    Setter method for vpci, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/vpci (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vpci is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vpci() directly.

    YANG Description: Specifies the virtual PCI address. Expressed in
the following format dddd:dd:dd.d. For example
0000:00:12.0. This information can be used to
pass as metadata during the VM creation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vpci", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vpci must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='string', is_config=True)""",
            })

        self.__vpci = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vpci(self):
        self.__vpci = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vpci", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                                   yang_type='string', is_config=True)

    def _get_bandwidth(self):
        """
    Getter method for bandwidth, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/bandwidth (uint64)

    YANG Description: Aggregate bandwidth of the NIC.
    """
        return self.__bandwidth

    def _set_bandwidth(self, v, load=False):
        """
    Setter method for bandwidth, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface/bandwidth (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bandwidth is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bandwidth() directly.

    YANG Description: Aggregate bandwidth of the NIC.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="bandwidth", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """bandwidth must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bandwidth", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='uint64', is_config=True)""",
            })

        self.__bandwidth = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_bandwidth(self):
        self.__bandwidth = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bandwidth", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='uint64',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    vpci = __builtin__.property(_get_vpci, _set_vpci)
    bandwidth = __builtin__.property(_get_bandwidth, _set_bandwidth)

    _pyangbind_elements = OrderedDict([('type', type), ('vpci', vpci), ('bandwidth', bandwidth), ])


class yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/virtual-network-interface-requirement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__description', '__support_mandatory',
        '__network_interface_requirements',
        '__vif_quota', '__position', '__ip_address', '__mac_address', '__virtual_interface',)

    _yang_name = 'virtual-network-interface-requirement'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                             defining_module='etsi-nfv-vnfd', yang_type='list',
                                                             is_config=True)
        self.__vif_quota = YANGDynClass(
            base=yc_vif_quota_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_vif_quota,
            is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)
        self.__position = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
            yang_type='uint32', is_config=True)
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="ip-address", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:interface',
                                         defining_module='interface', yang_type='inet:ip-address', is_config=True)
        self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:interface',
                                          defining_module='interface', yang_type='string', is_config=True)
        self.__virtual_interface = YANGDynClass(
            base=yc_virtual_interface_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_virtual_interface,
            is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'virtual-network-interface-requirement']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/support_mandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_network_interface_requirements(self):
        """
    Getter method for network_interface_requirements, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements (list)

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        return self.__network_interface_requirements

    def _set_network_interface_requirements(self, v, load=False):
        """
    Setter method for network_interface_requirements, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/network_interface_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_interface_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_interface_requirements() directly.

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                  yang_name="network-interface-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="network-interface-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_interface_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements, yang_name="network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__network_interface_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_interface_requirements(self):
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                             defining_module='etsi-nfv-vnfd', yang_type='list',
                                                             is_config=True)

    def _get_vif_quota(self):
        """
    Getter method for vif_quota, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota (container)

    YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
    """
        return self.__vif_quota

    def _set_vif_quota(self, v, load=False):
        """
    Setter method for vif_quota, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/vif_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vif_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vif_quota() directly.

    YANG Description: Virtual interfaces quota describes the virtual interface bandwidth resource allocation policy.
Limit and Reserve values are defined in Mbps
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_vif_quota_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_vif_quota,
                             is_container='container', yang_name="vif-quota", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vif_quota must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vif_quota_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_vif_quota, is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__vif_quota = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vif_quota(self):
        self.__vif_quota = YANGDynClass(
            base=yc_vif_quota_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_vif_quota,
            is_container='container', yang_name="vif-quota", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)

    def _get_position(self):
        """
    Getter method for position, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/position (uint32)

    YANG Description: Explicit Position of the interface within the list
    """
        return self.__position

    def _set_position(self, v, load=False):
        """
    Setter method for position, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/position (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_position is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_position() directly.

    YANG Description: Explicit Position of the interface within the list
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="position", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """position must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='uint32', is_config=True)""",
            })

        self.__position = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_position(self):
        self.__position = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="position", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
            yang_type='uint32', is_config=True)

    def _get_ip_address(self):
        """
    Getter method for ip_address, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/ip_address (inet:ip-address)

    YANG Description: IP address of the internal connection point
    """
        return self.__ip_address

    def _set_ip_address(self, v, load=False):
        """
    Setter method for ip_address, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/ip_address (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address() directly.

    YANG Description: IP address of the internal connection point
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
                'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                      RestrictedClassType(base_type=six.text_type, restriction_dict={
                                          'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                             is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='inet:ip-address', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address must be of a type compatible with inet:ip-address""",
                'defined-type': "inet:ip-address",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="ip-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='inet:ip-address', is_config=True)""",
            })

        self.__ip_address = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address(self):
        self.__ip_address = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="ip-address", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:interface',
                                         defining_module='interface', yang_type='inet:ip-address', is_config=True)

    def _get_mac_address(self):
        """
    Getter method for mac_address, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/mac_address (string)

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
        return self.__mac_address

    def _set_mac_address(self, v, load=False):
        """
    Setter method for mac_address, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/mac_address (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address() directly.

    YANG Description: MAC address of the interface.
Some VNFs require a specific MAC address to be configured
in the interface. While this is not recommended at all in
NFV environments, this parameter exists to allow those
scenarios.
This parameter will be likely deprecated in the future.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='string', is_config=True)""",
            })

        self.__mac_address = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address(self):
        self.__mac_address = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mac-address", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:interface',
                                          defining_module='interface', yang_type='string', is_config=True)

    def _get_virtual_interface(self):
        """
    Getter method for virtual_interface, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface (container)

    YANG Description: Container for the virtual interface properties
    """
        return self.__virtual_interface

    def _set_virtual_interface(self, v, load=False):
        """
    Setter method for virtual_interface, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement/virtual_interface (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_interface is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_interface() directly.

    YANG Description: Container for the virtual interface properties
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_virtual_interface_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_virtual_interface,
                             is_container='container', yang_name="virtual-interface", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:interface',
                             defining_module='interface', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_interface must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_interface_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_virtual_interface, is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='container', is_config=True)""",
            })

        self.__virtual_interface = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_interface(self):
        self.__virtual_interface = YANGDynClass(
            base=yc_virtual_interface_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement_virtual_interface,
            is_container='container', yang_name="virtual-interface", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:interface', defining_module='interface', yang_type='container',
            is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    network_interface_requirements = __builtin__.property(_get_network_interface_requirements,
                                                          _set_network_interface_requirements)
    vif_quota = __builtin__.property(_get_vif_quota, _set_vif_quota)
    position = __builtin__.property(_get_position, _set_position)
    ip_address = __builtin__.property(_get_ip_address, _set_ip_address)
    mac_address = __builtin__.property(_get_mac_address, _set_mac_address)
    virtual_interface = __builtin__.property(_get_virtual_interface, _set_virtual_interface)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('description', description), ('support_mandatory', support_mandatory),
         ('network_interface_requirements', network_interface_requirements), ('vif_quota', vif_quota),
         ('position', position), ('ip_address', ip_address), ('mac_address', mac_address),
         ('virtual_interface', virtual_interface), ])


class yc_l2_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l2_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/protocol/address-data/l2-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
  """
    __slots__ = ('_path_helper', '_extmethods', '__mac_address_assignment',)

    _yang_name = 'l2-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data', 'l2-address-data']

    def _get_mac_address_assignment(self):
        """
    Getter method for mac_address_assignment, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        return self.__mac_address_assignment

    def _set_mac_address_assignment(self, v, load=False):
        """
    Setter method for mac_address_assignment, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_assignment() directly.

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__mac_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address_assignment(self):
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                     is_config=True)

    mac_address_assignment = __builtin__.property(_get_mac_address_assignment, _set_mac_address_assignment)

    _pyangbind_elements = OrderedDict([('mac_address_assignment', mac_address_assignment), ])


class yc_l3_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l3_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/protocol/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__ip_address_assignment', '__floating_ip_activated', '__ip_address_type',
        '__number_of_ip_addresses',)

    _yang_name = 'l3-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data', 'l3-address-data']

    def _get_ip_address_assignment(self):
        """
    Getter method for ip_address_assignment, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility. 
    """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
    Setter method for ip_address_assignment, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility. 
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__ip_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)

    def _get_floating_ip_activated(self):
        """
    Getter method for floating_ip_activated, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
    Setter method for floating_ip_activated, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_activated must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_activated = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)

    def _get_ip_address_type(self):
        """
    Getter method for ip_address_type, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
    Setter method for ip_address_type, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
                             yang_name="ip-address-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_address_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)

    def _get_number_of_ip_addresses(self):
        """
    Getter method for number_of_ip_addresses, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
    Setter method for number_of_ip_addresses, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="number-of-ip-addresses",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_ip_addresses = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
    floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)

    _pyangbind_elements = OrderedDict(
        [('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated),
         ('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ])


class yc_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/protocol/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__l2_address_data', '__l3_address_data',)

    _yang_name = 'address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'protocol', 'address-data']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/type (identityref)

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
  • MAC address.
  • IP address.
  • Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
  • MAC address.
  • IP address.
  • Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)

    def _get_l2_address_data(self):
        """
    Getter method for l2_address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l2_address_data (container)

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
    Setter method for l2_address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l2_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
                             is_container='container', yang_name="l2-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l2_address_data, is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l2_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_l3_address_data(self):
        """
    Getter method for l3_address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data (container)
    """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
    Setter method for l3_address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
                             is_container='container', yang_name="l3-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l3_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [('type', type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_protocol_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
  """
    __slots__ = ('_path_helper', '_extmethods', '__associated_layer_protocol', '__address_data',)

    _yang_name = 'protocol'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd', 'protocol']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)

    def _get_address_data(self):
        """
    Getter method for address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
    Setter method for address_data, mapped from YANG variable /vnfd/vdu/int_cpd/protocol/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("type",
                                                  yc_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data,
                                                  yang_name="address-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='type',
                                                  extensions=None), is_container='list', yang_name="address-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("type",yc_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('address_data', address_data), ])


class yc_int_cpd_etsi_nfv_vnfd__vnfd_vdu_int_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/int-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
  """
    __slots__ = ('_path_helper', '_extmethods', '__int_virtual_link_desc', '__bitrate_requirement',
                 '__virtual_network_interface_requirement', '__nicio_requirements', '__order', '__id',
                 '__layer_protocol', '__role', '__description', '__protocol', '__trunk_mode',
                 '__security_group_rule_id', '__port_security_enabled', '__port_security_disable_strategy',)

    _yang_name = 'int-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                    is_config=True)
        self.__bitrate_requirement = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                    defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                    is_config=True)
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__order = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                             int_size=32)), is_leaf=False, yang_name="order", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='uint32', is_config=True)
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                     is_config=True)
        self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                                    yang_name="port-security-enabled", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                                    defining_module='various', yang_type='boolean', is_config=True)
        self.__port_security_disable_strategy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
            default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'int-cpd']

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /vnfd/vdu/int_cpd/int_virtual_link_desc (leafref)

    YANG Description: Reference of the internal VLD which this internal CPD
connects to.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /vnfd/vdu/int_cpd/int_virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Reference of the internal VLD which this internal CPD
connects to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                    is_config=True)

    def _get_bitrate_requirement(self):
        """
    Getter method for bitrate_requirement, mapped from YANG variable /vnfd/vdu/int_cpd/bitrate_requirement (uint64)

    YANG Description: Bitrate requirement on this CP.
    """
        return self.__bitrate_requirement

    def _set_bitrate_requirement(self, v, load=False):
        """
    Setter method for bitrate_requirement, mapped from YANG variable /vnfd/vdu/int_cpd/bitrate_requirement (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bitrate_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bitrate_requirement() directly.

    YANG Description: Bitrate requirement on this CP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="bitrate-requirement",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """bitrate_requirement must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__bitrate_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_bitrate_requirement(self):
        self.__bitrate_requirement = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="bitrate-requirement", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    def _get_virtual_network_interface_requirement(self):
        """
    Getter method for virtual_network_interface_requirement, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement (list)

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        return self.__virtual_network_interface_requirement

    def _set_virtual_network_interface_requirement(self, v, load=False):
        """
    Setter method for virtual_network_interface_requirement, mapped from YANG variable /vnfd/vdu/int_cpd/virtual_network_interface_requirement (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_interface_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_interface_requirement() directly.

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                  yang_name="virtual-network-interface-requirement", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="virtual-network-interface-requirement", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_network_interface_requirement must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement, yang_name="virtual-network-interface-requirement", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_network_interface_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_network_interface_requirement(self):
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_vdu_int_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                    defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                    is_config=True)

    def _get_nicio_requirements(self):
        """
    Getter method for nicio_requirements, mapped from YANG variable /vnfd/vdu/int_cpd/nicio_requirements (leafref)

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        return self.__nicio_requirements

    def _set_nicio_requirements(self, v, load=False):
        """
    Setter method for nicio_requirements, mapped from YANG variable /vnfd/vdu/int_cpd/nicio_requirements (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nicio_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nicio_requirements() directly.

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nicio_requirements must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__nicio_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nicio_requirements(self):
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_order(self):
        """
    Getter method for order, mapped from YANG variable /vnfd/vdu/int_cpd/order (uint32)

    YANG Description: The order of the NIC to be assigned on the compute
instance (e.g. 2 for eth2).

Note: when binding more than one port to a single
compute (aka multi vNICs) and ordering is desired, it
is mandatory that all ports will be set with an order
value. The order values shall represent a positive,
arithmetic progression that starts with 0 (i.e. 0, 1,
2,..., n).

If the property is not present, it shall be left to the
VIM to assign a value when creating the instance.
    """
        return self.__order

    def _set_order(self, v, load=False):
        """
    Setter method for order, mapped from YANG variable /vnfd/vdu/int_cpd/order (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_order() directly.

    YANG Description: The order of the NIC to be assigned on the compute
instance (e.g. 2 for eth2).

Note: when binding more than one port to a single
compute (aka multi vNICs) and ordering is desired, it
is mandatory that all ports will be set with an order
value. The order values shall represent a positive,
arithmetic progression that starts with 0 (i.e. 0, 1,
2,..., n).

If the property is not present, it shall be left to the
VIM to assign a value when creating the instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                 int_size=32)), is_leaf=False, yang_name="order", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """order must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)), is_leaf=False, yang_name="order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__order = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_order(self):
        self.__order = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                             int_size=32)), is_leaf=False, yang_name="order", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='uint32', is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/vdu/int_cpd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/vdu/int_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /vnfd/vdu/int_cpd/layer_protocol (identityref)

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /vnfd/vdu/int_cpd/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)

    def _get_role(self):
        """
    Getter method for role, mapped from YANG variable /vnfd/vdu/int_cpd/role (identityref)

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        return self.__role

    def _set_role(self, v, load=False):
        """
    Setter method for role, mapped from YANG variable /vnfd/vdu/int_cpd/role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """role must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__role = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_role(self):
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/vdu/int_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/vdu/int_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /vnfd/vdu/int_cpd/protocol (list)

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /vnfd/vdu/int_cpd/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("associated_layer_protocol",
                                                  yc_protocol_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol,
                                                  yang_name="protocol", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='associated-layer-protocol', extensions=None),
                             is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_protocol_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_vnfd__vnfd_vdu_int_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_trunk_mode(self):
        """
    Getter method for trunk_mode, mapped from YANG variable /vnfd/vdu/int_cpd/trunk_mode (boolean)

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
    Setter method for trunk_mode, mapped from YANG variable /vnfd/vdu/int_cpd/trunk_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_mode() directly.

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trunk_mode must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__trunk_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_security_group_rule_id(self):
        """
    Getter method for security_group_rule_id, mapped from YANG variable /vnfd/vdu/int_cpd/security_group_rule_id (leafref)

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        return self.__security_group_rule_id

    def _set_security_group_rule_id(self, v, load=False):
        """
    Setter method for security_group_rule_id, mapped from YANG variable /vnfd/vdu/int_cpd/security_group_rule_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule_id() directly.

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__security_group_rule_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule_id(self):
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                     is_config=True)

    def _get_port_security_enabled(self):
        """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd/vdu/int_cpd/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
        return self.__port_security_enabled

    def _set_port_security_enabled(self, v, load=False):
        """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd/vdu/int_cpd/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True,
                             yang_name="port-security-enabled", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_security_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='boolean', is_config=True)""",
            })

        self.__port_security_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_security_enabled(self):
        self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                                    yang_name="port-security-enabled", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                                    defining_module='various', yang_type='boolean', is_config=True)

    def _get_port_security_disable_strategy(self):
        """
    Getter method for port_security_disable_strategy, mapped from YANG variable /vnfd/vdu/int_cpd/port_security_disable_strategy (enumeration)

    YANG Description: Strategy to disable port security, either Enables the port security for the port.
full                : disable port security in the whole port
allow-address-pairs : allow address pairs for virtual IP (any virtual IP can be configured)
    """
        return self.__port_security_disable_strategy

    def _set_port_security_disable_strategy(self, v, load=False):
        """
    Setter method for port_security_disable_strategy, mapped from YANG variable /vnfd/vdu/int_cpd/port_security_disable_strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_disable_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_disable_strategy() directly.

    YANG Description: Strategy to disable port security, either Enables the port security for the port.
full                : disable port security in the whole port
allow-address-pairs : allow address pairs for virtual IP (any virtual IP can be configured)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
                             default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                             defining_module='various', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_security_disable_strategy must be of a type compatible with enumeration""",
                'defined-type': "various:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'full': {}, 'allow-address-pairs': {}},), default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration', is_config=True)""",
            })

        self.__port_security_disable_strategy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_security_disable_strategy(self):
        self.__port_security_disable_strategy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
            default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration',
            is_config=True)

    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    bitrate_requirement = __builtin__.property(_get_bitrate_requirement, _set_bitrate_requirement)
    virtual_network_interface_requirement = __builtin__.property(_get_virtual_network_interface_requirement,
                                                                 _set_virtual_network_interface_requirement)
    nicio_requirements = __builtin__.property(_get_nicio_requirements, _set_nicio_requirements)
    order = __builtin__.property(_get_order, _set_order)
    id = __builtin__.property(_get_id, _set_id)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    role = __builtin__.property(_get_role, _set_role)
    description = __builtin__.property(_get_description, _set_description)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)
    security_group_rule_id = __builtin__.property(_get_security_group_rule_id, _set_security_group_rule_id)
    port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
    port_security_disable_strategy = __builtin__.property(_get_port_security_disable_strategy,
                                                          _set_port_security_disable_strategy)

    _pyangbind_elements = OrderedDict(
        [('int_virtual_link_desc', int_virtual_link_desc), ('bitrate_requirement', bitrate_requirement),
         ('virtual_network_interface_requirement', virtual_network_interface_requirement),
         ('nicio_requirements', nicio_requirements), ('order', order), ('id', id), ('layer_protocol', layer_protocol),
         ('role', role), ('description', description), ('protocol', protocol), ('trunk_mode', trunk_mode),
         ('security_group_rule_id', security_group_rule_id), ('port_security_enabled', port_security_enabled),
         ('port_security_disable_strategy', port_security_disable_strategy), ])


class yc_boot_order_etsi_nfv_vnfd__vnfd_vdu_boot_order(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/boot-order. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'boot-order'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'boot-order']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/vdu/boot_order/key (uint32)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/vdu/boot_order/key (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/vdu/boot_order/value (leafref)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/vdu/boot_order/value (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='leafref', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_vdu_monitoring_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/monitoring-parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'monitoring-parameter']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/vdu/monitoring_parameter/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/vdu/monitoring_parameter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/vdu/monitoring_parameter/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/vdu/monitoring_parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /vnfd/vdu/monitoring_parameter/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /vnfd/vdu/monitoring_parameter/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /vnfd/vdu/monitoring_parameter/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /vnfd/vdu/monitoring_parameter/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_configurable_properties_etsi_nfv_vnfd__vnfd_vdu_configurable_properties(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/configurable-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'configurable-properties'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'configurable-properties']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/vdu/configurable_properties/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/vdu/configurable_properties/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/vdu/configurable_properties/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/vdu/configurable_properties/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_ok_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_ok(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/alarm/actions/ok. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__url',)

    _yang_name = 'ok'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'alarm', 'actions', 'ok']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/ok/url (string)
    """
        return self.__url

    def _set_url(self, v, load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/ok/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__url = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

    url = __builtin__.property(_get_url, _set_url)

    _pyangbind_elements = OrderedDict([('url', url), ])


class yc_insufficient_data_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_insufficient_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/alarm/actions/insufficient-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__url',)

    _yang_name = 'insufficient-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'alarm', 'actions', 'insufficient-data']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/insufficient_data/url (string)
    """
        return self.__url

    def _set_url(self, v, load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/insufficient_data/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__url = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

    url = __builtin__.property(_get_url, _set_url)

    _pyangbind_elements = OrderedDict([('url', url), ])


class yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/alarm/actions/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__url',)

    _yang_name = 'alarm'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'alarm', 'actions', 'alarm']

    def _get_url(self):
        """
    Getter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/alarm/url (string)
    """
        return self.__url

    def _set_url(self, v, load=False):
        """
    Setter method for url, mapped from YANG variable /vnfd/vdu/alarm/actions/alarm/url (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_url is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_url() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """url must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__url = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_url(self):
        self.__url = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="url", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                  yang_type='string', is_config=True)

    url = __builtin__.property(_get_url, _set_url)

    _pyangbind_elements = OrderedDict([('url', url), ])


class yc_actions_etsi_nfv_vnfd__vnfd_vdu_alarm_actions(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/alarm/actions. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__ok', '__insufficient_data', '__alarm',)

    _yang_name = 'actions'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ok = YANGDynClass(
            base=YANGListType("url", yc_ok_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url',
                              extensions=None), is_container='list', yang_name="ok", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)
        self.__insufficient_data = YANGDynClass(
            base=YANGListType("url", yc_insufficient_data_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_insufficient_data,
                              yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list',
            yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
            yang_type='list', is_config=True)
        self.__alarm = YANGDynClass(
            base=YANGListType("url", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_alarm, yang_name="alarm",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'alarm', 'actions']

    def _get_ok(self):
        """
    Getter method for ok, mapped from YANG variable /vnfd/vdu/alarm/actions/ok (list)
    """
        return self.__ok

    def _set_ok(self, v, load=False):
        """
    Setter method for ok, mapped from YANG variable /vnfd/vdu/alarm/actions/ok (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ok is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ok() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("url", yc_ok_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_ok, yang_name="ok",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='url', extensions=None),
                             is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ok must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_ok_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="ok", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)""",
            })

        self.__ok = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ok(self):
        self.__ok = YANGDynClass(
            base=YANGListType("url", yc_ok_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_ok, yang_name="ok", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url',
                              extensions=None), is_container='list', yang_name="ok", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)

    def _get_insufficient_data(self):
        """
    Getter method for insufficient_data, mapped from YANG variable /vnfd/vdu/alarm/actions/insufficient_data (list)
    """
        return self.__insufficient_data

    def _set_insufficient_data(self, v, load=False):
        """
    Setter method for insufficient_data, mapped from YANG variable /vnfd/vdu/alarm/actions/insufficient_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_insufficient_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_insufficient_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("url",
                                                  yc_insufficient_data_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_insufficient_data,
                                                  yang_name="insufficient-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='url',
                                                  extensions=None), is_container='list', yang_name="insufficient-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm',
                             defining_module='alarm', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """insufficient_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_insufficient_data_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_insufficient_data, yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)""",
            })

        self.__insufficient_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_insufficient_data(self):
        self.__insufficient_data = YANGDynClass(
            base=YANGListType("url", yc_insufficient_data_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_insufficient_data,
                              yang_name="insufficient-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list',
            yang_name="insufficient-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
            yang_type='list', is_config=True)

    def _get_alarm(self):
        """
    Getter method for alarm, mapped from YANG variable /vnfd/vdu/alarm/actions/alarm (list)
    """
        return self.__alarm

    def _set_alarm(self, v, load=False):
        """
    Setter method for alarm, mapped from YANG variable /vnfd/vdu/alarm/actions/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("url", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_alarm,
                                                  yang_name="alarm", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='url',
                                                  extensions=None), is_container='list', yang_name="alarm", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """alarm must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("url",yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)""",
            })

        self.__alarm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_alarm(self):
        self.__alarm = YANGDynClass(
            base=YANGListType("url", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm_actions_alarm, yang_name="alarm",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='url', extensions=None), is_container='list', yang_name="alarm", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)

    ok = __builtin__.property(_get_ok, _set_ok)
    insufficient_data = __builtin__.property(_get_insufficient_data, _set_insufficient_data)
    alarm = __builtin__.property(_get_alarm, _set_alarm)

    _pyangbind_elements = OrderedDict([('ok', ok), ('insufficient_data', insufficient_data), ('alarm', alarm), ])


class yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/alarm. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__alarm_id', '__vnf_monitoring_param_ref', '__name', '__description',
        '__vdur_id',
        '__actions', '__repeat', '__enabled', '__severity', '__statistic', '__operation', '__value', '__period',
        '__evaluations',)

    _yang_name = 'alarm'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__alarm_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                       defining_module='alarm', yang_type='string', is_config=True)
        self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="vnf-monitoring-param-ref", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True,
                                                       namespace='urn:etsi:osm:yang:augments:alarm',
                                                       defining_module='alarm', yang_type='leafref', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                          defining_module='alarm', yang_type='string', is_config=True)
        self.__vdur_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                      yang_type='string', is_config=True)
        self.__actions = YANGDynClass(base=yc_actions_etsi_nfv_vnfd__vnfd_vdu_alarm_actions, is_container='container',
                                      yang_name="actions", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                      namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                      yang_type='container', is_config=True)
        self.__repeat = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                     defining_module='alarm', yang_type='boolean', is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled",
                                      parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                      register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                      defining_module='alarm', yang_type='boolean', is_config=True)
        self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'LOW': {}, 'MODERATE': {},
                                                                                 'CRITICAL': {}}, ), is_leaf=True,
                                       yang_name="severity", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                       yang_type='alarm-severity-type', is_config=True)
        self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'AVERAGE': {}, 'MINIMUM': {},
                                                                                  'MAXIMUM': {}, 'COUNT': {},
                                                                                  'SUM': {}}, ), is_leaf=True,
                                        yang_name="statistic", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                        yang_type='alarm-statistic-type', is_config=True)
        self.__operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'GE': {}, 'LE': {}, 'GT': {},
                                                                                  'LT': {}, 'EQ': {}}, ), is_leaf=True,
                                        yang_name="operation", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                        yang_type='relational-operation-type', is_config=True)
        self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                    defining_module='alarm', yang_type='decimal64', is_config=True)
        self.__period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
            yang_type='uint32', is_config=True)
        self.__evaluations = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
            defining_module='alarm', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'alarm']

    def _get_alarm_id(self):
        """
    Getter method for alarm_id, mapped from YANG variable /vnfd/vdu/alarm/alarm_id (string)

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
        return self.__alarm_id

    def _set_alarm_id(self, v, load=False):
        """
    Setter method for alarm_id, mapped from YANG variable /vnfd/vdu/alarm/alarm_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm_id() directly.

    YANG Description: This field is reserved for the identifier assigned by the VIM provider
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """alarm_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__alarm_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_alarm_id(self):
        self.__alarm_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="alarm-id", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       is_keyval=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                       defining_module='alarm', yang_type='string', is_config=True)

    def _get_vnf_monitoring_param_ref(self):
        """
    Getter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd/vdu/alarm/vnf_monitoring_param_ref (leafref)

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        return self.__vnf_monitoring_param_ref

    def _set_vnf_monitoring_param_ref(self, v, load=False):
        """
    Setter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd/vdu/alarm/vnf_monitoring_param_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_monitoring_param_ref() directly.

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='leafref',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_monitoring_param_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_monitoring_param_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_monitoring_param_ref(self):
        self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="vnf-monitoring-param-ref", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True,
                                                       namespace='urn:etsi:osm:yang:augments:alarm',
                                                       defining_module='alarm', yang_type='leafref', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/vdu/alarm/name (string)

    YANG Description: A human readable string to identify the alarm
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/vdu/alarm/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: A human readable string to identify the alarm
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/vdu/alarm/description (string)

    YANG Description: A description of this alarm
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/vdu/alarm/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: A description of this alarm
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                          defining_module='alarm', yang_type='string', is_config=True)

    def _get_vdur_id(self):
        """
    Getter method for vdur_id, mapped from YANG variable /vnfd/vdu/alarm/vdur_id (string)

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
        return self.__vdur_id

    def _set_vdur_id(self, v, load=False):
        """
    Setter method for vdur_id, mapped from YANG variable /vnfd/vdu/alarm/vdur_id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdur_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdur_id() directly.

    YANG Description: The identifier of the VDUR that the alarm is associated with
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdur_id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='string', is_config=True)""",
            })

        self.__vdur_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdur_id(self):
        self.__vdur_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdur-id", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                      yang_type='string', is_config=True)

    def _get_actions(self):
        """
    Getter method for actions, mapped from YANG variable /vnfd/vdu/alarm/actions (container)
    """
        return self.__actions

    def _set_actions(self, v, load=False):
        """
    Setter method for actions, mapped from YANG variable /vnfd/vdu/alarm/actions (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_actions is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_actions() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_actions_etsi_nfv_vnfd__vnfd_vdu_alarm_actions, is_container='container',
                             yang_name="actions", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """actions must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_actions_etsi_nfv_vnfd__vnfd_vdu_alarm_actions, is_container='container', yang_name="actions", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='container', is_config=True)""",
            })

        self.__actions = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_actions(self):
        self.__actions = YANGDynClass(base=yc_actions_etsi_nfv_vnfd__vnfd_vdu_alarm_actions, is_container='container',
                                      yang_name="actions", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                      namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                      yang_type='container', is_config=True)

    def _get_repeat(self):
        """
    Getter method for repeat, mapped from YANG variable /vnfd/vdu/alarm/repeat (boolean)

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
        return self.__repeat

    def _set_repeat(self, v, load=False):
        """
    Setter method for repeat, mapped from YANG variable /vnfd/vdu/alarm/repeat (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_repeat is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_repeat() directly.

    YANG Description: This flag indicates whether the alarm should be repeatedly emitted
while the associated threshold has been crossed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='boolean',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """repeat must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='boolean', is_config=True)""",
            })

        self.__repeat = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_repeat(self):
        self.__repeat = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="repeat",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                     defining_module='alarm', yang_type='boolean', is_config=True)

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /vnfd/vdu/alarm/enabled (boolean)

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
        return self.__enabled

    def _set_enabled(self, v, load=False):
        """
    Setter method for enabled, mapped from YANG variable /vnfd/vdu/alarm/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: This flag indicates whether the alarm has been enabled or
disabled.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='boolean',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='boolean', is_config=True)""",
            })

        self.__enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled",
                                      parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                      register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                      defining_module='alarm', yang_type='boolean', is_config=True)

    def _get_severity(self):
        """
    Getter method for severity, mapped from YANG variable /vnfd/vdu/alarm/severity (alarm-severity-type)

    YANG Description: A measure of the importance or urgency of the alarm
    """
        return self.__severity

    def _set_severity(self, v, load=False):
        """
    Setter method for severity, mapped from YANG variable /vnfd/vdu/alarm/severity (alarm-severity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_severity is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_severity() directly.

    YANG Description: A measure of the importance or urgency of the alarm
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'LOW': {}, 'MODERATE': {}, 'CRITICAL': {}}, ),
                             is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='alarm-severity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """severity must be of a type compatible with alarm-severity-type""",
                'defined-type': "alarm:alarm-severity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LOW': {}, 'MODERATE': {}, 'CRITICAL': {}},), is_leaf=True, yang_name="severity", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='alarm-severity-type', is_config=True)""",
            })

        self.__severity = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_severity(self):
        self.__severity = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'LOW': {}, 'MODERATE': {},
                                                                                 'CRITICAL': {}}, ), is_leaf=True,
                                       yang_name="severity", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                       yang_type='alarm-severity-type', is_config=True)

    def _get_statistic(self):
        """
    Getter method for statistic, mapped from YANG variable /vnfd/vdu/alarm/statistic (alarm-statistic-type)

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
        return self.__statistic

    def _set_statistic(self, v, load=False):
        """
    Setter method for statistic, mapped from YANG variable /vnfd/vdu/alarm/statistic (alarm-statistic-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_statistic is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_statistic() directly.

    YANG Description: The type of metric statistic that is tracked by this alarm
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'AVERAGE': {}, 'MINIMUM': {}, 'MAXIMUM': {},
                                                                          'COUNT': {}, 'SUM': {}}, ), is_leaf=True,
                             yang_name="statistic", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='alarm-statistic-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """statistic must be of a type compatible with alarm-statistic-type""",
                'defined-type': "alarm:alarm-statistic-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AVERAGE': {}, 'MINIMUM': {}, 'MAXIMUM': {}, 'COUNT': {}, 'SUM': {}},), is_leaf=True, yang_name="statistic", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='alarm-statistic-type', is_config=True)""",
            })

        self.__statistic = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_statistic(self):
        self.__statistic = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'AVERAGE': {}, 'MINIMUM': {},
                                                                                  'MAXIMUM': {}, 'COUNT': {},
                                                                                  'SUM': {}}, ), is_leaf=True,
                                        yang_name="statistic", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                        yang_type='alarm-statistic-type', is_config=True)

    def _get_operation(self):
        """
    Getter method for operation, mapped from YANG variable /vnfd/vdu/alarm/operation (relational-operation-type)

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
        return self.__operation

    def _set_operation(self, v, load=False):
        """
    Setter method for operation, mapped from YANG variable /vnfd/vdu/alarm/operation (relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operation() directly.

    YANG Description: The relational operator used to define whether an alarm should be
triggered in certain scenarios, such as if the metric statistic
goes above or below a specified value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {},
                                                                          'EQ': {}}, ), is_leaf=True,
                             yang_name="operation", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='relational-operation-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """operation must be of a type compatible with relational-operation-type""",
                'defined-type': "alarm:relational-operation-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}},), is_leaf=True, yang_name="operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='relational-operation-type', is_config=True)""",
            })

        self.__operation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_operation(self):
        self.__operation = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'GE': {}, 'LE': {}, 'GT': {},
                                                                                  'LT': {}, 'EQ': {}}, ), is_leaf=True,
                                        yang_name="operation", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                                        yang_type='relational-operation-type', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/vdu/alarm/value (decimal64)

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/vdu/alarm/value (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: This value defines the threshold that, if crossed, will trigger
the alarm.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='decimal64', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=4), is_leaf=True, yang_name="value",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
                                    defining_module='alarm', yang_type='decimal64', is_config=True)

    def _get_period(self):
        """
    Getter method for period, mapped from YANG variable /vnfd/vdu/alarm/period (uint32)

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
        return self.__period

    def _set_period(self, v, load=False):
        """
    Setter method for period, mapped from YANG variable /vnfd/vdu/alarm/period (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_period() directly.

    YANG Description: The period defines the length of time (seconds) that the metric
data are collected over in oreder to evaluate the chosen
statistic.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="period", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='uint32',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """period must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='uint32', is_config=True)""",
            })

        self.__period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_period(self):
        self.__period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
            yang_type='uint32', is_config=True)

    def _get_evaluations(self):
        """
    Getter method for evaluations, mapped from YANG variable /vnfd/vdu/alarm/evaluations (uint32)

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
        return self.__evaluations

    def _set_evaluations(self, v, load=False):
        """
    Setter method for evaluations, mapped from YANG variable /vnfd/vdu/alarm/evaluations (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_evaluations is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_evaluations() directly.

    YANG Description: Defines the length of time (seconds) in which metric data are
collected in order to evaluate the chosen statistic.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="evaluations",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """evaluations must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='uint32', is_config=True)""",
            })

        self.__evaluations = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_evaluations(self):
        self.__evaluations = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="evaluations", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:alarm',
            defining_module='alarm', yang_type='uint32', is_config=True)

    alarm_id = __builtin__.property(_get_alarm_id, _set_alarm_id)
    vnf_monitoring_param_ref = __builtin__.property(_get_vnf_monitoring_param_ref, _set_vnf_monitoring_param_ref)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    vdur_id = __builtin__.property(_get_vdur_id, _set_vdur_id)
    actions = __builtin__.property(_get_actions, _set_actions)
    repeat = __builtin__.property(_get_repeat, _set_repeat)
    enabled = __builtin__.property(_get_enabled, _set_enabled)
    severity = __builtin__.property(_get_severity, _set_severity)
    statistic = __builtin__.property(_get_statistic, _set_statistic)
    operation = __builtin__.property(_get_operation, _set_operation)
    value = __builtin__.property(_get_value, _set_value)
    period = __builtin__.property(_get_period, _set_period)
    evaluations = __builtin__.property(_get_evaluations, _set_evaluations)

    _pyangbind_elements = OrderedDict(
        [('alarm_id', alarm_id), ('vnf_monitoring_param_ref', vnf_monitoring_param_ref), ('name', name),
         ('description', description), ('vdur_id', vdur_id), ('actions', actions), ('repeat', repeat),
         ('enabled', enabled), ('severity', severity), ('statistic', statistic), ('operation', operation),
         ('value', value), ('period', period), ('evaluations', evaluations), ])


class yc_supplemental_boot_data_etsi_nfv_vnfd__vnfd_vdu_supplemental_boot_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu/supplemental-boot-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__boot_data_drive',)

    _yang_name = 'supplemental-boot-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__boot_data_drive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                              yang_name="boot-data-drive", parent=self, path_helper=self._path_helper,
                                              extmethods=self._extmethods, register_paths=True,
                                              namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                              yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu', 'supplemental-boot-data']

    def _get_boot_data_drive(self):
        """
    Getter method for boot_data_drive, mapped from YANG variable /vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
        return self.__boot_data_drive

    def _set_boot_data_drive(self, v, load=False):
        """
    Setter method for boot_data_drive, mapped from YANG variable /vnfd/vdu/supplemental_boot_data/boot_data_drive (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_data_drive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_data_drive() directly.

    YANG Description: Some VIMs implement additional drives to host config-files or meta-data
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                             defining_module='various', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """boot_data_drive must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="boot-data-drive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='boolean', is_config=True)""",
            })

        self.__boot_data_drive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_boot_data_drive(self):
        self.__boot_data_drive = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                              yang_name="boot-data-drive", parent=self, path_helper=self._path_helper,
                                              extmethods=self._extmethods, register_paths=True,
                                              namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                              yang_type='boolean', is_config=True)

    boot_data_drive = __builtin__.property(_get_boot_data_drive, _set_boot_data_drive)

    _pyangbind_elements = OrderedDict([('boot_data_drive', boot_data_drive), ])


class yc_vdu_etsi_nfv_vnfd__vnfd_vdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__description', '__int_cpd', '__virtual_compute_desc',
        '__virtual_storage_desc', '__boot_order', '__sw_image_desc', '__nfvi_constraint', '__monitoring_parameter',
        '__configurable_properties', '__boot_data', '__alarm', '__alternative_sw_image_desc', '__cloud_init',
        '__cloud_init_file', '__pdu_type', '__supplemental_boot_data',)

    _yang_name = 'vdu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__int_cpd = YANGDynClass(
            base=YANGListType("id", yc_int_cpd_etsi_nfv_vnfd__vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="int-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__virtual_compute_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__virtual_storage_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="virtual-storage-desc", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__boot_order = YANGDynClass(
            base=YANGListType("key", yc_boot_order_etsi_nfv_vnfd__vnfd_vdu_boot_order, yang_name="boot-order",
                              parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper,
                              yang_keys='key', extensions=None), is_container='list', yang_name="boot-order",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                            defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__nfvi_constraint = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="nfvi-constraint", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_vdu_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__configurable_properties = YANGDynClass(
            base=YANGListType("key", yc_configurable_properties_etsi_nfv_vnfd__vnfd_vdu_configurable_properties,
                              yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__boot_data = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)
        self.__alarm = YANGDynClass(
            base=YANGListType("alarm_id", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm, yang_name="alarm", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list',
            is_config=True)
        self.__alternative_sw_image_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                        is_leaf=False, yang_name="alternative-sw-image-desc",
                                                        parent=self, path_helper=self._path_helper,
                                                        extmethods=self._extmethods, register_paths=True,
                                                        namespace='urn:etsi:osm:yang:alternative-images',
                                                        defining_module='alternative-images', yang_type='leafref',
                                                        is_config=True)
        self.__cloud_init = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self,
                                         choice=('cloud-init-input', 'inline'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:cloud-init',
                                         defining_module='cloud-init', yang_type='string', is_config=True)
        self.__cloud_init_file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file",
                                              parent=self, choice=('cloud-init-input', 'filename'),
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:osm:yang:augments:cloud-init',
                                              defining_module='cloud-init', yang_type='string', is_config=True)
        self.__pdu_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                       yang_type='string', is_config=True)
        self.__supplemental_boot_data = YANGDynClass(
            base=yc_supplemental_boot_data_etsi_nfv_vnfd__vnfd_vdu_supplemental_boot_data, is_container='container',
            yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:various',
            defining_module='various', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vdu']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/vdu/id (string)

    YANG Description: Unique identifier of this VDU in VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/vdu/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VDU in VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/vdu/name (string)

    YANG Description: Human readable name of the VDU.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/vdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/vdu/description (string)

    YANG Description: Human readable description of the VDU.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/vdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_int_cpd(self):
        """
    Getter method for int_cpd, mapped from YANG variable /vnfd/vdu/int_cpd (list)

    YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
    """
        return self.__int_cpd

    def _set_int_cpd(self, v, load=False):
        """
    Setter method for int_cpd, mapped from YANG variable /vnfd/vdu/int_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_cpd() directly.

    YANG Description: A internal-connection-point element is a type of
connection point and describes network connectivity
between a VDU instance and an internal Virtual Link or
an external connection point.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_int_cpd_etsi_nfv_vnfd__vnfd_vdu_int_cpd, yang_name="int-cpd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="int-cpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_cpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_int_cpd_etsi_nfv_vnfd__vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="int-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__int_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_cpd(self):
        self.__int_cpd = YANGDynClass(
            base=YANGListType("id", yc_int_cpd_etsi_nfv_vnfd__vnfd_vdu_int_cpd, yang_name="int-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="int-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_virtual_compute_desc(self):
        """
    Getter method for virtual_compute_desc, mapped from YANG variable /vnfd/vdu/virtual_compute_desc (leafref)

    YANG Description: Describes CPU, Memory and acceleration requirements of
the Virtualisation Container realizing this VDU.
    """
        return self.__virtual_compute_desc

    def _set_virtual_compute_desc(self, v, load=False):
        """
    Setter method for virtual_compute_desc, mapped from YANG variable /vnfd/vdu/virtual_compute_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_compute_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_compute_desc() directly.

    YANG Description: Describes CPU, Memory and acceleration requirements of
the Virtualisation Container realizing this VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_compute_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_compute_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_compute_desc(self):
        self.__virtual_compute_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="virtual-compute-desc",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_virtual_storage_desc(self):
        """
    Getter method for virtual_storage_desc, mapped from YANG variable /vnfd/vdu/virtual_storage_desc (leafref)

    YANG Description: Describes storage requirements for a VirtualStorage
instance attached to the virtualisation container
created from virtualComputeDesc defined for this VDU.
    """
        return self.__virtual_storage_desc

    def _set_virtual_storage_desc(self, v, load=False):
        """
    Setter method for virtual_storage_desc, mapped from YANG variable /vnfd/vdu/virtual_storage_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage_desc() directly.

    YANG Description: Describes storage requirements for a VirtualStorage
instance attached to the virtualisation container
created from virtualComputeDesc defined for this VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_storage_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_storage_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_storage_desc(self):
        self.__virtual_storage_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="virtual-storage-desc", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_boot_order(self):
        """
    Getter method for boot_order, mapped from YANG variable /vnfd/vdu/boot_order (list)

    YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
    """
        return self.__boot_order

    def _set_boot_order(self, v, load=False):
        """
    Setter method for boot_order, mapped from YANG variable /vnfd/vdu/boot_order (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_order is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_order() directly.

    YANG Description: The key indicates the boot index (lowest index defines
highest boot priority). The Value references a descriptor
from which a valid boot device is created e.g.
VirtualStorageDesc from which a VirtualStorage instance
is created.

Editor's note: The boot-order node requires further
study.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key", yc_boot_order_etsi_nfv_vnfd__vnfd_vdu_boot_order,
                                                  yang_name="boot-order", parent=self, is_container='list',
                                                  user_ordered=True, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="boot-order",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """boot_order must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_boot_order_etsi_nfv_vnfd__vnfd_vdu_boot_order, yang_name="boot-order", parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="boot-order", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__boot_order = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_boot_order(self):
        self.__boot_order = YANGDynClass(
            base=YANGListType("key", yc_boot_order_etsi_nfv_vnfd__vnfd_vdu_boot_order, yang_name="boot-order",
                              parent=self, is_container='list', user_ordered=True, path_helper=self._path_helper,
                              yang_keys='key', extensions=None), is_container='list', yang_name="boot-order",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /vnfd/vdu/sw_image_desc (leafref)

    YANG Description: Describes the software image which is directly loaded on
the virtualisation container realising this Vdu.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /vnfd/vdu/sw_image_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Describes the software image which is directly loaded on
the virtualisation container realising this Vdu.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                            defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_nfvi_constraint(self):
        """
    Getter method for nfvi_constraint, mapped from YANG variable /vnfd/vdu/nfvi_constraint (string)

    YANG Description: Describes constraints on the NFVI for the VNFC
instance(s) created from this Vdu. For example, aspects
of a secure hosting environment for the VNFC instance
that involve additional entities or processes.
    """
        return self.__nfvi_constraint

    def _set_nfvi_constraint(self, v, load=False):
        """
    Setter method for nfvi_constraint, mapped from YANG variable /vnfd/vdu/nfvi_constraint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nfvi_constraint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nfvi_constraint() directly.

    YANG Description: Describes constraints on the NFVI for the VNFC
instance(s) created from this Vdu. For example, aspects
of a secure hosting environment for the VNFC instance
that involve additional entities or processes.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="nfvi-constraint", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nfvi_constraint must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="nfvi-constraint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__nfvi_constraint = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nfvi_constraint(self):
        self.__nfvi_constraint = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="nfvi-constraint", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_monitoring_parameter(self):
        """
    Getter method for monitoring_parameter, mapped from YANG variable /vnfd/vdu/monitoring_parameter (list)
    """
        return self.__monitoring_parameter

    def _set_monitoring_parameter(self, v, load=False):
        """
    Setter method for monitoring_parameter, mapped from YANG variable /vnfd/vdu/monitoring_parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameter() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_vdu_monitoring_parameter,
                                                  yang_name="monitoring-parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_vdu_monitoring_parameter, yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameter(self):
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_vdu_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_configurable_properties(self):
        """
    Getter method for configurable_properties, mapped from YANG variable /vnfd/vdu/configurable_properties (list)

    YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
    """
        return self.__configurable_properties

    def _set_configurable_properties(self, v, load=False):
        """
    Setter method for configurable_properties, mapped from YANG variable /vnfd/vdu/configurable_properties (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable_properties() directly.

    YANG Description: It provides VNFC configurable properties that can be
modified using the ModifyVnfInfo operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_configurable_properties_etsi_nfv_vnfd__vnfd_vdu_configurable_properties,
                                                  yang_name="configurable-properties", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """configurable_properties must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_configurable_properties_etsi_nfv_vnfd__vnfd_vdu_configurable_properties, yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="configurable-properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__configurable_properties = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_configurable_properties(self):
        self.__configurable_properties = YANGDynClass(
            base=YANGListType("key", yc_configurable_properties_etsi_nfv_vnfd__vnfd_vdu_configurable_properties,
                              yang_name="configurable-properties", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_boot_data(self):
        """
    Getter method for boot_data, mapped from YANG variable /vnfd/vdu/boot_data (string)

    YANG Description: Contains a string or a URL to a file contained in the
VNF package used to customize a virtualised compute
resource at boot time. The bootData may contain variable
parts that are replaced by deployment specific values
before being sent to the VIM.
    """
        return self.__boot_data

    def _set_boot_data(self, v, load=False):
        """
    Setter method for boot_data, mapped from YANG variable /vnfd/vdu/boot_data (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_boot_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_boot_data() directly.

    YANG Description: Contains a string or a URL to a file contained in the
VNF package used to customize a virtualised compute
resource at boot time. The bootData may contain variable
parts that are replaced by deployment specific values
before being sent to the VIM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """boot_data must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__boot_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_boot_data(self):
        self.__boot_data = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="boot-data", parent=self,
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)

    def _get_alarm(self):
        """
    Getter method for alarm, mapped from YANG variable /vnfd/vdu/alarm (list)
    """
        return self.__alarm

    def _set_alarm(self, v, load=False):
        """
    Setter method for alarm, mapped from YANG variable /vnfd/vdu/alarm (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alarm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alarm() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("alarm_id", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm, yang_name="alarm",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='alarm-id', extensions=None),
                             is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """alarm must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("alarm_id",yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm, yang_name="alarm", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list', is_config=True)""",
            })

        self.__alarm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_alarm(self):
        self.__alarm = YANGDynClass(
            base=YANGListType("alarm_id", yc_alarm_etsi_nfv_vnfd__vnfd_vdu_alarm, yang_name="alarm", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='alarm-id', extensions=None), is_container='list', yang_name="alarm",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:osm:yang:augments:alarm', defining_module='alarm', yang_type='list',
            is_config=True)

    def _get_alternative_sw_image_desc(self):
        """
    Getter method for alternative_sw_image_desc, mapped from YANG variable /vnfd/vdu/alternative_sw_image_desc (leafref)

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
        return self.__alternative_sw_image_desc

    def _set_alternative_sw_image_desc(self, v, load=False):
        """
    Setter method for alternative_sw_image_desc, mapped from YANG variable /vnfd/vdu/alternative_sw_image_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_alternative_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_alternative_sw_image_desc() directly.

    YANG Description: List of alternative images per VIM type.
Different images can be used for specific types of VIMs instead
of the default image. This allows deployments in sites where the
image identifier in the VIM is given by the VIM provider and
cannot be modified.
If an alternative image is specified for a VIM type, it will prevail
over the default image
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="alternative-sw-image-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:alternative-images', defining_module='alternative-images',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """alternative_sw_image_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="alternative-sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:alternative-images', defining_module='alternative-images', yang_type='leafref', is_config=True)""",
            })

        self.__alternative_sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_alternative_sw_image_desc(self):
        self.__alternative_sw_image_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                        is_leaf=False, yang_name="alternative-sw-image-desc",
                                                        parent=self, path_helper=self._path_helper,
                                                        extmethods=self._extmethods, register_paths=True,
                                                        namespace='urn:etsi:osm:yang:alternative-images',
                                                        defining_module='alternative-images', yang_type='leafref',
                                                        is_config=True)

    def _get_cloud_init(self):
        """
    Getter method for cloud_init, mapped from YANG variable /vnfd/vdu/cloud_init (string)

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
        return self.__cloud_init

    def _set_cloud_init(self, v, load=False):
        """
    Setter method for cloud_init, mapped from YANG variable /vnfd/vdu/cloud_init (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init() directly.

    YANG Description: Contents of cloud-init script, provided inline, in cloud-config format
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self,
                             choice=('cloud-init-input', 'inline'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:cloud-init', defining_module='cloud-init',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud_init must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self, choice=('cloud-init-input', 'inline'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:cloud-init', defining_module='cloud-init', yang_type='string', is_config=True)""",
            })

        self.__cloud_init = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud_init(self):
        self.__cloud_init = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init", parent=self,
                                         choice=('cloud-init-input', 'inline'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:cloud-init',
                                         defining_module='cloud-init', yang_type='string', is_config=True)

    def _get_cloud_init_file(self):
        """
    Getter method for cloud_init_file, mapped from YANG variable /vnfd/vdu/cloud_init_file (string)

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
        return self.__cloud_init_file

    def _set_cloud_init_file(self, v, load=False):
        """
    Setter method for cloud_init_file, mapped from YANG variable /vnfd/vdu/cloud_init_file (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud_init_file is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud_init_file() directly.

    YANG Description: Name of file with contents of cloud-init script in cloud-config format
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self,
                             choice=('cloud-init-input', 'filename'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:cloud-init', defining_module='cloud-init',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud_init_file must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file", parent=self, choice=('cloud-init-input', 'filename'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:cloud-init', defining_module='cloud-init', yang_type='string', is_config=True)""",
            })

        self.__cloud_init_file = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud_init_file(self):
        self.__cloud_init_file = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cloud-init-file",
                                              parent=self, choice=('cloud-init-input', 'filename'),
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:osm:yang:augments:cloud-init',
                                              defining_module='cloud-init', yang_type='string', is_config=True)

    def _get_pdu_type(self):
        """
    Getter method for pdu_type, mapped from YANG variable /vnfd/vdu/pdu_type (string)

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
        return self.__pdu_type

    def _set_pdu_type(self, v, load=False):
        """
    Setter method for pdu_type, mapped from YANG variable /vnfd/vdu/pdu_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pdu_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pdu_type() directly.

    YANG Description: Type of PDU. If this field exists, the deployment unit must be
understood as a PDU, not as a VDU. This field is used to identify
the category of PDU instances to be used at instantiation time. For
the instantiation to be successful, there must be available
PDU instances of this type in the selected datacenter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pdu_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='string', is_config=True)""",
            })

        self.__pdu_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pdu_type(self):
        self.__pdu_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="pdu-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                       yang_type='string', is_config=True)

    def _get_supplemental_boot_data(self):
        """
    Getter method for supplemental_boot_data, mapped from YANG variable /vnfd/vdu/supplemental_boot_data (container)
    """
        return self.__supplemental_boot_data

    def _set_supplemental_boot_data(self, v, load=False):
        """
    Setter method for supplemental_boot_data, mapped from YANG variable /vnfd/vdu/supplemental_boot_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supplemental_boot_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supplemental_boot_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_supplemental_boot_data_etsi_nfv_vnfd__vnfd_vdu_supplemental_boot_data,
                             is_container='container', yang_name="supplemental-boot-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supplemental_boot_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_supplemental_boot_data_etsi_nfv_vnfd__vnfd_vdu_supplemental_boot_data, is_container='container', yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='container', is_config=True)""",
            })

        self.__supplemental_boot_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supplemental_boot_data(self):
        self.__supplemental_boot_data = YANGDynClass(
            base=yc_supplemental_boot_data_etsi_nfv_vnfd__vnfd_vdu_supplemental_boot_data, is_container='container',
            yang_name="supplemental-boot-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:various',
            defining_module='various', yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    int_cpd = __builtin__.property(_get_int_cpd, _set_int_cpd)
    virtual_compute_desc = __builtin__.property(_get_virtual_compute_desc, _set_virtual_compute_desc)
    virtual_storage_desc = __builtin__.property(_get_virtual_storage_desc, _set_virtual_storage_desc)
    boot_order = __builtin__.property(_get_boot_order, _set_boot_order)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)
    nfvi_constraint = __builtin__.property(_get_nfvi_constraint, _set_nfvi_constraint)
    monitoring_parameter = __builtin__.property(_get_monitoring_parameter, _set_monitoring_parameter)
    configurable_properties = __builtin__.property(_get_configurable_properties, _set_configurable_properties)
    boot_data = __builtin__.property(_get_boot_data, _set_boot_data)
    alarm = __builtin__.property(_get_alarm, _set_alarm)
    alternative_sw_image_desc = __builtin__.property(_get_alternative_sw_image_desc, _set_alternative_sw_image_desc)
    cloud_init = __builtin__.property(_get_cloud_init, _set_cloud_init)
    cloud_init_file = __builtin__.property(_get_cloud_init_file, _set_cloud_init_file)
    pdu_type = __builtin__.property(_get_pdu_type, _set_pdu_type)
    supplemental_boot_data = __builtin__.property(_get_supplemental_boot_data, _set_supplemental_boot_data)

    __choices__ = {'cloud-init-input': {'inline': ['cloud_init'], 'filename': ['cloud_init_file']}}
    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('description', description), ('int_cpd', int_cpd),
                                       ('virtual_compute_desc', virtual_compute_desc),
                                       ('virtual_storage_desc', virtual_storage_desc), ('boot_order', boot_order),
                                       ('sw_image_desc', sw_image_desc), ('nfvi_constraint', nfvi_constraint),
                                       ('monitoring_parameter', monitoring_parameter),
                                       ('configurable_properties', configurable_properties), ('boot_data', boot_data),
                                       ('alarm', alarm), ('alternative_sw_image_desc', alternative_sw_image_desc),
                                       ('cloud_init', cloud_init), ('cloud_init_file', cloud_init_file),
                                       ('pdu_type', pdu_type), ('supplemental_boot_data', supplemental_boot_data), ])


class yc_requirement_detail_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node_requirement_detail(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/logical-node/requirement-detail. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'requirement-detail'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'logical-node', 'requirement-detail']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_logical_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/logical-node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The logical node requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__requirement_detail',)

    _yang_name = 'logical-node'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__requirement_detail = YANGDynClass(base=YANGListType("key",
                                                                   yc_requirement_detail_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                                   yang_name="requirement-detail", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper, yang_keys='key',
                                                                   extensions=None), is_container='list',
                                                 yang_name="requirement-detail", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'logical-node']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/id (string)

    YANG Description: Identifies this set of logical node requirements.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies this set of logical node requirements.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_requirement_detail(self):
        """
    Getter method for requirement_detail, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail (list)

    YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
    """
        return self.__requirement_detail

    def _set_requirement_detail(self, v, load=False):
        """
    Setter method for requirement_detail, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node/requirement_detail (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_requirement_detail is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_requirement_detail() directly.

    YANG Description: The logical node-level compute, memory and I/O
requirements. An array of key-value pairs that
articulate the deployment requirements.

This could include the number of CPU cores on this
logical node, a memory configuration specific to a
logical node (e.g. such as available in the Linux
kernel via the libnuma library) or a requirement
related to the association of an I/O device with the
logical node.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_requirement_detail_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                  yang_name="requirement-detail", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="requirement-detail",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """requirement_detail must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_requirement_detail_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node_requirement_detail, yang_name="requirement-detail", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="requirement-detail", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__requirement_detail = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_requirement_detail(self):
        self.__requirement_detail = YANGDynClass(base=YANGListType("key",
                                                                   yc_requirement_detail_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node_requirement_detail,
                                                                   yang_name="requirement-detail", parent=self,
                                                                   is_container='list', user_ordered=False,
                                                                   path_helper=self._path_helper, yang_keys='key',
                                                                   extensions=None), is_container='list',
                                                 yang_name="requirement-detail", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, extensions=None,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    requirement_detail = __builtin__.property(_get_requirement_detail, _set_requirement_detail)

    _pyangbind_elements = OrderedDict([('id', id), ('requirement_detail', requirement_detail), ])


class yc_target_performance_parameters_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/request-additional-capability/target-performance-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'target-performance-parameters'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'request-additional-capability', 'target-performance-parameters']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_request_additional_capability_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/request-additional-capability. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__support_mandatory', '__min_version', '__preferred_version',
                 '__target_performance_parameters',)

    _yang_name = 'request-additional-capability'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__min_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__preferred_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",
                                                                              yc_target_performance_parameters_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                                              yang_name="target-performance-parameters",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='key', extensions=None),
                                                            is_container='list',
                                                            yang_name="target-performance-parameters", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='list',
                                                            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'request-additional-capability']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/name (string)

    YANG Description: Identifies a requested additional capability for the
VDU. ETSI GS NFV-IFA 002 [i.1] describes acceleration
capabilities.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identifies a requested additional capability for the
VDU. ETSI GS NFV-IFA 002 [i.1] describes acceleration
capabilities.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/support_mandatory (boolean)

    YANG Description: Indicates whether the requested additional capability
is mandatory for successful operation.
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether the requested additional capability
is mandatory for successful operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_min_version(self):
        """
    Getter method for min_version, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/min_version (string)

    YANG Description: Identifies the minimum version of the requested
additional capability.
    """
        return self.__min_version

    def _set_min_version(self, v, load=False):
        """
    Setter method for min_version, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/min_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_version() directly.

    YANG Description: Identifies the minimum version of the requested
additional capability.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__min_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_version(self):
        self.__min_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="min-version", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_preferred_version(self):
        """
    Getter method for preferred_version, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/preferred_version (string)

    YANG Description: Identifies the preferred version of the requested
additional capability.
    """
        return self.__preferred_version

    def _set_preferred_version(self, v, load=False):
        """
    Setter method for preferred_version, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/preferred_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_preferred_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_preferred_version() directly.

    YANG Description: Identifies the preferred version of the requested
additional capability.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="preferred-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """preferred_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__preferred_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_preferred_version(self):
        self.__preferred_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="preferred-version",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_target_performance_parameters(self):
        """
    Getter method for target_performance_parameters, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters (list)

    YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
    """
        return self.__target_performance_parameters

    def _set_target_performance_parameters(self, v, load=False):
        """
    Setter method for target_performance_parameters, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability/target_performance_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_target_performance_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_target_performance_parameters() directly.

    YANG Description: Identifies specific attributes, dependent on the
requested additional capability type.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_target_performance_parameters_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                  yang_name="target-performance-parameters", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="target-performance-parameters", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """target_performance_parameters must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_target_performance_parameters_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters, yang_name="target-performance-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="target-performance-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__target_performance_parameters = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_target_performance_parameters(self):
        self.__target_performance_parameters = YANGDynClass(base=YANGListType("key",
                                                                              yc_target_performance_parameters_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability_target_performance_parameters,
                                                                              yang_name="target-performance-parameters",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='key', extensions=None),
                                                            is_container='list',
                                                            yang_name="target-performance-parameters", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='list',
                                                            is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    min_version = __builtin__.property(_get_min_version, _set_min_version)
    preferred_version = __builtin__.property(_get_preferred_version, _set_preferred_version)
    target_performance_parameters = __builtin__.property(_get_target_performance_parameters,
                                                         _set_target_performance_parameters)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('support_mandatory', support_mandatory), ('min_version', min_version),
         ('preferred_version', preferred_version), ('target_performance_parameters', target_performance_parameters), ])


class yc_vdu_mem_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/vdu-mem-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pair requirements on the memory for
the VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-mem-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'vdu-mem-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_vcpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_vcpu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/numa-node-policy/node/vcpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VCPUs to allocate on
this NUMA node.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'vcpu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="id", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'numa-node-policy', 'node', 'vcpu']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/vcpu/id (uint64)

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/vcpu/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: List of VCPUs ids to allocate on
this NUMA node
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="id", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_paired_thread_ids_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads_paired_thread_ids(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/numa-node-policy/node/paired-threads/paired-thread-ids. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of thread pairs to use in case of paired-thread NUMA
  """
    __slots__ = ('_path_helper', '_extmethods', '__thread_a', '__thread_b',)

    _yang_name = 'paired-thread-ids'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__thread_a = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="thread-a", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)
        self.__thread_b = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="thread-b", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'numa-node-policy', 'node', 'paired-threads',
                    'paired-thread-ids']

    def _get_thread_a(self):
        """
    Getter method for thread_a, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    """
        return self.__thread_a

    def _set_thread_a(self, v, load=False):
        """
    Setter method for thread_a, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids/thread_a (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_a is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_a() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']},
                                                         int_size=8), is_leaf=True, yang_name="thread-a", parent=self,
                             choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """thread_a must be of a type compatible with uint8""",
                'defined-type': "uint8",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-a", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)""",
            })

        self.__thread_a = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_thread_a(self):
        self.__thread_a = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="thread-a", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)

    def _get_thread_b(self):
        """
    Getter method for thread_b, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    """
        return self.__thread_b

    def _set_thread_b(self, v, load=False):
        """
    Setter method for thread_b, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids/thread_b (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_b is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_b() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']},
                                                         int_size=8), is_leaf=True, yang_name="thread-b", parent=self,
                             choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """thread_b must be of a type compatible with uint8""",
                'defined-type': "uint8",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="thread-b", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)""",
            })

        self.__thread_b = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_thread_b(self):
        self.__thread_b = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="thread-b", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)

    thread_a = __builtin__.property(_get_thread_a, _set_thread_a)
    thread_b = __builtin__.property(_get_thread_b, _set_thread_b)

    __choices__ = {'om-numa-type': {'paired-threads': ['thread_a', 'thread_b']}}
    _pyangbind_elements = OrderedDict([('thread_a', thread_a), ('thread_b', thread_b), ])


class yc_paired_threads_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/numa-node-policy/node/paired-threads. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__num_paired_threads', '__paired_thread_ids',)

    _yang_name = 'paired-threads'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__num_paired_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-paired-threads", parent=self, choice=('om-numa-type', 'paired-threads'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)
        self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a",
                                                                  yc_paired_thread_ids_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads_paired_thread_ids,
                                                                  yang_name="paired-thread-ids", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='thread-a',
                                                                  extensions=None,
                                                                  choice=('om-numa-type', 'paired-threads')),
                                                is_container='list', yang_name="paired-thread-ids", parent=self,
                                                choice=('om-numa-type', 'paired-threads'),
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                                                yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'numa-node-policy', 'node', 'paired-threads']

    def _get_num_paired_threads(self):
        """
    Getter method for num_paired_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    """
        return self.__num_paired_threads

    def _set_num_paired_threads(self, v, load=False):
        """
    Setter method for num_paired_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/num_paired_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_paired_threads() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']},
                                                         int_size=8), is_leaf=True, yang_name="num-paired-threads",
                             parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """num_paired_threads must be of a type compatible with uint8""",
                'defined-type': "uint8",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-paired-threads", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)""",
            })

        self.__num_paired_threads = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_num_paired_threads(self):
        self.__num_paired_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-paired-threads", parent=self, choice=('om-numa-type', 'paired-threads'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)

    def _get_paired_thread_ids(self):
        """
    Getter method for paired_thread_ids, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids (list)

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
        return self.__paired_thread_ids

    def _set_paired_thread_ids(self, v, load=False):
        """
    Setter method for paired_thread_ids, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads/paired_thread_ids (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_thread_ids is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_thread_ids() directly.

    YANG Description: List of thread pairs to use in case of paired-thread NUMA
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("thread_a",
                                                  yc_paired_thread_ids_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads_paired_thread_ids,
                                                  yang_name="paired-thread-ids", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='thread-a', extensions=None,
                                                  choice=('om-numa-type', 'paired-threads')), is_container='list',
                             yang_name="paired-thread-ids", parent=self, choice=('om-numa-type', 'paired-threads'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """paired_thread_ids must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("thread_a",yc_paired_thread_ids_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads_paired_thread_ids, yang_name="paired-thread-ids", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='thread-a', extensions=None, choice=('om-numa-type', 'paired-threads')), is_container='list', yang_name="paired-thread-ids", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='list', is_config=True)""",
            })

        self.__paired_thread_ids = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_paired_thread_ids(self):
        self.__paired_thread_ids = YANGDynClass(base=YANGListType("thread_a",
                                                                  yc_paired_thread_ids_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads_paired_thread_ids,
                                                                  yang_name="paired-thread-ids", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='thread-a',
                                                                  extensions=None,
                                                                  choice=('om-numa-type', 'paired-threads')),
                                                is_container='list', yang_name="paired-thread-ids", parent=self,
                                                choice=('om-numa-type', 'paired-threads'),
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                                                yang_type='list', is_config=True)

    num_paired_threads = __builtin__.property(_get_num_paired_threads, _set_num_paired_threads)
    paired_thread_ids = __builtin__.property(_get_paired_thread_ids, _set_paired_thread_ids)

    __choices__ = {'om-numa-type': {'paired-threads': ['num_paired_threads', 'paired_thread_ids']}}
    _pyangbind_elements = OrderedDict(
        [('num_paired_threads', num_paired_threads), ('paired_thread_ids', paired_thread_ids), ])


class yc_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/numa-node-policy/node. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__vcpu', '__memory_mb', '__num_cores', '__paired_threads',
        '__num_threads',)

    _yang_name = 'node'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="id", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__vcpu = YANGDynClass(base=YANGListType("id",
                                                     yc_vcpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_vcpu,
                                                     yang_name="vcpu", parent=self, is_container='list',
                                                     user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                     extensions=None), is_container='list', yang_name="vcpu",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa',
                                   defining_module='epa', yang_type='list', is_config=True)
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="memory-mb", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__num_cores = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-cores", parent=self, choice=('om-numa-type', 'cores'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)
        self.__paired_threads = YANGDynClass(
            base=yc_paired_threads_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads,
            is_container='container', yang_name="paired-threads", parent=self,
            choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)
        self.__num_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-threads", parent=self, choice=('om-numa-type', 'threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'numa-node-policy', 'node']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/id (uint64)

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/id (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: NUMA node identification. Typically
it's 0 or 1
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="id", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_vcpu(self):
        """
    Getter method for vcpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/vcpu (list)

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
        return self.__vcpu

    def _set_vcpu(self, v, load=False):
        """
    Setter method for vcpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/vcpu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vcpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vcpu() directly.

    YANG Description: List of VCPUs to allocate on
this NUMA node.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_vcpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_vcpu,
                                                  yang_name="vcpu", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vcpu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vcpu must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vcpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_vcpu, yang_name="vcpu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vcpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='list', is_config=True)""",
            })

        self.__vcpu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vcpu(self):
        self.__vcpu = YANGDynClass(base=YANGListType("id",
                                                     yc_vcpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_vcpu,
                                                     yang_name="vcpu", parent=self, is_container='list',
                                                     user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                     extensions=None), is_container='list', yang_name="vcpu",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa',
                                   defining_module='epa', yang_type='list', is_config=True)

    def _get_memory_mb(self):
        """
    Getter method for memory_mb, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/memory_mb (uint64)

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
        return self.__memory_mb

    def _set_memory_mb(self, v, load=False):
        """
    Setter method for memory_mb, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/memory_mb (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_memory_mb is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_memory_mb() directly.

    YANG Description: Memory size expressed in MB
for this NUMA node.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="memory-mb", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """memory_mb must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="memory-mb", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__memory_mb = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_memory_mb(self):
        self.__memory_mb = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="memory-mb", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_num_cores(self):
        """
    Getter method for num_cores, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/num_cores (uint8)
    """
        return self.__num_cores

    def _set_num_cores(self, v, load=False):
        """
    Setter method for num_cores, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/num_cores (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_cores is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_cores() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']},
                                                         int_size=8), is_leaf=True, yang_name="num-cores", parent=self,
                             choice=('om-numa-type', 'cores'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """num_cores must be of a type compatible with uint8""",
                'defined-type': "uint8",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-cores", parent=self, choice=('om-numa-type', 'cores'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)""",
            })

        self.__num_cores = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_num_cores(self):
        self.__num_cores = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-cores", parent=self, choice=('om-numa-type', 'cores'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)

    def _get_paired_threads(self):
        """
    Getter method for paired_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads (container)
    """
        return self.__paired_threads

    def _set_paired_threads(self, v, load=False):
        """
    Setter method for paired_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/paired_threads (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_threads() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_paired_threads_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads,
                             is_container='container', yang_name="paired-threads", parent=self,
                             choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """paired_threads must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_paired_threads_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads, is_container='container', yang_name="paired-threads", parent=self, choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__paired_threads = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_paired_threads(self):
        self.__paired_threads = YANGDynClass(
            base=yc_paired_threads_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node_paired_threads,
            is_container='container', yang_name="paired-threads", parent=self,
            choice=('om-numa-type', 'paired-threads'), path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)

    def _get_num_threads(self):
        """
    Getter method for num_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/num_threads (uint8)
    """
        return self.__num_threads

    def _set_num_threads(self, v, load=False):
        """
    Setter method for num_threads, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node/num_threads (uint8)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_threads is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_threads() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']},
                                                         int_size=8), is_leaf=True, yang_name="num-threads",
                             parent=self, choice=('om-numa-type', 'threads'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """num_threads must be of a type compatible with uint8""",
                'defined-type': "uint8",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True, yang_name="num-threads", parent=self, choice=('om-numa-type', 'threads'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint8', is_config=True)""",
            })

        self.__num_threads = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_num_threads(self):
        self.__num_threads = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..255']}, int_size=8), is_leaf=True,
            yang_name="num-threads", parent=self, choice=('om-numa-type', 'threads'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='uint8', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vcpu = __builtin__.property(_get_vcpu, _set_vcpu)
    memory_mb = __builtin__.property(_get_memory_mb, _set_memory_mb)
    num_cores = __builtin__.property(_get_num_cores, _set_num_cores)
    paired_threads = __builtin__.property(_get_paired_threads, _set_paired_threads)
    num_threads = __builtin__.property(_get_num_threads, _set_num_threads)

    __choices__ = {
        'om-numa-type': {'cores': ['num_cores'], 'paired-threads': ['paired_threads'], 'threads': ['num_threads']}}
    _pyangbind_elements = OrderedDict([('id', id), ('vcpu', vcpu), ('memory_mb', memory_mb), ('num_cores', num_cores),
                                       ('paired_threads', paired_threads), ('num_threads', num_threads), ])


class yc_numa_node_policy_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/numa-node-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
  """
    __slots__ = ('_path_helper', '_extmethods', '__node_cnt', '__mem_policy', '__node',)

    _yang_name = 'numa-node-policy'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__node_cnt = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="node-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint16',
            is_config=True)
        self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'STRICT': {}, 'PREFERRED': {}}, ),
                                         is_leaf=True, yang_name="mem-policy", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
                                         defining_module='epa', yang_type='enumeration', is_config=True)
        self.__node = YANGDynClass(base=YANGListType("id",
                                                     yc_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node,
                                                     yang_name="node", parent=self, is_container='list',
                                                     user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                     extensions=None), is_container='list', yang_name="node",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa',
                                   defining_module='epa', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'numa-node-policy']

    def _get_node_cnt(self):
        """
    Getter method for node_cnt, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node_cnt (uint16)

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
        return self.__node_cnt

    def _set_node_cnt(self, v, load=False):
        """
    Setter method for node_cnt, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node_cnt (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node_cnt is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node_cnt() directly.

    YANG Description: The number of NUMA nodes to expose to the VM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16), is_leaf=True, yang_name="node-cnt", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint16',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node_cnt must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="node-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint16', is_config=True)""",
            })

        self.__node_cnt = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node_cnt(self):
        self.__node_cnt = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="node-cnt", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint16',
            is_config=True)

    def _get_mem_policy(self):
        """
    Getter method for mem_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/mem_policy (enumeration)

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
        return self.__mem_policy

    def _set_mem_policy(self, v, load=False):
        """
    Setter method for mem_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/mem_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_policy() directly.

    YANG Description: This policy specifies how the memory should
be allocated in a multi-node scenario.
STRICT    : The memory must be allocated
            strictly from the memory attached
            to the NUMA node.
PREFERRED : The memory should be allocated
            preferentially from the memory
            attached to the NUMA node
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRICT': {}, 'PREFERRED': {}}, ),
                             is_leaf=True, yang_name="mem-policy", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mem_policy must be of a type compatible with enumeration""",
                'defined-type': "epa:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRICT': {}, 'PREFERRED': {}},), is_leaf=True, yang_name="mem-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration', is_config=True)""",
            })

        self.__mem_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mem_policy(self):
        self.__mem_policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'STRICT': {}, 'PREFERRED': {}}, ),
                                         is_leaf=True, yang_name="mem-policy", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
                                         defining_module='epa', yang_type='enumeration', is_config=True)

    def _get_node(self):
        """
    Getter method for node, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node (list)
    """
        return self.__node

    def _set_node(self, v, load=False):
        """
    Setter method for node, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy/node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_node() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node,
                                                  yang_name="node", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="node", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """node must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node, yang_name="node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='list', is_config=True)""",
            })

        self.__node = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_node(self):
        self.__node = YANGDynClass(base=YANGListType("id",
                                                     yc_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy_node,
                                                     yang_name="node", parent=self, is_container='list',
                                                     user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                     extensions=None), is_container='list', yang_name="node",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa',
                                   defining_module='epa', yang_type='list', is_config=True)

    node_cnt = __builtin__.property(_get_node_cnt, _set_node_cnt)
    mem_policy = __builtin__.property(_get_mem_policy, _set_mem_policy)
    node = __builtin__.property(_get_node, _set_node)

    _pyangbind_elements = OrderedDict([('node_cnt', node_cnt), ('mem_policy', mem_policy), ('node', node), ])


class yc_mem_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_mem_quota(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory/mem-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
  """
    __slots__ = ('_path_helper', '_extmethods', '__limit', '__reserve', '__shares',)

    _yang_name = 'mem-quota'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory', 'mem-quota']

    def _get_limit(self):
        """
    Getter method for limit, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        return self.__limit

    def _set_limit(self, v, load=False):
        """
    Setter method for limit, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="limit", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """limit must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__limit = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_limit(self):
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_reserve(self):
        """
    Getter method for reserve, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        return self.__reserve

    def _set_reserve(self, v, load=False):
        """
    Setter method for reserve, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="reserve", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """reserve must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__reserve = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_reserve(self):
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_shares(self):
        """
    Getter method for shares, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        return self.__shares

    def _set_shares(self, v, load=False):
        """
    Setter method for shares, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="shares", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """shares must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__shares = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_shares(self):
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    limit = __builtin__.property(_get_limit, _set_limit)
    reserve = __builtin__.property(_get_reserve, _set_reserve)
    shares = __builtin__.property(_get_shares, _set_shares)

    _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_virtual_memory_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-memory. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual memory of the virtualised compute.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__size', '__over_subscription_policy', '__vdu_mem_requirements',
        '__numa_enabled',
        '__numa_node_policy', '__mempage_size', '__mem_quota',)

    _yang_name = 'virtual-memory'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__size = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                                   default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='decimal64', is_config=True)
        self.__over_subscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="over-subscription-policy", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='string',
                                                       is_config=True)
        self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_mem_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                                     yang_name="vdu-mem-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-mem-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__numa_node_policy = YANGDynClass(
            base=yc_numa_node_policy_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy,
            is_container='container', yang_name="numa-node-policy", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)
        self.__mempage_size = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'LARGE': {}, 'SMALL': {}, 'SIZE_2MB': {}, 'SIZE_1GB': {},
                                                      'PREFER_LARGE': {}}, ), is_leaf=True, yang_name="mempage-size",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration', is_config=True)
        self.__mem_quota = YANGDynClass(
            base=yc_mem_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_mem_quota,
            is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-memory']

    def _get_size(self):
        """
    Getter method for size, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/size (decimal64)

    YANG Description: Amount of virtual memory in GB.
    """
        return self.__size

    def _set_size(self, v, load=False):
        """
    Setter method for size, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/size (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: Amount of virtual memory in GB.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                             default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(1), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='decimal64', is_config=True)""",
            })

        self.__size = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                                   default=Decimal(1), is_leaf=True, yang_name="size", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='decimal64', is_config=True)

    def _get_over_subscription_policy(self):
        """
    Getter method for over_subscription_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/over_subscription_policy (string)

    YANG Description: The memory core oversubscription policy in terms of
virtual memory to physical memory on the platform.
The cardinality can be 0 during the allocation
request, if no particular value is requested.
    """
        return self.__over_subscription_policy

    def _set_over_subscription_policy(self, v, load=False):
        """
    Setter method for over_subscription_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/over_subscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_over_subscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_over_subscription_policy() directly.

    YANG Description: The memory core oversubscription policy in terms of
virtual memory to physical memory on the platform.
The cardinality can be 0 during the allocation
request, if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="over-subscription-policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """over_subscription_policy must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="over-subscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__over_subscription_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_over_subscription_policy(self):
        self.__over_subscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="over-subscription-policy", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='string',
                                                       is_config=True)

    def _get_vdu_mem_requirements(self):
        """
    Getter method for vdu_mem_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements (list)

    YANG Description: Array of key-value pair requirements on the memory for
the VDU.
    """
        return self.__vdu_mem_requirements

    def _set_vdu_mem_requirements(self, v, load=False):
        """
    Setter method for vdu_mem_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/vdu_mem_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_mem_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_mem_requirements() directly.

    YANG Description: Array of key-value pair requirements on the memory for
the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_mem_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                  yang_name="vdu-mem-requirements", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_mem_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_mem_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements, yang_name="vdu-mem-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-mem-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_mem_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_mem_requirements(self):
        self.__vdu_mem_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_mem_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_vdu_mem_requirements,
                                                                     yang_name="vdu-mem-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-mem-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_numa_enabled(self):
        """
    Getter method for numa_enabled, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_enabled (boolean)

    YANG Description: It specifies the memory allocation to be cognisant of
the relevant process/core allocation. The cardinality
can be 0 during the allocation request, if no
particular value is requested.
    """
        return self.__numa_enabled

    def _set_numa_enabled(self, v, load=False):
        """
    Setter method for numa_enabled, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_enabled() directly.

    YANG Description: It specifies the memory allocation to be cognisant of
the relevant process/core allocation. The cardinality
can be 0 during the allocation request, if no
particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """numa_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__numa_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_numa_enabled(self):
        self.__numa_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="numa-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_numa_node_policy(self):
        """
    Getter method for numa_node_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy (container)

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
        return self.__numa_node_policy

    def _set_numa_node_policy(self, v, load=False):
        """
    Setter method for numa_node_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/numa_node_policy (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_numa_node_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_numa_node_policy() directly.

    YANG Description: This policy defines NUMA topology of the
guest. Specifically identifies if the guest
should be run on a host with one NUMA
node or multiple NUMA nodes. As an example
a guest might need 8 VCPUs and 4 GB of
memory. However, it might need the VCPUs
and memory distributed across multiple
NUMA nodes. In this scenario, NUMA node
1 could run with 6 VCPUs and 3GB, and
NUMA node 2 could run with 2 VCPUs and
1GB.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_numa_node_policy_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy,
                             is_container='container', yang_name="numa-node-policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """numa_node_policy must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_numa_node_policy_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy, is_container='container', yang_name="numa-node-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__numa_node_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_numa_node_policy(self):
        self.__numa_node_policy = YANGDynClass(
            base=yc_numa_node_policy_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_numa_node_policy,
            is_container='container', yang_name="numa-node-policy", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)

    def _get_mempage_size(self):
        """
    Getter method for mempage_size, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mempage_size (enumeration)

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
        return self.__mempage_size

    def _set_mempage_size(self, v, load=False):
        """
    Setter method for mempage_size, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mempage_size (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mempage_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mempage_size() directly.

    YANG Description: Memory page allocation size. If a VM requires
hugepages, it should choose LARGE or SIZE_2MB
or SIZE_1GB. If the VM prefers hugepages it
should choose PREFER_LARGE.
LARGE        : Require hugepages (either 2MB or 1GB)
SMALL        : Doesn't require hugepages
SIZE_2MB     : Requires 2MB hugepages
SIZE_1GB     : Requires 1GB hugepages
PREFER_LARGE : Application prefers hugepages
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'LARGE': {}, 'SMALL': {}, 'SIZE_2MB': {},
                                                                          'SIZE_1GB': {}, 'PREFER_LARGE': {}}, ),
                             is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mempage_size must be of a type compatible with enumeration""",
                'defined-type': "epa:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'LARGE': {}, 'SMALL': {}, 'SIZE_2MB': {}, 'SIZE_1GB': {}, 'PREFER_LARGE': {}},), is_leaf=True, yang_name="mempage-size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration', is_config=True)""",
            })

        self.__mempage_size = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mempage_size(self):
        self.__mempage_size = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'LARGE': {}, 'SMALL': {}, 'SIZE_2MB': {}, 'SIZE_1GB': {},
                                                      'PREFER_LARGE': {}}, ), is_leaf=True, yang_name="mempage-size",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration', is_config=True)

    def _get_mem_quota(self):
        """
    Getter method for mem_quota, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota (container)

    YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
    """
        return self.__mem_quota

    def _set_mem_quota(self, v, load=False):
        """
    Setter method for mem_quota, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory/mem_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mem_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mem_quota() directly.

    YANG Description: Memory quota describes the memory resource allocation policy.
Limit and Reserve values are defined in MB
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_mem_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_mem_quota,
                             is_container='container', yang_name="mem-quota", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mem_quota must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_mem_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_mem_quota, is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__mem_quota = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mem_quota(self):
        self.__mem_quota = YANGDynClass(
            base=yc_mem_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory_mem_quota,
            is_container='container', yang_name="mem-quota", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)

    size = __builtin__.property(_get_size, _set_size)
    over_subscription_policy = __builtin__.property(_get_over_subscription_policy, _set_over_subscription_policy)
    vdu_mem_requirements = __builtin__.property(_get_vdu_mem_requirements, _set_vdu_mem_requirements)
    numa_enabled = __builtin__.property(_get_numa_enabled, _set_numa_enabled)
    numa_node_policy = __builtin__.property(_get_numa_node_policy, _set_numa_node_policy)
    mempage_size = __builtin__.property(_get_mempage_size, _set_mempage_size)
    mem_quota = __builtin__.property(_get_mem_quota, _set_mem_quota)

    _pyangbind_elements = OrderedDict([('size', size), ('over_subscription_policy', over_subscription_policy),
                                       ('vdu_mem_requirements', vdu_mem_requirements), ('numa_enabled', numa_enabled),
                                       ('numa_node_policy', numa_node_policy), ('mempage_size', mempage_size),
                                       ('mem_quota', mem_quota), ])


class yc_vdu_cpu_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-cpu/vdu-cpu-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-cpu-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-cpu', 'vdu-cpu-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_rule_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning_rule(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-cpu/pinning/rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-cpu', 'pinning', 'rule']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_pinning_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-cpu/pinning. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
  """
    __slots__ = ('_path_helper', '_extmethods', '__policy', '__rule', '__thread_policy',)

    _yang_name = 'pinning'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'static': {}, 'dynamic': {}}, ),
                                     default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)
        self.__rule = YANGDynClass(
            base=YANGListType("key", yc_rule_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                              yang_name="rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__thread_policy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AVOID': {}, 'SEPARATE': {}, 'ISOLATE': {}, 'PREFER': {}}, ),
            is_leaf=True, yang_name="thread-policy", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-cpu', 'pinning']

    def _get_policy(self):
        """
    Getter method for policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/policy (enumeration)

    YANG Description: The policy can take values of 'static' or 'dynamic'.
In case of 'static' the virtual CPU cores are
requested to be allocated to logical CPU cores
according to the rules defined in
virtualCpuPinningRules. In case of 'dynamic' the
allocation of virtual CPU cores to logical CPU cores
is decided by the VIM. (e.g. SMT (Simultaneous
MultiThreading) requirements).
    """
        return self.__policy

    def _set_policy(self, v, load=False):
        """
    Setter method for policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_policy() directly.

    YANG Description: The policy can take values of 'static' or 'dynamic'.
In case of 'static' the virtual CPU cores are
requested to be allocated to logical CPU cores
according to the rules defined in
virtualCpuPinningRules. In case of 'dynamic' the
allocation of virtual CPU cores to logical CPU cores
is decided by the VIM. (e.g. SMT (Simultaneous
MultiThreading) requirements).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'static': {}, 'dynamic': {}}, ),
                             default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """policy must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'static': {}, 'dynamic': {}},), default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_policy(self):
        self.__policy = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'static': {}, 'dynamic': {}}, ),
                                     default=six.text_type("dynamic"), is_leaf=True, yang_name="policy", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)

    def _get_rule(self):
        """
    Getter method for rule, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule (list)

    YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
    """
        return self.__rule

    def _set_rule(self, v, load=False):
        """
    Setter method for rule, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rule() directly.

    YANG Description: A list of rules that should be considered during the
allocation of the virtual CPUs to logical CPUs in case
of 'static' virtualCpuPinningPolicy.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_rule_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                                                  yang_name="rule", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_rule_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning_rule, yang_name="rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_rule(self):
        self.__rule = YANGDynClass(
            base=YANGListType("key", yc_rule_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning_rule,
                              yang_name="rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_thread_policy(self):
        """
    Getter method for thread_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/thread_policy (enumeration)

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
        return self.__thread_policy

    def _set_thread_policy(self, v, load=False):
        """
    Setter method for thread_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning/thread_policy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_thread_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_thread_policy() directly.

    YANG Description: CPU thread pinning policy describes how to
place the guest CPUs when the host supports
hyper threads:
AVOID   : Avoids placing a guest on a host
          with threads.
SEPARATE: Places vCPUs on separate cores,
          and avoids placing two vCPUs on
          two threads of same core.
ISOLATE : Places each vCPU on a different core,
          and places no vCPUs from a different
          guest on the same core.
PREFER  : Attempts to place vCPUs on threads
          of the same core.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'AVOID': {}, 'SEPARATE': {}, 'ISOLATE': {},
                                                                          'PREFER': {}}, ), is_leaf=True,
                             yang_name="thread-policy", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """thread_policy must be of a type compatible with enumeration""",
                'defined-type': "epa:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AVOID': {}, 'SEPARATE': {}, 'ISOLATE': {}, 'PREFER': {}},), is_leaf=True, yang_name="thread-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='enumeration', is_config=True)""",
            })

        self.__thread_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_thread_policy(self):
        self.__thread_policy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AVOID': {}, 'SEPARATE': {}, 'ISOLATE': {}, 'PREFER': {}}, ),
            is_leaf=True, yang_name="thread-policy", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa',
            defining_module='epa', yang_type='enumeration', is_config=True)

    policy = __builtin__.property(_get_policy, _set_policy)
    rule = __builtin__.property(_get_rule, _set_rule)
    thread_policy = __builtin__.property(_get_thread_policy, _set_thread_policy)

    _pyangbind_elements = OrderedDict([('policy', policy), ('rule', rule), ('thread_policy', thread_policy), ])


class yc_cpu_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_cpu_quota(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-cpu/cpu-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
  """
    __slots__ = ('_path_helper', '_extmethods', '__limit', '__reserve', '__shares',)

    _yang_name = 'cpu-quota'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-cpu', 'cpu-quota']

    def _get_limit(self):
        """
    Getter method for limit, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        return self.__limit

    def _set_limit(self, v, load=False):
        """
    Setter method for limit, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="limit", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """limit must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__limit = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_limit(self):
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_reserve(self):
        """
    Getter method for reserve, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        return self.__reserve

    def _set_reserve(self, v, load=False):
        """
    Setter method for reserve, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="reserve", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """reserve must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__reserve = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_reserve(self):
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_shares(self):
        """
    Getter method for shares, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        return self.__shares

    def _set_shares(self, v, load=False):
        """
    Setter method for shares, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="shares", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """shares must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__shares = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_shares(self):
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    limit = __builtin__.property(_get_limit, _set_limit)
    reserve = __builtin__.property(_get_reserve, _set_reserve)
    shares = __builtin__.property(_get_shares, _set_shares)

    _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_virtual_cpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc/virtual-cpu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The virtual CPU(s)of the virtualised compute.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__cpu_architecture', '__num_virtual_cpu', '__clock',
        '__oversubscription_policy',
        '__vdu_cpu_requirements', '__pinning', '__cpu_quota',)

    _yang_name = 'virtual-cpu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__cpu_architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__num_virtual_cpu = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={
            'range': ['0..65535']}, int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        self.__clock = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)
        self.__oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="oversubscription-policy", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                      defining_module='etsi-nfv-vnfd', yang_type='string',
                                                      is_config=True)
        self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_cpu_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                                     yang_name="vdu-cpu-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-cpu-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__pinning = YANGDynClass(base=yc_pinning_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning,
                                      is_container='container', yang_name="pinning", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        self.__cpu_quota = YANGDynClass(
            base=yc_cpu_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_cpu_quota, is_container='container',
            yang_name="cpu-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc', 'virtual-cpu']

    def _get_cpu_architecture(self):
        """
    Getter method for cpu_architecture, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_architecture (string)

    YANG Description: CPU architecture type. Examples are x86, ARM. The
cardinality can be 0 during the allocation request,
if no particular CPU architecture type is requested.
    """
        return self.__cpu_architecture

    def _set_cpu_architecture(self, v, load=False):
        """
    Setter method for cpu_architecture, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_architecture (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_architecture is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_architecture() directly.

    YANG Description: CPU architecture type. Examples are x86, ARM. The
cardinality can be 0 during the allocation request,
if no particular CPU architecture type is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpu-architecture", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpu_architecture must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__cpu_architecture = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpu_architecture(self):
        self.__cpu_architecture = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpu-architecture",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_num_virtual_cpu(self):
        """
    Getter method for num_virtual_cpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/num_virtual_cpu (uint16)

    YANG Description: Number of virtual CPUs.
    """
        return self.__num_virtual_cpu

    def _set_num_virtual_cpu(self, v, load=False):
        """
    Setter method for num_virtual_cpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/num_virtual_cpu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_num_virtual_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_num_virtual_cpu() directly.

    YANG Description: Number of virtual CPUs.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
                restriction_dict={'range': ['1..max']}),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """num_virtual_cpu must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__num_virtual_cpu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_num_virtual_cpu(self):
        self.__num_virtual_cpu = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            restriction_dict={'range': ['1..max']}), default=RestrictedClassType(base_type=int, restriction_dict={
            'range': ['0..65535']}, int_size=16)(1), is_leaf=True, yang_name="num-virtual-cpu", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    def _get_clock(self):
        """
    Getter method for clock, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/clock (uint32)

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz). The
cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        return self.__clock

    def _set_clock(self, v, load=False):
        """
    Setter method for clock, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/clock (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_clock is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_clock() directly.

    YANG Description: Minimum virtual CPU clock rate (e.g. in MHz). The
cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="clock", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """clock must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__clock = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_clock(self):
        self.__clock = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="clock", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    def _get_oversubscription_policy(self):
        """
    Getter method for oversubscription_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/oversubscription_policy (string)

    YANG Description: The CPU core oversubscription policy e.g. the relation
of virtual CPU cores to physical CPU cores/threads.
The cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        return self.__oversubscription_policy

    def _set_oversubscription_policy(self, v, load=False):
        """
    Setter method for oversubscription_policy, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/oversubscription_policy (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_oversubscription_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_oversubscription_policy() directly.

    YANG Description: The CPU core oversubscription policy e.g. the relation
of virtual CPU cores to physical CPU cores/threads.
The cardinality can be 0 during the allocation request,
if no particular value is requested.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="oversubscription-policy", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """oversubscription_policy must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="oversubscription-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__oversubscription_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_oversubscription_policy(self):
        self.__oversubscription_policy = YANGDynClass(base=six.text_type, is_leaf=True,
                                                      yang_name="oversubscription-policy", parent=self,
                                                      path_helper=self._path_helper, extmethods=self._extmethods,
                                                      register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                      defining_module='etsi-nfv-vnfd', yang_type='string',
                                                      is_config=True)

    def _get_vdu_cpu_requirements(self):
        """
    Getter method for vdu_cpu_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements (list)

    YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
    """
        return self.__vdu_cpu_requirements

    def _set_vdu_cpu_requirements(self, v, load=False):
        """
    Setter method for vdu_cpu_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/vdu_cpu_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_cpu_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_cpu_requirements() directly.

    YANG Description: Array of key-value pair requirements on the compute
(CPU) for the VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_cpu_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                  yang_name="vdu-cpu-requirements", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list',
                             yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_cpu_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_cpu_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements, yang_name="vdu-cpu-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-cpu-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_cpu_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_cpu_requirements(self):
        self.__vdu_cpu_requirements = YANGDynClass(base=YANGListType("key",
                                                                     yc_vdu_cpu_requirements_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_vdu_cpu_requirements,
                                                                     yang_name="vdu-cpu-requirements", parent=self,
                                                                     is_container='list', user_ordered=False,
                                                                     path_helper=self._path_helper, yang_keys='key',
                                                                     extensions=None), is_container='list',
                                                   yang_name="vdu-cpu-requirements", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, extensions=None,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_pinning(self):
        """
    Getter method for pinning, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning (container)

    YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
    """
        return self.__pinning

    def _set_pinning(self, v, load=False):
        """
    Setter method for pinning, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/pinning (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_pinning is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_pinning() directly.

    YANG Description: The virtual CPU pinning configuration for the
virtualised compute resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_pinning_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning,
                             is_container='container', yang_name="pinning", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """pinning must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_pinning_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning, is_container='container', yang_name="pinning", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__pinning = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_pinning(self):
        self.__pinning = YANGDynClass(base=yc_pinning_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_pinning,
                                      is_container='container', yang_name="pinning", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    def _get_cpu_quota(self):
        """
    Getter method for cpu_quota, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota (container)

    YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
    """
        return self.__cpu_quota

    def _set_cpu_quota(self, v, load=False):
        """
    Setter method for cpu_quota, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu/cpu_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpu_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpu_quota() directly.

    YANG Description: CPU quota describes the CPU resource allocation policy.
Limit and Reserve values are defined in MHz
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_cpu_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_cpu_quota,
                             is_container='container', yang_name="cpu-quota", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpu_quota must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_cpu_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_cpu_quota, is_container='container', yang_name="cpu-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__cpu_quota = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpu_quota(self):
        self.__cpu_quota = YANGDynClass(
            base=yc_cpu_quota_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu_cpu_quota, is_container='container',
            yang_name="cpu-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)

    cpu_architecture = __builtin__.property(_get_cpu_architecture, _set_cpu_architecture)
    num_virtual_cpu = __builtin__.property(_get_num_virtual_cpu, _set_num_virtual_cpu)
    clock = __builtin__.property(_get_clock, _set_clock)
    oversubscription_policy = __builtin__.property(_get_oversubscription_policy, _set_oversubscription_policy)
    vdu_cpu_requirements = __builtin__.property(_get_vdu_cpu_requirements, _set_vdu_cpu_requirements)
    pinning = __builtin__.property(_get_pinning, _set_pinning)
    cpu_quota = __builtin__.property(_get_cpu_quota, _set_cpu_quota)

    _pyangbind_elements = OrderedDict(
        [('cpu_architecture', cpu_architecture), ('num_virtual_cpu', num_virtual_cpu), ('clock', clock),
         ('oversubscription_policy', oversubscription_policy), ('vdu_cpu_requirements', vdu_cpu_requirements),
         ('pinning', pinning), ('cpu_quota', cpu_quota), ])


class yc_virtual_compute_desc_etsi_nfv_vnfd__vnfd_virtual_compute_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-compute-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__logical_node', '__request_additional_capability',
                 '__compute_requirements', '__virtual_memory', '__virtual_cpu',)

    _yang_name = 'virtual-compute-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__logical_node = YANGDynClass(
            base=YANGListType("id", yc_logical_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node,
                              yang_name="logical-node", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__request_additional_capability = YANGDynClass(base=YANGListType("name",
                                                                              yc_request_additional_capability_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability,
                                                                              yang_name="request-additional-capability",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='name', extensions=None),
                                                            is_container='list',
                                                            yang_name="request-additional-capability", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='list',
                                                            is_config=True)
        self.__compute_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory, is_container='container',
            yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu,
                                          is_container='container', yang_name="virtual-cpu", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                          yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-compute-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/id (string)

    YANG Description: Unique identifier of this VirtualComputeDesc in the
VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/virtual_compute_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VirtualComputeDesc in the
VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_logical_node(self):
        """
    Getter method for logical_node, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node (list)

    YANG Description: The logical node requirements.
    """
        return self.__logical_node

    def _set_logical_node(self, v, load=False):
        """
    Setter method for logical_node, mapped from YANG variable /vnfd/virtual_compute_desc/logical_node (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_logical_node is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_logical_node() directly.

    YANG Description: The logical node requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_logical_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node,
                                                  yang_name="logical-node", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="logical-node",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """logical_node must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_logical_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node, yang_name="logical-node", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__logical_node = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_logical_node(self):
        self.__logical_node = YANGDynClass(
            base=YANGListType("id", yc_logical_node_etsi_nfv_vnfd__vnfd_virtual_compute_desc_logical_node,
                              yang_name="logical-node", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="logical-node", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_request_additional_capability(self):
        """
    Getter method for request_additional_capability, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability (list)
    """
        return self.__request_additional_capability

    def _set_request_additional_capability(self, v, load=False):
        """
    Setter method for request_additional_capability, mapped from YANG variable /vnfd/virtual_compute_desc/request_additional_capability (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_request_additional_capability is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_request_additional_capability() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_request_additional_capability_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability,
                                                  yang_name="request-additional-capability", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="request-additional-capability", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """request_additional_capability must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_request_additional_capability_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability, yang_name="request-additional-capability", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="request-additional-capability", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__request_additional_capability = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_request_additional_capability(self):
        self.__request_additional_capability = YANGDynClass(base=YANGListType("name",
                                                                              yc_request_additional_capability_etsi_nfv_vnfd__vnfd_virtual_compute_desc_request_additional_capability,
                                                                              yang_name="request-additional-capability",
                                                                              parent=self, is_container='list',
                                                                              user_ordered=False,
                                                                              path_helper=self._path_helper,
                                                                              yang_keys='name', extensions=None),
                                                            is_container='list',
                                                            yang_name="request-additional-capability", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True, extensions=None,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='list',
                                                            is_config=True)

    def _get_compute_requirements(self):
        """
    Getter method for compute_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/compute_requirements (string)

    YANG Description: Specifies compute requirements.
    """
        return self.__compute_requirements

    def _set_compute_requirements(self, v, load=False):
        """
    Setter method for compute_requirements, mapped from YANG variable /vnfd/virtual_compute_desc/compute_requirements (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_compute_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_compute_requirements() directly.

    YANG Description: Specifies compute requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="compute-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """compute_requirements must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__compute_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_compute_requirements(self):
        self.__compute_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="compute-requirements",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_virtual_memory(self):
        """
    Getter method for virtual_memory, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory (container)

    YANG Description: The virtual memory of the virtualised compute.
    """
        return self.__virtual_memory

    def _set_virtual_memory(self, v, load=False):
        """
    Setter method for virtual_memory, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_memory (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_memory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_memory() directly.

    YANG Description: The virtual memory of the virtualised compute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_virtual_memory_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory,
                             is_container='container', yang_name="virtual-memory", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_memory must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_memory_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory, is_container='container', yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__virtual_memory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_memory(self):
        self.__virtual_memory = YANGDynClass(
            base=yc_virtual_memory_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_memory, is_container='container',
            yang_name="virtual-memory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    def _get_virtual_cpu(self):
        """
    Getter method for virtual_cpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu (container)

    YANG Description: The virtual CPU(s)of the virtualised compute.
    """
        return self.__virtual_cpu

    def _set_virtual_cpu(self, v, load=False):
        """
    Setter method for virtual_cpu, mapped from YANG variable /vnfd/virtual_compute_desc/virtual_cpu (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_cpu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_cpu() directly.

    YANG Description: The virtual CPU(s)of the virtualised compute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_virtual_cpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu,
                             is_container='container', yang_name="virtual-cpu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_cpu must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_cpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu, is_container='container', yang_name="virtual-cpu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__virtual_cpu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_cpu(self):
        self.__virtual_cpu = YANGDynClass(base=yc_virtual_cpu_etsi_nfv_vnfd__vnfd_virtual_compute_desc_virtual_cpu,
                                          is_container='container', yang_name="virtual-cpu", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, extensions=None,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                          yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    logical_node = __builtin__.property(_get_logical_node, _set_logical_node)
    request_additional_capability = __builtin__.property(_get_request_additional_capability,
                                                         _set_request_additional_capability)
    compute_requirements = __builtin__.property(_get_compute_requirements, _set_compute_requirements)
    virtual_memory = __builtin__.property(_get_virtual_memory, _set_virtual_memory)
    virtual_cpu = __builtin__.property(_get_virtual_cpu, _set_virtual_cpu)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('logical_node', logical_node), ('request_additional_capability', request_additional_capability),
         ('compute_requirements', compute_requirements), ('virtual_memory', virtual_memory),
         ('virtual_cpu', virtual_cpu), ])


class yc_vdu_storage_requirements_etsi_nfv_vnfd__vnfd_virtual_storage_desc_vdu_storage_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-storage-desc/vdu-storage-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'vdu-storage-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-storage-desc', 'vdu-storage-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_disk_io_quota_etsi_nfv_vnfd__vnfd_virtual_storage_desc_disk_io_quota(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-storage-desc/disk-io-quota. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
  """
    __slots__ = ('_path_helper', '_extmethods', '__limit', '__reserve', '__shares',)

    _yang_name = 'disk-io-quota'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-storage-desc', 'disk-io-quota']

    def _get_limit(self):
        """
    Getter method for limit, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/limit (uint64)

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        return self.__limit

    def _set_limit(self, v, load=False):
        """
    Setter method for limit, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/limit (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_limit is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_limit() directly.

    YANG Description: Defines the maximum allocation. The value 0 indicates that usage is not limited.
This parameter ensures that the instance never uses more than the defined amount of resource.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="limit", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """limit must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="limit", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__limit = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_limit(self):
        self.__limit = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="limit", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_reserve(self):
        """
    Getter method for reserve, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/reserve (uint64)

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        return self.__reserve

    def _set_reserve(self, v, load=False):
        """
    Setter method for reserve, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/reserve (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_reserve is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_reserve() directly.

    YANG Description: Defines the guaranteed minimum reservation.
If needed, the machine will definitely get allocated the reserved amount of resources.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="reserve", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """reserve must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="reserve", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__reserve = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_reserve(self):
        self.__reserve = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="reserve", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    def _get_shares(self):
        """
    Getter method for shares, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/shares (uint64)

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        return self.__shares

    def _set_shares(self, v, load=False):
        """
    Setter method for shares, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota/shares (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_shares is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_shares() directly.

    YANG Description: Number of shares allocated.
Specifies the proportional weighted share for the domain.
If this element is omitted, the service defaults to the OS provided defaults
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="shares", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """shares must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="shares", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)""",
            })

        self.__shares = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_shares(self):
        self.__shares = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="shares", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='uint64', is_config=True)

    limit = __builtin__.property(_get_limit, _set_limit)
    reserve = __builtin__.property(_get_reserve, _set_reserve)
    shares = __builtin__.property(_get_shares, _set_shares)

    _pyangbind_elements = OrderedDict([('limit', limit), ('reserve', reserve), ('shares', shares), ])


class yc_virtual_storage_desc_etsi_nfv_vnfd__vnfd_virtual_storage_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/virtual-storage-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__type_of_storage', '__size_of_storage', '__vdu_storage_requirements',
        '__rdma_enabled', '__sw_image_desc', '__description', '__disk_io_quota', '__device_bus',)

    _yang_name = 'virtual-storage-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'root-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
            default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                        int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)
        self.__vdu_storage_requirements = YANGDynClass(base=YANGListType("key",
                                                                         yc_vdu_storage_requirements_etsi_nfv_vnfd__vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                                         yang_name="vdu-storage-requirements",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='key',
                                                                         extensions=None), is_container='list',
                                                       yang_name="vdu-storage-requirements", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='list',
                                                       is_config=True)
        self.__rdma_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                            defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)
        self.__disk_io_quota = YANGDynClass(
            base=yc_disk_io_quota_etsi_nfv_vnfd__vnfd_virtual_storage_desc_disk_io_quota, is_container='container',
            yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)
        self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ide': {}, 'usb': {}, 'virtio': {},
                                                                                   'scsi': {}}, ), is_leaf=True,
                                         yang_name="device-bus", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                         yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'virtual-storage-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/virtual_storage_desc/id (string)

    YANG Description: Unique identifier of this VirtualStorageDesc in the
VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/virtual_storage_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this VirtualStorageDesc in the
VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_type_of_storage(self):
        """
    Getter method for type_of_storage, mapped from YANG variable /vnfd/virtual_storage_desc/type_of_storage (identityref)

    YANG Description: Type of virtualised storage resource (e.g. volume,
object).
    """
        return self.__type_of_storage

    def _set_type_of_storage(self, v, load=False):
        """
    Setter method for type_of_storage, mapped from YANG variable /vnfd/virtual_storage_desc/type_of_storage (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type_of_storage() directly.

    YANG Description: Type of virtualised storage resource (e.g. volume,
object).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ephemeral-storage': {
                                                                 '@module': 'etsi-nfv-descriptors',
                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ephemeral-storage': {
                                                                 '@module': 'etsi-nfv-descriptors',
                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type_of_storage must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__type_of_storage = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type_of_storage(self):
        self.__type_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'root-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:root-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'swap-storage': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:swap-storage': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ephemeral-storage': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
            default=six.text_type("root-storage"), is_leaf=True, yang_name="type-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)

    def _get_size_of_storage(self):
        """
    Getter method for size_of_storage, mapped from YANG variable /vnfd/virtual_storage_desc/size_of_storage (uint64)

    YANG Description: Size of virtualised storage resource (e.g. size of
volume, in GB)
    """
        return self.__size_of_storage

    def _set_size_of_storage(self, v, load=False):
        """
    Setter method for size_of_storage, mapped from YANG variable /vnfd/virtual_storage_desc/size_of_storage (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size_of_storage is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size_of_storage() directly.

    YANG Description: Size of virtualised storage resource (e.g. size of
volume, in GB)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), default=RestrictedClassType(base_type=long,
                                                                                                   restriction_dict={
                                                                                                       'range': [
                                                                                                           '0..18446744073709551615']},
                                                                                                   int_size=64)(0),
                             is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size_of_storage must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), default=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__size_of_storage = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size_of_storage(self):
        self.__size_of_storage = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                        int_size=64)(0), is_leaf=True, yang_name="size-of-storage", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    def _get_vdu_storage_requirements(self):
        """
    Getter method for vdu_storage_requirements, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements (list)

    YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
    """
        return self.__vdu_storage_requirements

    def _set_vdu_storage_requirements(self, v, load=False):
        """
    Setter method for vdu_storage_requirements, mapped from YANG variable /vnfd/virtual_storage_desc/vdu_storage_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_storage_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_storage_requirements() directly.

    YANG Description: Array of key-value pairs that articulate the storage
deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_vdu_storage_requirements_etsi_nfv_vnfd__vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                  yang_name="vdu-storage-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="vdu-storage-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_storage_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_vdu_storage_requirements_etsi_nfv_vnfd__vnfd_virtual_storage_desc_vdu_storage_requirements, yang_name="vdu-storage-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="vdu-storage-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_storage_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_storage_requirements(self):
        self.__vdu_storage_requirements = YANGDynClass(base=YANGListType("key",
                                                                         yc_vdu_storage_requirements_etsi_nfv_vnfd__vnfd_virtual_storage_desc_vdu_storage_requirements,
                                                                         yang_name="vdu-storage-requirements",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='key',
                                                                         extensions=None), is_container='list',
                                                       yang_name="vdu-storage-requirements", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='list',
                                                       is_config=True)

    def _get_rdma_enabled(self):
        """
    Getter method for rdma_enabled, mapped from YANG variable /vnfd/virtual_storage_desc/rdma_enabled (boolean)

    YANG Description: Indicate if the storage support RDMA.
    """
        return self.__rdma_enabled

    def _set_rdma_enabled(self, v, load=False):
        """
    Setter method for rdma_enabled, mapped from YANG variable /vnfd/virtual_storage_desc/rdma_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_rdma_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_rdma_enabled() directly.

    YANG Description: Indicate if the storage support RDMA.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """rdma_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__rdma_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_rdma_enabled(self):
        self.__rdma_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="rdma-enabled", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /vnfd/virtual_storage_desc/sw_image_desc (leafref)

    YANG Description: Software image to be loaded on the VirtualStorage
resource created based on this VirtualStorageDesc.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /vnfd/virtual_storage_desc/sw_image_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Software image to be loaded on the VirtualStorage
resource created based on this VirtualStorageDesc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="sw-image-desc", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                            defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/virtual_storage_desc/description (string)
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/virtual_storage_desc/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)

    def _get_disk_io_quota(self):
        """
    Getter method for disk_io_quota, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota (container)

    YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
    """
        return self.__disk_io_quota

    def _set_disk_io_quota(self, v, load=False):
        """
    Setter method for disk_io_quota, mapped from YANG variable /vnfd/virtual_storage_desc/disk_io_quota (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_io_quota is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_io_quota() directly.

    YANG Description: Disk IO quota describes the disk IO operations resource allocation policy.
Limit and Reserve values are defined in IOPS
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_disk_io_quota_etsi_nfv_vnfd__vnfd_virtual_storage_desc_disk_io_quota,
                             is_container='container', yang_name="disk-io-quota", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """disk_io_quota must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_disk_io_quota_etsi_nfv_vnfd__vnfd_virtual_storage_desc_disk_io_quota, is_container='container', yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa', yang_type='container', is_config=True)""",
            })

        self.__disk_io_quota = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_disk_io_quota(self):
        self.__disk_io_quota = YANGDynClass(
            base=yc_disk_io_quota_etsi_nfv_vnfd__vnfd_virtual_storage_desc_disk_io_quota, is_container='container',
            yang_name="disk-io-quota", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:epa', defining_module='epa',
            yang_type='container', is_config=True)

    def _get_device_bus(self):
        """
    Getter method for device_bus, mapped from YANG variable /vnfd/virtual_storage_desc/device_bus (enumeration)

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
        return self.__device_bus

    def _set_device_bus(self, v, load=False):
        """
    Setter method for device_bus, mapped from YANG variable /vnfd/virtual_storage_desc/device_bus (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_device_bus is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_device_bus() directly.

    YANG Description: Type of disk-bus on which this disk is exposed to guest
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ide': {}, 'usb': {}, 'virtio': {},
                                                                          'scsi': {}}, ), is_leaf=True,
                             yang_name="device-bus", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """device_bus must be of a type compatible with enumeration""",
                'defined-type': "various:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ide': {}, 'usb': {}, 'virtio': {}, 'scsi': {}},), is_leaf=True, yang_name="device-bus", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration', is_config=True)""",
            })

        self.__device_bus = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_device_bus(self):
        self.__device_bus = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ide': {}, 'usb': {}, 'virtio': {},
                                                                                   'scsi': {}}, ), is_leaf=True,
                                         yang_name="device-bus", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                                         yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    type_of_storage = __builtin__.property(_get_type_of_storage, _set_type_of_storage)
    size_of_storage = __builtin__.property(_get_size_of_storage, _set_size_of_storage)
    vdu_storage_requirements = __builtin__.property(_get_vdu_storage_requirements, _set_vdu_storage_requirements)
    rdma_enabled = __builtin__.property(_get_rdma_enabled, _set_rdma_enabled)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)
    description = __builtin__.property(_get_description, _set_description)
    disk_io_quota = __builtin__.property(_get_disk_io_quota, _set_disk_io_quota)
    device_bus = __builtin__.property(_get_device_bus, _set_device_bus)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('type_of_storage', type_of_storage), ('size_of_storage', size_of_storage),
         ('vdu_storage_requirements', vdu_storage_requirements), ('rdma_enabled', rdma_enabled),
         ('sw_image_desc', sw_image_desc), ('description', description), ('disk_io_quota', disk_io_quota),
         ('device_bus', device_bus), ])


class yc_checksum_etsi_nfv_vnfd__vnfd_sw_image_desc_checksum(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/sw-image-desc/checksum. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The checksum of the software image file.
  """
    __slots__ = ('_path_helper', '_extmethods', '__algorithm', '__hash',)

    _yang_name = 'checksum'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={
                                                                     'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                        is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='identityref', is_config=True)
        self.__hash = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'sw-image-desc', 'checksum']

    def _get_algorithm(self):
        """
    Getter method for algorithm, mapped from YANG variable /vnfd/sw_image_desc/checksum/algorithm (identityref)

    YANG Description: Species the algorithm used to obtain the checksum
value.
    """
        return self.__algorithm

    def _set_algorithm(self, v, load=False):
        """
    Setter method for algorithm, mapped from YANG variable /vnfd/sw_image_desc/checksum/algorithm (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_algorithm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_algorithm() directly.

    YANG Description: Species the algorithm used to obtain the checksum
value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-224': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-224': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-256': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-256': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-384': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-384': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:sha-512': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:sha-512': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """algorithm must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-224': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-256': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-384': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:sha-512': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__algorithm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_algorithm(self):
        self.__algorithm = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={
                                                                     'sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-224': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-256': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-384': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'nfv:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                     'vnf:sha-512': {'@module': 'etsi-nfv-descriptors',
                                                                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                        is_leaf=True, yang_name="algorithm", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='identityref', is_config=True)

    def _get_hash(self):
        """
    Getter method for hash, mapped from YANG variable /vnfd/sw_image_desc/checksum/hash (string)

    YANG Description: Contains the result of applying the algorithm
indicated by the algorithm attribute to the data to
which this ChecksumData refers.
    """
        return self.__hash

    def _set_hash(self, v, load=False):
        """
    Setter method for hash, mapped from YANG variable /vnfd/sw_image_desc/checksum/hash (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hash is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hash() directly.

    YANG Description: Contains the result of applying the algorithm
indicated by the algorithm attribute to the data to
which this ChecksumData refers.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """hash must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__hash = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_hash(self):
        self.__hash = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="hash", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    algorithm = __builtin__.property(_get_algorithm, _set_algorithm)
    hash = __builtin__.property(_get_hash, _set_hash)

    _pyangbind_elements = OrderedDict([('algorithm', algorithm), ('hash', hash), ])


class yc_sw_image_desc_etsi_nfv_vnfd__vnfd_sw_image_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/sw-image-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines descriptors of software images to be used by the
VNF.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__version', '__checksum', '__container_format',
        '__disk_format',
        '__min_disk', '__min_ram', '__size', '__image', '__operating_system', '__supported_virtualization_environment',
        '__vim_type',)

    _yang_name = 'sw-image-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                      yang_type='string', is_config=True)
        self.__checksum = YANGDynClass(base=yc_checksum_etsi_nfv_vnfd__vnfd_sw_image_desc_checksum,
                                       is_container='container', yang_name="checksum", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                       defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        self.__container_format = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {},
                                                      'ova': {}, 'ovf': {}}, ), default=six.text_type("bare"),
            is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__disk_format = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'aki': {}, 'ami': {}, 'ari': {},
                                                                                    'iso': {}, 'qcow2': {}, 'raw': {},
                                                                                    'vdi': {}, 'vhd': {}, 'vhdx': {},
                                                                                    'vmdk': {}}, ),
                                          default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format",
                                          parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0),
            is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='decimal64', is_config=True)
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="size", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)
        self.__image = YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                    defining_module='etsi-nfv-vnfd', yang_type='inet:uri', is_config=True)
        self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__supported_virtualization_environment = YANGDynClass(unique=True,
                                                                   base=TypedListType(allowed_type=six.text_type),
                                                                   is_leaf=False,
                                                                   yang_name="supported-virtualization-environment",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='string',
                                                                   is_config=True)
        self.__vim_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:alternative-images',
                                       defining_module='alternative-images', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'sw-image-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/sw_image_desc/id (string)

    YANG Description: The identifier of this software image.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/sw_image_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: The identifier of this software image.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/sw_image_desc/name (string)

    YANG Description: The name of this software image.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/sw_image_desc/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The name of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /vnfd/sw_image_desc/version (string)

    YANG Description: The version of this software image.
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /vnfd/sw_image_desc/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: The version of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                      yang_type='string', is_config=True)

    def _get_checksum(self):
        """
    Getter method for checksum, mapped from YANG variable /vnfd/sw_image_desc/checksum (container)

    YANG Description: The checksum of the software image file.
    """
        return self.__checksum

    def _set_checksum(self, v, load=False):
        """
    Setter method for checksum, mapped from YANG variable /vnfd/sw_image_desc/checksum (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_checksum is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_checksum() directly.

    YANG Description: The checksum of the software image file.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_checksum_etsi_nfv_vnfd__vnfd_sw_image_desc_checksum, is_container='container',
                             yang_name="checksum", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """checksum must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_checksum_etsi_nfv_vnfd__vnfd_sw_image_desc_checksum, is_container='container', yang_name="checksum", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__checksum = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_checksum(self):
        self.__checksum = YANGDynClass(base=yc_checksum_etsi_nfv_vnfd__vnfd_sw_image_desc_checksum,
                                       is_container='container', yang_name="checksum", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                       defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    def _get_container_format(self):
        """
    Getter method for container_format, mapped from YANG variable /vnfd/sw_image_desc/container_format (enumeration)

    YANG Description: The container format describes the container file
format in which software image is provided.
    """
        return self.__container_format

    def _set_container_format(self, v, load=False):
        """
    Setter method for container_format, mapped from YANG variable /vnfd/sw_image_desc/container_format (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_container_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_container_format() directly.

    YANG Description: The container format describes the container file
format in which software image is provided.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {},
                                                                          'docker': {}, 'ova': {}, 'ovf': {}}, ),
                             default=six.text_type("bare"), is_leaf=True, yang_name="container-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """container_format must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {}, 'ova': {}, 'ovf': {}},), default=six.text_type("bare"), is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__container_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_container_format(self):
        self.__container_format = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'bare': {}, 'docker': {},
                                                      'ova': {}, 'ovf': {}}, ), default=six.text_type("bare"),
            is_leaf=True, yang_name="container-format", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_disk_format(self):
        """
    Getter method for disk_format, mapped from YANG variable /vnfd/sw_image_desc/disk_format (enumeration)

    YANG Description: The disk format of a software image is the format of
the underlying disk image.
    """
        return self.__disk_format

    def _set_disk_format(self, v, load=False):
        """
    Setter method for disk_format, mapped from YANG variable /vnfd/sw_image_desc/disk_format (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_disk_format is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_disk_format() directly.

    YANG Description: The disk format of a software image is the format of
the underlying disk image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'iso': {},
                                                                          'qcow2': {}, 'raw': {}, 'vdi': {}, 'vhd': {},
                                                                          'vhdx': {}, 'vmdk': {}}, ),
                             default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """disk_format must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'aki': {}, 'ami': {}, 'ari': {}, 'iso': {}, 'qcow2': {}, 'raw': {}, 'vdi': {}, 'vhd': {}, 'vhdx': {}, 'vmdk': {}},), default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__disk_format = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_disk_format(self):
        self.__disk_format = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'aki': {}, 'ami': {}, 'ari': {},
                                                                                    'iso': {}, 'qcow2': {}, 'raw': {},
                                                                                    'vdi': {}, 'vhd': {}, 'vhdx': {},
                                                                                    'vmdk': {}}, ),
                                          default=six.text_type("qcow2"), is_leaf=True, yang_name="disk-format",
                                          parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_min_disk(self):
        """
    Getter method for min_disk, mapped from YANG variable /vnfd/sw_image_desc/min_disk (uint64)

    YANG Description: The minimal disk size requirement for this software
image. The value of the 'size of storage' attribute
of the VirtualStorageDesc referencing this
SwImageDesc shall not be smaller than the value of
minDisk.
    """
        return self.__min_disk

    def _set_min_disk(self, v, load=False):
        """
    Setter method for min_disk, mapped from YANG variable /vnfd/sw_image_desc/min_disk (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_disk is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_disk() directly.

    YANG Description: The minimal disk size requirement for this software
image. The value of the 'size of storage' attribute
of the VirtualStorageDesc referencing this
SwImageDesc shall not be smaller than the value of
minDisk.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_disk must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="min-disk", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__min_disk = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_disk(self):
        self.__min_disk = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="min-disk", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    def _get_min_ram(self):
        """
    Getter method for min_ram, mapped from YANG variable /vnfd/sw_image_desc/min_ram (decimal64)

    YANG Description: The minimal RAM requirement for this software image.
The value of the 'size' attribute of
VirtualMemoryData of the Vdu referencing this
SwImageDesc shall not be smaller than the value of
minRam.
    """
        return self.__min_ram

    def _set_min_ram(self, v, load=False):
        """
    Setter method for min_ram, mapped from YANG variable /vnfd/sw_image_desc/min_ram (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_ram is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_ram() directly.

    YANG Description: The minimal RAM requirement for this software image.
The value of the 'size' attribute of
VirtualMemoryData of the Vdu referencing this
SwImageDesc shall not be smaller than the value of
minRam.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}),
                             default=Decimal(0), is_leaf=True, yang_name="min-ram", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_ram must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0), is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='decimal64', is_config=True)""",
            })

        self.__min_ram = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_ram(self):
        self.__min_ram = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..max']}), default=Decimal(0),
            is_leaf=True, yang_name="min-ram", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='decimal64', is_config=True)

    def _get_size(self):
        """
    Getter method for size, mapped from YANG variable /vnfd/sw_image_desc/size (uint64)

    YANG Description: The size of this software image.
    """
        return self.__size

    def _set_size(self, v, load=False):
        """
    Setter method for size, mapped from YANG variable /vnfd/sw_image_desc/size (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_size is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_size() directly.

    YANG Description: The size of this software image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="size", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """size must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="size", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__size = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_size(self):
        self.__size = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="size", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    def _get_image(self):
        """
    Getter method for image, mapped from YANG variable /vnfd/sw_image_desc/image (inet:uri)

    YANG Description: This is a reference to the actual software image.
The reference can be relative to the root of the VNF
Package or can be a URL
    """
        return self.__image

    def _set_image(self, v, load=False):
        """
    Setter method for image, mapped from YANG variable /vnfd/sw_image_desc/image (inet:uri)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_image is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_image() directly.

    YANG Description: This is a reference to the actual software image.
The reference can be relative to the root of the VNF
Package or can be a URL
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='inet:uri', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """image must be of a type compatible with inet:uri""",
                'defined-type': "inet:uri",
                'generated-type': """YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='inet:uri', is_config=True)""",
            })

        self.__image = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_image(self):
        self.__image = YANGDynClass(base=six.text_type, default=six.text_type("."), is_leaf=True, yang_name="image",
                                    parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                    defining_module='etsi-nfv-vnfd', yang_type='inet:uri', is_config=True)

    def _get_operating_system(self):
        """
    Getter method for operating_system, mapped from YANG variable /vnfd/sw_image_desc/operating_system (string)

    YANG Description: Identifies the operating system used in the software
image. This attribute may also identify if a 32 bit
or 64 bit software image is used.
    """
        return self.__operating_system

    def _set_operating_system(self, v, load=False):
        """
    Setter method for operating_system, mapped from YANG variable /vnfd/sw_image_desc/operating_system (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operating_system is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operating_system() directly.

    YANG Description: Identifies the operating system used in the software
image. This attribute may also identify if a 32 bit
or 64 bit software image is used.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """operating_system must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__operating_system = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_operating_system(self):
        self.__operating_system = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="operating-system",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_supported_virtualization_environment(self):
        """
    Getter method for supported_virtualization_environment, mapped from YANG variable /vnfd/sw_image_desc/supported_virtualization_environment (string)

    YANG Description: Identifies the virtualisation environments
(e.g. hypervisor) compatible with this software
image.
    """
        return self.__supported_virtualization_environment

    def _set_supported_virtualization_environment(self, v, load=False):
        """
    Setter method for supported_virtualization_environment, mapped from YANG variable /vnfd/sw_image_desc/supported_virtualization_environment (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_virtualization_environment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_virtualization_environment() directly.

    YANG Description: Identifies the virtualisation environments
(e.g. hypervisor) compatible with this software
image.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="supported-virtualization-environment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_virtualization_environment must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="supported-virtualization-environment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__supported_virtualization_environment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_virtualization_environment(self):
        self.__supported_virtualization_environment = YANGDynClass(unique=True,
                                                                   base=TypedListType(allowed_type=six.text_type),
                                                                   is_leaf=False,
                                                                   yang_name="supported-virtualization-environment",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='string',
                                                                   is_config=True)

    def _get_vim_type(self):
        """
    Getter method for vim_type, mapped from YANG variable /vnfd/sw_image_desc/vim_type (string)

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
        return self.__vim_type

    def _set_vim_type(self, v, load=False):
        """
    Setter method for vim_type, mapped from YANG variable /vnfd/sw_image_desc/vim_type (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vim_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vim_type() directly.

    YANG Description: VIM type: openvim, openstack, vmware, aws, etc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:alternative-images', defining_module='alternative-images',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vim_type must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:alternative-images', defining_module='alternative-images', yang_type='string', is_config=True)""",
            })

        self.__vim_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vim_type(self):
        self.__vim_type = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vim-type", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:alternative-images',
                                       defining_module='alternative-images', yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    version = __builtin__.property(_get_version, _set_version)
    checksum = __builtin__.property(_get_checksum, _set_checksum)
    container_format = __builtin__.property(_get_container_format, _set_container_format)
    disk_format = __builtin__.property(_get_disk_format, _set_disk_format)
    min_disk = __builtin__.property(_get_min_disk, _set_min_disk)
    min_ram = __builtin__.property(_get_min_ram, _set_min_ram)
    size = __builtin__.property(_get_size, _set_size)
    image = __builtin__.property(_get_image, _set_image)
    operating_system = __builtin__.property(_get_operating_system, _set_operating_system)
    supported_virtualization_environment = __builtin__.property(_get_supported_virtualization_environment,
                                                                _set_supported_virtualization_environment)
    vim_type = __builtin__.property(_get_vim_type, _set_vim_type)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('version', version), ('checksum', checksum),
                                       ('container_format', container_format), ('disk_format', disk_format),
                                       ('min_disk', min_disk), ('min_ram', min_ram), ('size', size), ('image', image),
                                       ('operating_system', operating_system),
                                       ('supported_virtualization_environment', supported_virtualization_environment),
                                       ('vim_type', vim_type), ])


class yc_qos_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour_qos(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc/flavour/qos. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: QoS of the VL.
  """
    __slots__ = ('_path_helper', '_extmethods', '__latency', '__packet_delay_variation', '__packet_loss_ratio',)

    _yang_name = 'qos'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='decimal64', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc', 'flavour', 'qos']

    def _get_latency(self):
        """
    Getter method for latency, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/latency (uint32)

    YANG Description: Specifies the maximum latency in ms.
    """
        return self.__latency

    def _set_latency(self, v, load=False):
        """
    Setter method for latency, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/latency (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_latency is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_latency() directly.

    YANG Description: Specifies the maximum latency in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="latency", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """latency must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__latency = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_latency(self):
        self.__latency = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="latency", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    def _get_packet_delay_variation(self):
        """
    Getter method for packet_delay_variation, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/packet_delay_variation (uint32)

    YANG Description: Specifies the maximum jitter in ms.
    """
        return self.__packet_delay_variation

    def _set_packet_delay_variation(self, v, load=False):
        """
    Setter method for packet_delay_variation, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/packet_delay_variation (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_delay_variation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_delay_variation() directly.

    YANG Description: Specifies the maximum jitter in ms.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="packet-delay-variation",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_delay_variation must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__packet_delay_variation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_delay_variation(self):
        self.__packet_delay_variation = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="packet-delay-variation", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    def _get_packet_loss_ratio(self):
        """
    Getter method for packet_loss_ratio, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/packet_loss_ratio (decimal64)

    YANG Description: Specifies the maximum packet loss ratio.
    """
        return self.__packet_loss_ratio

    def _set_packet_loss_ratio(self, v, load=False):
        """
    Setter method for packet_loss_ratio, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos/packet_loss_ratio (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_packet_loss_ratio is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_packet_loss_ratio() directly.

    YANG Description: Specifies the maximum packet loss ratio.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}),
                             is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """packet_loss_ratio must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True, yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='decimal64', is_config=True)""",
            })

        self.__packet_loss_ratio = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_packet_loss_ratio(self):
        self.__packet_loss_ratio = YANGDynClass(
            base=RestrictedClassType(base_type=Decimal, restriction_dict={'range': ['0..1.00']}), is_leaf=True,
            yang_name="packet-loss-ratio", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='decimal64', is_config=True)

    latency = __builtin__.property(_get_latency, _set_latency)
    packet_delay_variation = __builtin__.property(_get_packet_delay_variation, _set_packet_delay_variation)
    packet_loss_ratio = __builtin__.property(_get_packet_loss_ratio, _set_packet_loss_ratio)

    _pyangbind_elements = OrderedDict([('latency', latency), ('packet_delay_variation', packet_delay_variation),
                                       ('packet_loss_ratio', packet_loss_ratio), ])


class yc_flavour_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc/flavour. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__qos',)

    _yang_name = 'flavour'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour_qos,
                                  is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc', 'flavour']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/id (string)

    YANG Description: Identifies a flavour within a VnfVirtualLinkDesc.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies a flavour within a VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_qos(self):
        """
    Getter method for qos, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos (container)

    YANG Description: QoS of the VL.
    """
        return self.__qos

    def _set_qos(self, v, load=False):
        """
    Setter method for qos, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour/qos (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_qos is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_qos() directly.

    YANG Description: QoS of the VL.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_qos_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour_qos,
                             is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """qos must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_qos_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour_qos, is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__qos = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_qos(self):
        self.__qos = YANGDynClass(base=yc_qos_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour_qos,
                                  is_container='container', yang_name="qos", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True, extensions=None,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='container', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    qos = __builtin__.property(_get_qos, _set_qos)

    _pyangbind_elements = OrderedDict([('id', id), ('qos', qos), ])


class yc_connectivity_type_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_connectivity_type(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc/connectivity-type. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__layer_protocol', '__flow_pattern',)

    _yang_name = 'connectivity-type'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='flow-pattern', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc', 'connectivity-type']

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type/layer_protocol (identityref)

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies the protocols that the VL uses (Ethernet,
MPLS, ODU2, IPV4, IPV6, Pseudo-Wire). The top layer
protocol of the VL protocol stack shall always be provided.
The lower layer protocols may be included when there are
specific requirements on these layers.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)

    def _get_flow_pattern(self):
        """
    Getter method for flow_pattern, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        return self.__flow_pattern

    def _set_flow_pattern(self, v, load=False):
        """
    Setter method for flow_pattern, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type/flow_pattern (flow-pattern)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flow_pattern is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flow_pattern() directly.

    YANG Description: Identifies the flow pattern of the connectivity (Line,
Tree, Mesh).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ),
                             is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='flow-pattern', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flow_pattern must be of a type compatible with flow-pattern""",
                'defined-type': "etsi-nfv-vnfd:flow-pattern",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}},), is_leaf=True, yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='flow-pattern', is_config=True)""",
            })

        self.__flow_pattern = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flow_pattern(self):
        self.__flow_pattern = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'line': {}, 'tree': {}, 'mesh': {}}, ), is_leaf=True,
            yang_name="flow-pattern", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='flow-pattern', is_config=True)

    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    flow_pattern = __builtin__.property(_get_flow_pattern, _set_flow_pattern)

    _pyangbind_elements = OrderedDict([('layer_protocol', layer_protocol), ('flow_pattern', flow_pattern), ])


class yc_monitoring_parameters_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_monitoring_parameters(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc/monitoring-parameters. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameters'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc', 'monitoring-parameters']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_provider_network_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_provider_network(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc/provider-network. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Container for the provider network.
  """
    __slots__ = ('_path_helper', '_extmethods', '__physical_network', '__segmentation_id',)

    _yang_name = 'provider-network'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                               defining_module='various', yang_type='string', is_config=True)
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
            defining_module='various', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc', 'provider-network']

    def _get_physical_network(self):
        """
    Getter method for physical_network, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network/physical_network (string)

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        return self.__physical_network

    def _set_physical_network(self, v, load=False):
        """
    Setter method for physical_network, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network/physical_network (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_physical_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_physical_network() directly.

    YANG Description: Name of the physical network on which the provider
network is built.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """physical_network must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='string', is_config=True)""",
            })

        self.__physical_network = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_physical_network(self):
        self.__physical_network = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="physical-network",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                               defining_module='various', yang_type='string', is_config=True)

    def _get_segmentation_id(self):
        """
    Getter method for segmentation_id, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network/segmentation_id (uint32)

    YANG Description: ID of segregated virtual networks
    """
        return self.__segmentation_id

    def _set_segmentation_id(self, v, load=False):
        """
    Setter method for segmentation_id, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network/segmentation_id (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_segmentation_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_segmentation_id() directly.

    YANG Description: ID of segregated virtual networks
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="segmentation_id",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                             defining_module='various', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """segmentation_id must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='uint32', is_config=True)""",
            })

        self.__segmentation_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_segmentation_id(self):
        self.__segmentation_id = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="segmentation_id", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
            defining_module='various', yang_type='uint32', is_config=True)

    physical_network = __builtin__.property(_get_physical_network, _set_physical_network)
    segmentation_id = __builtin__.property(_get_segmentation_id, _set_segmentation_id)

    _pyangbind_elements = OrderedDict([('physical_network', physical_network), ('segmentation_id', segmentation_id), ])


class yc_int_virtual_link_desc_etsi_nfv_vnfd__vnfd_int_virtual_link_desc(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/int-virtual-link-desc. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__flavour', '__connectivity_type', '__test_access', '__description',
        '__monitoring_parameters', '__provider_network',)

    _yang_name = 'int-virtual-link-desc'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__flavour = YANGDynClass(
            base=YANGListType("id", yc_flavour_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour, yang_name="flavour",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="flavour", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__test_access = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                          yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__monitoring_parameters = YANGDynClass(base=YANGListType("id",
                                                                      yc_monitoring_parameters_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_monitoring_parameters,
                                                                      yang_name="monitoring-parameters", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper, yang_keys='id',
                                                                      extensions=None), is_container='list',
                                                    yang_name="monitoring-parameters", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_provider_network,
            is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'int-virtual-link-desc']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/id (string)

    YANG Description: Unique identifier of this internal VLD in VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/int_virtual_link_desc/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this internal VLD in VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_flavour(self):
        """
    Getter method for flavour, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour (list)

    YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
    """
        return self.__flavour

    def _set_flavour(self, v, load=False):
        """
    Setter method for flavour, mapped from YANG variable /vnfd/int_virtual_link_desc/flavour (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour() directly.

    YANG Description: Describes a specific flavour of the VL with specific
  bitrate requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_flavour_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour,
                                                  yang_name="flavour", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="flavour",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_flavour_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour, yang_name="flavour", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__flavour = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour(self):
        self.__flavour = YANGDynClass(
            base=YANGListType("id", yc_flavour_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_flavour, yang_name="flavour",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="flavour", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_connectivity_type(self):
        """
    Getter method for connectivity_type, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type (container)
    """
        return self.__connectivity_type

    def _set_connectivity_type(self, v, load=False):
        """
    Setter method for connectivity_type, mapped from YANG variable /vnfd/int_virtual_link_desc/connectivity_type (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_connectivity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_connectivity_type() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_connectivity_type_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_connectivity_type,
                             is_container='container', yang_name="connectivity-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """connectivity_type must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_connectivity_type_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_connectivity_type, is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__connectivity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_connectivity_type(self):
        self.__connectivity_type = YANGDynClass(
            base=yc_connectivity_type_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_connectivity_type,
            is_container='container', yang_name="connectivity-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_test_access(self):
        """
    Getter method for test_access, mapped from YANG variable /vnfd/int_virtual_link_desc/test_access (string)

    YANG Description: Specifies test access facilities expected on the VL
(e.g. none, passive monitoring, or active (intrusive)
loopbacks at endpoints.
    """
        return self.__test_access

    def _set_test_access(self, v, load=False):
        """
    Setter method for test_access, mapped from YANG variable /vnfd/int_virtual_link_desc/test_access (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_test_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_test_access() directly.

    YANG Description: Specifies test access facilities expected on the VL
(e.g. none, passive monitoring, or active (intrusive)
loopbacks at endpoints.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="test-access", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """test_access must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="test-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__test_access = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_test_access(self):
        self.__test_access = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                          yang_name="test-access", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                          yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/int_virtual_link_desc/description (string)

    YANG Description: Provides human-readable information on the purpose of
the VL (e.g. control plane traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/int_virtual_link_desc/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of
the VL (e.g. control plane traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_monitoring_parameters(self):
        """
    Getter method for monitoring_parameters, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters (list)
    """
        return self.__monitoring_parameters

    def _set_monitoring_parameters(self, v, load=False):
        """
    Setter method for monitoring_parameters, mapped from YANG variable /vnfd/int_virtual_link_desc/monitoring_parameters (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameters is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameters() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameters_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_monitoring_parameters,
                                                  yang_name="monitoring-parameters", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameters", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameters must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameters_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_monitoring_parameters, yang_name="monitoring-parameters", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameters", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameters = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameters(self):
        self.__monitoring_parameters = YANGDynClass(base=YANGListType("id",
                                                                      yc_monitoring_parameters_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_monitoring_parameters,
                                                                      yang_name="monitoring-parameters", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper, yang_keys='id',
                                                                      extensions=None), is_container='list',
                                                    yang_name="monitoring-parameters", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_provider_network(self):
        """
    Getter method for provider_network, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network (container)

    YANG Description: Container for the provider network.
    """
        return self.__provider_network

    def _set_provider_network(self, v, load=False):
        """
    Setter method for provider_network, mapped from YANG variable /vnfd/int_virtual_link_desc/provider_network (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider_network is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider_network() directly.

    YANG Description: Container for the provider network.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_provider_network_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_provider_network,
                             is_container='container', yang_name="provider-network", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """provider_network must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_provider_network_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_provider_network, is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='container', is_config=True)""",
            })

        self.__provider_network = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_provider_network(self):
        self.__provider_network = YANGDynClass(
            base=yc_provider_network_etsi_nfv_vnfd__vnfd_int_virtual_link_desc_provider_network,
            is_container='container', yang_name="provider-network", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    flavour = __builtin__.property(_get_flavour, _set_flavour)
    connectivity_type = __builtin__.property(_get_connectivity_type, _set_connectivity_type)
    test_access = __builtin__.property(_get_test_access, _set_test_access)
    description = __builtin__.property(_get_description, _set_description)
    monitoring_parameters = __builtin__.property(_get_monitoring_parameters, _set_monitoring_parameters)
    provider_network = __builtin__.property(_get_provider_network, _set_provider_network)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('flavour', flavour), ('connectivity_type', connectivity_type), ('test_access', test_access),
         ('description', description), ('monitoring_parameters', monitoring_parameters),
         ('provider_network', provider_network), ])


class yc_security_group_rule_etsi_nfv_vnfd__vnfd_security_group_rule(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/security-group-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines security group rules to be used by the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__direction', '__ether_type', '__protocol',
                 '__port_range_min', '__port_range_max',)

    _yang_name = 'security-group-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                        defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='enumeration', is_config=True)
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'security-group-rule']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/security_group_rule/id (string)

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/security_group_rule/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this SecurityGroupRule information
element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/security_group_rule/description (string)

    YANG Description: Human readable description of the security group rule.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/security_group_rule/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the security group rule.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_direction(self):
        """
    Getter method for direction, mapped from YANG variable /vnfd/security_group_rule/direction (enumeration)

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        return self.__direction

    def _set_direction(self, v, load=False):
        """
    Setter method for direction, mapped from YANG variable /vnfd/security_group_rule/direction (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_direction is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_direction() directly.

    YANG Description: The direction in which the security group rule is applied.
Permitted values: INGRESS, EGRESS. Defaults to INGRESS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ingress': {}, 'egress': {}}, ),
                             default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """direction must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ingress': {}, 'egress': {}},), default=six.text_type("ingress"), is_leaf=True, yang_name="direction", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__direction = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_direction(self):
        self.__direction = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'ingress': {}, 'egress': {}}, ),
                                        default=six.text_type("ingress"), is_leaf=True, yang_name="direction",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                        defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_ether_type(self):
        """
    Getter method for ether_type, mapped from YANG variable /vnfd/security_group_rule/ether_type (enumeration)

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        return self.__ether_type

    def _set_ether_type(self, v, load=False):
        """
    Setter method for ether_type, mapped from YANG variable /vnfd/security_group_rule/ether_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ether_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ether_type() directly.

    YANG Description: Indicates the protocol carried over the Ethernet layer.
Permitted values: IPV4, IPV6. Defaults to IPV4.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ether_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__ether_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ether_type(self):
        self.__ether_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ether-type",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /vnfd/security_group_rule/protocol (enumeration)

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /vnfd/security_group_rule/protocol (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Indicates the protocol carried over the IP layer.
Permitted values: any protocol defined in the IANA
protocol registry, e.g. TCP, UDP, ICMP, etc. Defaults
to TCP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                             default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}},), default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                restriction_arg={'tcp': {}, 'udp': {}, 'icmp': {}}, ),
                                       default=six.text_type("tcp"), is_leaf=True, yang_name="protocol", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='enumeration', is_config=True)

    def _get_port_range_min(self):
        """
    Getter method for port_range_min, mapped from YANG variable /vnfd/security_group_rule/port_range_min (uint16)

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        return self.__port_range_min

    def _set_port_range_min(self, v, load=False):
        """
    Setter method for port_range_min, mapped from YANG variable /vnfd/security_group_rule/port_range_min (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_min is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_min() directly.

    YANG Description: Indicates minimum port number in the range that is
matched by the security group rule. Defaults to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(0), is_leaf=True, yang_name="port-range-min",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_min must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(0), is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_min = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_min(self):
        self.__port_range_min = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(0),
            is_leaf=True, yang_name="port-range-min", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    def _get_port_range_max(self):
        """
    Getter method for port_range_max, mapped from YANG variable /vnfd/security_group_rule/port_range_max (uint16)

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        return self.__port_range_max

    def _set_port_range_max(self, v, load=False):
        """
    Setter method for port_range_max, mapped from YANG variable /vnfd/security_group_rule/port_range_max (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_range_max is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_range_max() directly.

    YANG Description: Indicates maximum port number in the range that is
matched by the security group rule. Defaults to 65535.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(65535), is_leaf=True, yang_name="port-range-max",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_range_max must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(65535), is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__port_range_max = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_range_max(self):
        self.__port_range_max = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(65535),
            is_leaf=True, yang_name="port-range-max", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    direction = __builtin__.property(_get_direction, _set_direction)
    ether_type = __builtin__.property(_get_ether_type, _set_ether_type)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    port_range_min = __builtin__.property(_get_port_range_min, _set_port_range_min)
    port_range_max = __builtin__.property(_get_port_range_max, _set_port_range_max)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('direction', direction), ('ether_type', ether_type),
         ('protocol', protocol), ('port_range_min', port_range_min), ('port_range_max', port_range_max), ])


class yc_int_cpd_etsi_nfv_vnfd__vnfd_ext_cpd_int_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/int-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vdu_id', '__cpd',)

    _yang_name = 'int-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='leafref', is_config=True)
        self.__cpd = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                                  choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'int-cpd']

    def _get_vdu_id(self):
        """
    Getter method for vdu_id, mapped from YANG variable /vnfd/ext_cpd/int_cpd/vdu_id (leafref)
    """
        return self.__vdu_id

    def _set_vdu_id(self, v, load=False):
        """
    Setter method for vdu_id, mapped from YANG variable /vnfd/ext_cpd/int_cpd/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                             choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_id(self):
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='leafref', is_config=True)

    def _get_cpd(self):
        """
    Getter method for cpd, mapped from YANG variable /vnfd/ext_cpd/int_cpd/cpd (leafref)
    """
        return self.__cpd

    def _set_cpd(self, v, load=False):
        """
    Setter method for cpd, mapped from YANG variable /vnfd/ext_cpd/int_cpd/cpd (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                             choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd(self):
        self.__cpd = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cpd", parent=self,
                                  choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='leafref', is_config=True)

    vdu_id = __builtin__.property(_get_vdu_id, _set_vdu_id)
    cpd = __builtin__.property(_get_cpd, _set_cpd)

    __choices__ = {'cp-connection': {'int-cpd': ['vdu_id', 'cpd']}}
    _pyangbind_elements = OrderedDict([('vdu_id', vdu_id), ('cpd', cpd), ])


class yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/virtual-network-interface-requirement/network-interface-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'network-interface-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'virtual-network-interface-requirement', 'network-interface-requirements']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/virtual-network-interface-requirement. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__description', '__support_mandatory',
                 '__network_interface_requirements',)

    _yang_name = 'virtual-network-interface-requirement'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                             defining_module='etsi-nfv-vnfd', yang_type='list',
                                                             is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'virtual-network-interface-requirement']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/name (string)

    YANG Description: Provides a human readable name for the requirement.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Provides a human readable name for the requirement.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/description (string)

    YANG Description: Provides a human readable description of the requirement.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides a human readable description of the requirement.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_support_mandatory(self):
        """
    Getter method for support_mandatory, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/support_mandatory (boolean)

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        return self.__support_mandatory

    def _set_support_mandatory(self, v, load=False):
        """
    Setter method for support_mandatory, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/support_mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_support_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_support_mandatory() directly.

    YANG Description: Indicates whether fulfilling the constraint is
mandatory (true) for successful operation or desirable
(false).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """support_mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="support-mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__support_mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_support_mandatory(self):
        self.__support_mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                yang_name="support-mandatory", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_network_interface_requirements(self):
        """
    Getter method for network_interface_requirements, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements (list)

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        return self.__network_interface_requirements

    def _set_network_interface_requirements(self, v, load=False):
        """
    Setter method for network_interface_requirements, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement/network_interface_requirements (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_interface_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_interface_requirements() directly.

    YANG Description: The network interface requirements. An element from an
array of key-value pairs that articulate the network
interface deployment requirements.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                  yang_name="network-interface-requirements", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="network-interface-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_interface_requirements must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements, yang_name="network-interface-requirements", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="network-interface-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__network_interface_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_interface_requirements(self):
        self.__network_interface_requirements = YANGDynClass(base=YANGListType("key",
                                                                               yc_network_interface_requirements_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement_network_interface_requirements,
                                                                               yang_name="network-interface-requirements",
                                                                               parent=self, is_container='list',
                                                                               user_ordered=False,
                                                                               path_helper=self._path_helper,
                                                                               yang_keys='key', extensions=None),
                                                             is_container='list',
                                                             yang_name="network-interface-requirements", parent=self,
                                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                                             register_paths=True, extensions=None,
                                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                             defining_module='etsi-nfv-vnfd', yang_type='list',
                                                             is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    support_mandatory = __builtin__.property(_get_support_mandatory, _set_support_mandatory)
    network_interface_requirements = __builtin__.property(_get_network_interface_requirements,
                                                          _set_network_interface_requirements)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('description', description), ('support_mandatory', support_mandatory),
         ('network_interface_requirements', network_interface_requirements), ])


class yc_l2_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l2_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/protocol/address-data/l2-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
  """
    __slots__ = ('_path_helper', '_extmethods', '__mac_address_assignment',)

    _yang_name = 'l2-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                     is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'protocol', 'address-data', 'l2-address-data']

    def _get_mac_address_assignment(self):
        """
    Getter method for mac_address_assignment, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        return self.__mac_address_assignment

    def _set_mac_address_assignment(self, v, load=False):
        """
    Setter method for mac_address_assignment, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l2_address_data/mac_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mac_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mac_address_assignment() directly.

    YANG Description: Specify if the MAC address assignment is the
responsibility of management and orchestration function
or not. If it is set to True, it is the management and
orchestration function responsibility. If it is set to
False, it will be provided by an external entity,
e.g. OSS/BSS.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mac_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__mac_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mac_address_assignment(self):
        self.__mac_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="mac-address-assignment",
                                                     parent=self, path_helper=self._path_helper,
                                                     extmethods=self._extmethods, register_paths=True,
                                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                     is_config=True)

    mac_address_assignment = __builtin__.property(_get_mac_address_assignment, _set_mac_address_assignment)

    _pyangbind_elements = OrderedDict([('mac_address_assignment', mac_address_assignment), ])


class yc_l3_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l3_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/protocol/address-data/l3-address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__ip_address_assignment', '__floating_ip_activated', '__ip_address_type',
        '__number_of_ip_addresses',)

    _yang_name = 'l3-address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'protocol', 'address-data', 'l3-address-data']

    def _get_ip_address_assignment(self):
        """
    Getter method for ip_address_assignment, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility. 
    """
        return self.__ip_address_assignment

    def _set_ip_address_assignment(self, v, load=False):
        """
    Setter method for ip_address_assignment, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_assignment (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_assignment is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_assignment() directly.

    YANG Description: Specify if the address assignment is the responsibility
of management and orchestration function or not. If it
is set to True, it is the management and orchestration
function responsibility. 
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_assignment must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__ip_address_assignment = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_assignment(self):
        self.__ip_address_assignment = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="ip-address-assignment",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)

    def _get_floating_ip_activated(self):
        """
    Getter method for floating_ip_activated, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        return self.__floating_ip_activated

    def _set_floating_ip_activated(self, v, load=False):
        """
    Setter method for floating_ip_activated, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/floating_ip_activated (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_floating_ip_activated is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_floating_ip_activated() directly.

    YANG Description: Specify if the floating IP scheme is activated on the CP
or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """floating_ip_activated must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__floating_ip_activated = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_floating_ip_activated(self):
        self.__floating_ip_activated = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="floating-ip-activated",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                    is_config=True)

    def _get_ip_address_type(self):
        """
    Getter method for ip_address_type, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        return self.__ip_address_type

    def _set_ip_address_type(self, v, load=False):
        """
    Setter method for ip_address_type, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/ip_address_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_address_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_address_type() directly.

    YANG Description: Define address type. The address type should be aligned
with the address type supported by the layerProtocol
attribute of the parent VnfExtCpd.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
                             yang_name="ip-address-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_address_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), is_leaf=True, yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_address_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_address_type(self):
        self.__ip_address_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'ipv4': {}, 'ipv6': {}}, ), is_leaf=True,
            yang_name="ip-address-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)

    def _get_number_of_ip_addresses(self):
        """
    Getter method for number_of_ip_addresses, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        return self.__number_of_ip_addresses

    def _set_number_of_ip_addresses(self, v, load=False):
        """
    Setter method for number_of_ip_addresses, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data/number_of_ip_addresses (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_ip_addresses is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_ip_addresses() directly.

    YANG Description: Minimum number of IP addresses to be assigned based on
this L3AddressData information element.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="number-of-ip-addresses",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_ip_addresses must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_ip_addresses = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_ip_addresses(self):
        self.__number_of_ip_addresses = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="number-of-ip-addresses", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    ip_address_assignment = __builtin__.property(_get_ip_address_assignment, _set_ip_address_assignment)
    floating_ip_activated = __builtin__.property(_get_floating_ip_activated, _set_floating_ip_activated)
    ip_address_type = __builtin__.property(_get_ip_address_type, _set_ip_address_type)
    number_of_ip_addresses = __builtin__.property(_get_number_of_ip_addresses, _set_number_of_ip_addresses)

    _pyangbind_elements = OrderedDict(
        [('ip_address_assignment', ip_address_assignment), ('floating_ip_activated', floating_ip_activated),
         ('ip_address_type', ip_address_type), ('number_of_ip_addresses', number_of_ip_addresses), ])


class yc_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/protocol/address-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
  """
    __slots__ = ('_path_helper', '_extmethods', '__type', '__l2_address_data', '__l3_address_data',)

    _yang_name = 'address-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'protocol', 'address-data']

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/type (identityref)

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
  • MAC address.
  • IP address.
  • Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/type (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Describes the type of the address to be assigned to the
CP instantiated from the parent CPD.
Value:
  • MAC address.
  • IP address.
  • Etc.
The content type shall be aligned with the address type
supported by the layerProtocol attribute of the parent
CPD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mac-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ip-address': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={
                                                                'mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:mac-address': {'@module': 'etsi-nfv-descriptors',
                                                                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'nfv:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                'vnf:ip-address': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)

    def _get_l2_address_data(self):
        """
    Getter method for l2_address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l2_address_data (container)

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        return self.__l2_address_data

    def _set_l2_address_data(self, v, load=False):
        """
    Setter method for l2_address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l2_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_address_data() directly.

    YANG Description: Provides the information on the MAC addresses to be
assigned to the CP(s) instantiated from the parent CPD.
Shall be present when the addressType is MAC address.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l2_address_data,
                             is_container='container', yang_name="l2-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l2_address_data, is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l2_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_address_data(self):
        self.__l2_address_data = YANGDynClass(
            base=yc_l2_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l2_address_data,
            is_container='container', yang_name="l2-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_l3_address_data(self):
        """
    Getter method for l3_address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    """
        return self.__l3_address_data

    def _set_l3_address_data(self, v, load=False):
        """
    Setter method for l3_address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data/l3_address_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_address_data() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l3_address_data,
                             is_container='container', yang_name="l3-address-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_address_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l3_address_data, is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l3_address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_address_data(self):
        self.__l3_address_data = YANGDynClass(
            base=yc_l3_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data_l3_address_data,
            is_container='container', yang_name="l3-address-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    type = __builtin__.property(_get_type, _set_type)
    l2_address_data = __builtin__.property(_get_l2_address_data, _set_l2_address_data)
    l3_address_data = __builtin__.property(_get_l3_address_data, _set_l3_address_data)

    _pyangbind_elements = OrderedDict(
        [('type', type), ('l2_address_data', l2_address_data), ('l3_address_data', l3_address_data), ])


class yc_protocol_etsi_nfv_vnfd__vnfd_ext_cpd_protocol(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd/protocol. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
  """
    __slots__ = ('_path_helper', '_extmethods', '__associated_layer_protocol', '__address_data',)

    _yang_name = 'protocol'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd', 'protocol']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /vnfd/ext_cpd/protocol/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /vnfd/ext_cpd/protocol/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of the Cpd
IE.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref',
            is_config=True)

    def _get_address_data(self):
        """
    Getter method for address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data (list)

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        return self.__address_data

    def _set_address_data(self, v, load=False):
        """
    Setter method for address_data, mapped from YANG variable /vnfd/ext_cpd/protocol/address_data (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_address_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_address_data() directly.

    YANG Description: Provides information on the addresses to be assigned to the
CP(s) instantiated from the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("type",
                                                  yc_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data,
                                                  yang_name="address-data", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='type',
                                                  extensions=None), is_container='list', yang_name="address-data",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """address_data must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("type",yc_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data, yang_name="address-data", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list', yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__address_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_address_data(self):
        self.__address_data = YANGDynClass(
            base=YANGListType("type", yc_address_data_etsi_nfv_vnfd__vnfd_ext_cpd_protocol_address_data,
                              yang_name="address-data", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='type', extensions=None), is_container='list',
            yang_name="address-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    address_data = __builtin__.property(_get_address_data, _set_address_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('address_data', address_data), ])


class yc_ext_cpd_etsi_nfv_vnfd__vnfd_ext_cpd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/ext-cpd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
  """
    __slots__ = ('_path_helper', '_extmethods', '__int_virtual_link_desc', '__int_cpd', '__k8s_cluster_net',
                 '__virtual_network_interface_requirement', '__nicio_requirements', '__id', '__layer_protocol',
                 '__role', '__description', '__protocol', '__trunk_mode', '__security_group_rule_id',
                 '__port_security_enabled', '__port_security_disable_strategy',)

    _yang_name = 'ext-cpd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, choice=('cp-connection', 'int-virtual-link-desc'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                    is_config=True)
        self.__int_cpd = YANGDynClass(base=yc_int_cpd_etsi_nfv_vnfd__vnfd_ext_cpd_int_cpd, is_container='container',
                                      yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        self.__k8s_cluster_net = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="k8s-cluster-net",
                                              parent=self, choice=('cp-connection', 'k8s-cluster-net'),
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
                                              defining_module='kdu', yang_type='leafref', is_config=True)
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                    defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                    is_config=True)
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_vnfd__vnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                     is_config=True)
        self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                                    yang_name="port-security-enabled", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                                    defining_module='various', yang_type='boolean', is_config=True)
        self.__port_security_disable_strategy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
            default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'ext-cpd']

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /vnfd/ext_cpd/int_virtual_link_desc (leafref)

    YANG Description: Reference to the internal Virtual Link Descriptor (VLD)
to which CPs instantiated from this external CP
Descriptor (CPD) connect. Either intVirtualLinkDesc or
intCpd shall be present.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /vnfd/ext_cpd/int_virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Reference to the internal Virtual Link Descriptor (VLD)
to which CPs instantiated from this external CP
Descriptor (CPD) connect. Either intVirtualLinkDesc or
intCpd shall be present.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self,
                             choice=('cp-connection', 'int-virtual-link-desc'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc", parent=self, choice=('cp-connection', 'int-virtual-link-desc'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="int-virtual-link-desc",
                                                    parent=self, choice=('cp-connection', 'int-virtual-link-desc'),
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                    is_config=True)

    def _get_int_cpd(self):
        """
    Getter method for int_cpd, mapped from YANG variable /vnfd/ext_cpd/int_cpd (container)
    """
        return self.__int_cpd

    def _set_int_cpd(self, v, load=False):
        """
    Setter method for int_cpd, mapped from YANG variable /vnfd/ext_cpd/int_cpd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_cpd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_int_cpd_etsi_nfv_vnfd__vnfd_ext_cpd_int_cpd, is_container='container',
                             yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_cpd must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_int_cpd_etsi_nfv_vnfd__vnfd_ext_cpd_int_cpd, is_container='container', yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__int_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_cpd(self):
        self.__int_cpd = YANGDynClass(base=yc_int_cpd_etsi_nfv_vnfd__vnfd_ext_cpd_int_cpd, is_container='container',
                                      yang_name="int-cpd", parent=self, choice=('cp-connection', 'int-cpd'),
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    def _get_k8s_cluster_net(self):
        """
    Getter method for k8s_cluster_net, mapped from YANG variable /vnfd/ext_cpd/k8s_cluster_net (leafref)

    YANG Description: Reference to the K8s cluster network
to which CPs instantiated from this external CP
Descriptor (CPD) connect.
    """
        return self.__k8s_cluster_net

    def _set_k8s_cluster_net(self, v, load=False):
        """
    Setter method for k8s_cluster_net, mapped from YANG variable /vnfd/ext_cpd/k8s_cluster_net (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_k8s_cluster_net is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_k8s_cluster_net() directly.

    YANG Description: Reference to the K8s cluster network
to which CPs instantiated from this external CP
Descriptor (CPD) connect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="k8s-cluster-net", parent=self,
                             choice=('cp-connection', 'k8s-cluster-net'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='leafref',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """k8s_cluster_net must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="k8s-cluster-net", parent=self, choice=('cp-connection', 'k8s-cluster-net'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='leafref', is_config=True)""",
            })

        self.__k8s_cluster_net = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_k8s_cluster_net(self):
        self.__k8s_cluster_net = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="k8s-cluster-net",
                                              parent=self, choice=('cp-connection', 'k8s-cluster-net'),
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
                                              defining_module='kdu', yang_type='leafref', is_config=True)

    def _get_virtual_network_interface_requirement(self):
        """
    Getter method for virtual_network_interface_requirement, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement (list)

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        return self.__virtual_network_interface_requirement

    def _set_virtual_network_interface_requirement(self, v, load=False):
        """
    Setter method for virtual_network_interface_requirement, mapped from YANG variable /vnfd/ext_cpd/virtual_network_interface_requirement (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_network_interface_requirement is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_network_interface_requirement() directly.

    YANG Description: Specifies requirements on a virtual network interface
realising the CPs instantiated from this CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement,
                                                  yang_name="virtual-network-interface-requirement", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="virtual-network-interface-requirement", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_network_interface_requirement must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement, yang_name="virtual-network-interface-requirement", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="virtual-network-interface-requirement", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_network_interface_requirement = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_network_interface_requirement(self):
        self.__virtual_network_interface_requirement = YANGDynClass(base=YANGListType("name",
                                                                                      yc_virtual_network_interface_requirement_etsi_nfv_vnfd__vnfd_ext_cpd_virtual_network_interface_requirement,
                                                                                      yang_name="virtual-network-interface-requirement",
                                                                                      parent=self, is_container='list',
                                                                                      user_ordered=False,
                                                                                      path_helper=self._path_helper,
                                                                                      yang_keys='name',
                                                                                      extensions=None),
                                                                    is_container='list',
                                                                    yang_name="virtual-network-interface-requirement",
                                                                    parent=self, path_helper=self._path_helper,
                                                                    extmethods=self._extmethods, register_paths=True,
                                                                    extensions=None,
                                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                    defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                    is_config=True)

    def _get_nicio_requirements(self):
        """
    Getter method for nicio_requirements, mapped from YANG variable /vnfd/ext_cpd/nicio_requirements (leafref)

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        return self.__nicio_requirements

    def _set_nicio_requirements(self, v, load=False):
        """
    Setter method for nicio_requirements, mapped from YANG variable /vnfd/ext_cpd/nicio_requirements (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nicio_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nicio_requirements() directly.

    YANG Description: This references (couples) the CPD with any logical node I/O
requirements (for network devices) that may have been
created. Linking these attributes is necessary so that so
that I/O requirements that need to be articulated at the
logical node level can be associated with the network
interface requirements associated with the CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nicio_requirements must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__nicio_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nicio_requirements(self):
        self.__nicio_requirements = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="nicio-requirements",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/ext_cpd/id (string)

    YANG Description: Identifier of this Cpd information element.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/ext_cpd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this Cpd information element.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_layer_protocol(self):
        """
    Getter method for layer_protocol, mapped from YANG variable /vnfd/ext_cpd/layer_protocol (identityref)

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        return self.__layer_protocol

    def _set_layer_protocol(self, v, load=False):
        """
    Setter method for layer_protocol, mapped from YANG variable /vnfd/ext_cpd/layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_layer_protocol() directly.

    YANG Description: Identifies a protocol that the connection points
corresponding to the CPD support for connectivity purposes
(e.g. Ethernet, MPLS, ODU2, IPV4, IPV6, Pseudo-Wire, etc.).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), default=six.text_type("ethernet"), is_leaf=False, yang_name="layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_layer_protocol(self):
        self.__layer_protocol = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                             default=six.text_type("ethernet"), is_leaf=False,
                                             yang_name="layer-protocol", parent=self, path_helper=self._path_helper,
                                             extmethods=self._extmethods, register_paths=True,
                                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                             defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)

    def _get_role(self):
        """
    Getter method for role, mapped from YANG variable /vnfd/ext_cpd/role (identityref)

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        return self.__role

    def _set_role(self, v, load=False):
        """
    Setter method for role, mapped from YANG variable /vnfd/ext_cpd/role (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_role is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_role() directly.

    YANG Description: Identifies the role of the connection points
corresponding to the CPD in the context of the traffic
flow patterns in the VNF, PNF or NS. For example an NS with
a tree flow pattern within the NS will have legal cpRoles
of ROOT and LEAF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:root': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'nfv:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                          'vnf:leaf': {
                                                                              '@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """role must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:root': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:leaf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__role = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_role(self):
        self.__role = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'root': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:root': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'leaf': {'@module': 'etsi-nfv-descriptors',
                                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'nfv:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                                             'vnf:leaf': {
                                                                                 '@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                                   is_leaf=True, yang_name="role", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='identityref', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/ext_cpd/description (string)

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/ext_cpd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Provides human-readable information on the purpose of the
connection point (e.g. connection point for control plane
traffic).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_protocol(self):
        """
    Getter method for protocol, mapped from YANG variable /vnfd/ext_cpd/protocol (list)

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        return self.__protocol

    def _set_protocol(self, v, load=False):
        """
    Setter method for protocol, mapped from YANG variable /vnfd/ext_cpd/protocol (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_protocol() directly.

    YANG Description: Identifies the protocol layering information the CP uses for
connectivity purposes and associated information. There shall
be one cpProtocol for each layer protocol as indicated by the
attribute layerProtocol. When a PnfExtCpd as defined in ETSI
GS NFV-IFA 014 [i.8] is inherited from this Cpd, the
cardinality is set to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("associated_layer_protocol",
                                                  yc_protocol_etsi_nfv_vnfd__vnfd_ext_cpd_protocol,
                                                  yang_name="protocol", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='associated-layer-protocol', extensions=None),
                             is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """protocol must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("associated_layer_protocol",yc_protocol_etsi_nfv_vnfd__vnfd_ext_cpd_protocol, yang_name="protocol", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None), is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_protocol(self):
        self.__protocol = YANGDynClass(
            base=YANGListType("associated_layer_protocol", yc_protocol_etsi_nfv_vnfd__vnfd_ext_cpd_protocol,
                              yang_name="protocol", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='associated-layer-protocol', extensions=None),
            is_container='list', yang_name="protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_trunk_mode(self):
        """
    Getter method for trunk_mode, mapped from YANG variable /vnfd/ext_cpd/trunk_mode (boolean)

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        return self.__trunk_mode

    def _set_trunk_mode(self, v, load=False):
        """
    Setter method for trunk_mode, mapped from YANG variable /vnfd/ext_cpd/trunk_mode (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trunk_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trunk_mode() directly.

    YANG Description: Information about whether the Cp instantiated from this CPD
is in Trunk mode (802.1Q or other). When operating in
'trunk mode', the Cp is capable of carrying traffic for
several VLANs. A cardinality of 0 implies that trunkMode
is not configured for the Cp i.e. It is equivalent to
Boolean value 'false'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trunk_mode must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__trunk_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trunk_mode(self):
        self.__trunk_mode = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="trunk-mode", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_security_group_rule_id(self):
        """
    Getter method for security_group_rule_id, mapped from YANG variable /vnfd/ext_cpd/security_group_rule_id (leafref)

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        return self.__security_group_rule_id

    def _set_security_group_rule_id(self, v, load=False):
        """
    Setter method for security_group_rule_id, mapped from YANG variable /vnfd/ext_cpd/security_group_rule_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule_id() directly.

    YANG Description: Reference of the security group rules bound to this
CPD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group-rule-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__security_group_rule_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule_id(self):
        self.__security_group_rule_id = YANGDynClass(base=six.text_type, is_leaf=True,
                                                     yang_name="security-group-rule-id", parent=self,
                                                     path_helper=self._path_helper, extmethods=self._extmethods,
                                                     register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                     defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                     is_config=True)

    def _get_port_security_enabled(self):
        """
    Getter method for port_security_enabled, mapped from YANG variable /vnfd/ext_cpd/port_security_enabled (boolean)

    YANG Description: Enables the port security for the port.
    """
        return self.__port_security_enabled

    def _set_port_security_enabled(self, v, load=False):
        """
    Setter method for port_security_enabled, mapped from YANG variable /vnfd/ext_cpd/port_security_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_enabled() directly.

    YANG Description: Enables the port security for the port.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True,
                             yang_name="port-security-enabled", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_security_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="port-security-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='boolean', is_config=True)""",
            })

        self.__port_security_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_security_enabled(self):
        self.__port_security_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                                    yang_name="port-security-enabled", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                                    defining_module='various', yang_type='boolean', is_config=True)

    def _get_port_security_disable_strategy(self):
        """
    Getter method for port_security_disable_strategy, mapped from YANG variable /vnfd/ext_cpd/port_security_disable_strategy (enumeration)

    YANG Description: Strategy to disable port security, either Enables the port security for the port.
full                : disable port security in the whole port
allow-address-pairs : allow address pairs for virtual IP (any virtual IP can be configured)
    """
        return self.__port_security_disable_strategy

    def _set_port_security_disable_strategy(self, v, load=False):
        """
    Setter method for port_security_disable_strategy, mapped from YANG variable /vnfd/ext_cpd/port_security_disable_strategy (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_port_security_disable_strategy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_port_security_disable_strategy() directly.

    YANG Description: Strategy to disable port security, either Enables the port security for the port.
full                : disable port security in the whole port
allow-address-pairs : allow address pairs for virtual IP (any virtual IP can be configured)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
                             default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                             defining_module='various', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """port_security_disable_strategy must be of a type compatible with enumeration""",
                'defined-type': "various:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'full': {}, 'allow-address-pairs': {}},), default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration', is_config=True)""",
            })

        self.__port_security_disable_strategy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_port_security_disable_strategy(self):
        self.__port_security_disable_strategy = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'full': {}, 'allow-address-pairs': {}}, ),
            default=six.text_type("full"), is_leaf=True, yang_name="port-security-disable-strategy", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='enumeration',
            is_config=True)

    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    int_cpd = __builtin__.property(_get_int_cpd, _set_int_cpd)
    k8s_cluster_net = __builtin__.property(_get_k8s_cluster_net, _set_k8s_cluster_net)
    virtual_network_interface_requirement = __builtin__.property(_get_virtual_network_interface_requirement,
                                                                 _set_virtual_network_interface_requirement)
    nicio_requirements = __builtin__.property(_get_nicio_requirements, _set_nicio_requirements)
    id = __builtin__.property(_get_id, _set_id)
    layer_protocol = __builtin__.property(_get_layer_protocol, _set_layer_protocol)
    role = __builtin__.property(_get_role, _set_role)
    description = __builtin__.property(_get_description, _set_description)
    protocol = __builtin__.property(_get_protocol, _set_protocol)
    trunk_mode = __builtin__.property(_get_trunk_mode, _set_trunk_mode)
    security_group_rule_id = __builtin__.property(_get_security_group_rule_id, _set_security_group_rule_id)
    port_security_enabled = __builtin__.property(_get_port_security_enabled, _set_port_security_enabled)
    port_security_disable_strategy = __builtin__.property(_get_port_security_disable_strategy,
                                                          _set_port_security_disable_strategy)

    __choices__ = {'cp-connection': {'int-virtual-link-desc': ['int_virtual_link_desc'], 'int-cpd': ['int_cpd'],
                                     'k8s-cluster-net': ['k8s_cluster_net']}}
    _pyangbind_elements = OrderedDict(
        [('int_virtual_link_desc', int_virtual_link_desc), ('int_cpd', int_cpd), ('k8s_cluster_net', k8s_cluster_net),
         ('virtual_network_interface_requirement', virtual_network_interface_requirement),
         ('nicio_requirements', nicio_requirements), ('id', id), ('layer_protocol', layer_protocol), ('role', role),
         ('description', description), ('protocol', protocol), ('trunk_mode', trunk_mode),
         ('security_group_rule_id', security_group_rule_id), ('port_security_enabled', port_security_enabled),
         ('port_security_disable_strategy', port_security_disable_strategy), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/vdu-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'vdu-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-vnfd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-vnfd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_vdu_profile_affinity_or_anti_affinity_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/vdu-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'vdu-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/vdu_profile/affinity_or_anti_affinity_group/id (leafref)

    YANG Description: Identifies an affinity or anti-affinity group to
which the affinity or anti-affinity rule applies.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/vdu_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies an affinity or anti-affinity group to
which the affinity or anti-affinity rule applies.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_vdu_profile_etsi_nfv_vnfd__vnfd_df_vdu_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/vdu-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__min_number_of_instances', '__max_number_of_instances',
                 '__local_affinity_or_anti_affinity_rule', '__affinity_or_anti_affinity_group',)

    _yang_name = 'vdu-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'vdu-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/vdu_profile/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/vdu_profile/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_min_number_of_instances(self):
        """
    Getter method for min_number_of_instances, mapped from YANG variable /vnfd/df/vdu_profile/min_number_of_instances (uint16)

    YANG Description: Minimum number of instances of the VNFC based on this
VDU that is permitted to exist for this flavour.
    """
        return self.__min_number_of_instances

    def _set_min_number_of_instances(self, v, load=False):
        """
    Setter method for min_number_of_instances, mapped from YANG variable /vnfd/df/vdu_profile/min_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_number_of_instances() directly.

    YANG Description: Minimum number of instances of the VNFC based on this
VDU that is permitted to exist for this flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__min_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_number_of_instances(self):
        self.__min_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="min-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    def _get_max_number_of_instances(self):
        """
    Getter method for max_number_of_instances, mapped from YANG variable /vnfd/df/vdu_profile/max_number_of_instances (uint16)
    """
        return self.__max_number_of_instances

    def _set_max_number_of_instances(self, v, load=False):
        """
    Setter method for max_number_of_instances, mapped from YANG variable /vnfd/df/vdu_profile/max_number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_number_of_instances() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True,
                             yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__max_number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_number_of_instances(self):
        self.__max_number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="max-number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /vnfd/df/vdu_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_vdu_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/vdu_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/vdu_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VDU belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_vdu_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_vdu_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    min_number_of_instances = __builtin__.property(_get_min_number_of_instances, _set_min_number_of_instances)
    max_number_of_instances = __builtin__.property(_get_max_number_of_instances, _set_max_number_of_instances)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)

    _pyangbind_elements = OrderedDict([('id', id), ('min_number_of_instances', min_number_of_instances),
                                       ('max_number_of_instances', max_number_of_instances),
                                       ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group), ])


class yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/local-affinity-or-anti-affinity-rule. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__affinity_type', '__affinity_scope',)

    _yang_name = 'local-affinity-or-anti-affinity-rule'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'local-affinity-or-anti-affinity-rule']

    def _get_affinity_type(self):
        """
    Getter method for affinity_type, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__affinity_type

    def _set_affinity_type(self, v, load=False):
        """
    Setter method for affinity_type, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-vnfd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)""",
            })

        self.__affinity_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_type(self):
        self.__affinity_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'affinity': {}, 'anti-affinity': {}}, ), is_leaf=True,
            yang_name="affinity-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)

    def _get_affinity_scope(self):
        """
    Getter method for affinity_scope, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__affinity_scope

    def _set_affinity_scope(self, v, load=False):
        """
    Setter method for affinity_scope, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule/affinity_scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-vnfd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__affinity_scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_scope(self):
        self.__affinity_scope = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}}, ),
            is_leaf=True, yang_name="affinity-scope", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope',
            is_config=True)

    affinity_type = __builtin__.property(_get_affinity_type, _set_affinity_type)
    affinity_scope = __builtin__.property(_get_affinity_scope, _set_affinity_scope)

    _pyangbind_elements = OrderedDict([('affinity_type', affinity_type), ('affinity_scope', affinity_scope), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_max_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_max_bit_rate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/max-bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'max-bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'max-bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_min_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_min_bit_rate_requirements(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/min-bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'min-bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'min-bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g. bitrate of
E-Line, root bitrate of E-Tree, aggregate capacity
of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to the
link when applicable to the connectivity type
(e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_l2_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/virtual-link-protocol-data/l2-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__network_type', '__vlan_transparent', '__mtu',)

    _yang_name = 'l2-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l2-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)

    YANG Description: Network name associated with this L2 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_network_type(self):
        """
    Getter method for network_type, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        return self.__network_type

    def _set_network_type(self, v, load=False):
        """
    Setter method for network_type, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/network_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_network_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_network_type() directly.

    YANG Description: Specifies the network type for this L2 protocol.
Possible values: FLAT, VLAN, VXLAN, GRE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {},
                                                                          'gre': {}}, ), is_leaf=True,
                             yang_name="network-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """network_type must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}},), is_leaf=True, yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__network_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_network_type(self):
        self.__network_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'flat': {}, 'vlan': {}, 'vxlan': {}, 'gre': {}}, ), is_leaf=True,
            yang_name="network-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='enumeration', is_config=True)

    def _get_vlan_transparent(self):
        """
    Getter method for vlan_transparent, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        return self.__vlan_transparent

    def _set_vlan_transparent(self, v, load=False):
        """
    Setter method for vlan_transparent, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/vlan_transparent (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vlan_transparent is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vlan_transparent() directly.

    YANG Description: Specifies whether to support VLAN transparency for
this L2 protocol or not.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vlan_transparent must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__vlan_transparent = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vlan_transparent(self):
        self.__vlan_transparent = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="vlan-transparent", parent=self,
                                               path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_mtu(self):
        """
    Getter method for mtu, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        return self.__mtu

    def _set_mtu(self, v, load=False):
        """
    Setter method for mtu, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data/mtu (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mtu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mtu() directly.

    YANG Description: Specifies the maximum transmission unit (MTU) value
for this L2 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16), is_leaf=True, yang_name="mtu", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mtu must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__mtu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mtu(self):
        self.__mtu = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            is_leaf=True, yang_name="mtu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint16', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    network_type = __builtin__.property(_get_network_type, _set_network_type)
    vlan_transparent = __builtin__.property(_get_vlan_transparent, _set_vlan_transparent)
    mtu = __builtin__.property(_get_mtu, _set_mtu)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('network_type', network_type), ('vlan_transparent', vlan_transparent), ('mtu', mtu), ])


class yc_l3_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/virtual-link-protocol-data/l3-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__ip_version', '__cidr', '__ip_allocation_pools', '__gateway_ip',
        '__dhcp_enabled', '__ipv6_address_mode', '__description', '__security_group',)

    _yang_name = 'l3-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='inet:ip-address', is_config=True)
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                           yang_type='boolean', is_config=True)
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)
        self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                             defining_module='various', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data', 'l3-protocol-data']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)

    YANG Description: Network name associated with this L3 protocol.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Network name associated with this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_ip_version(self):
        """
    Getter method for ip_version, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)

    YANG Description: Specifies IP version of this L3 protocol.
Value:
• IPV4.
• IPV6.
    """
        return self.__ip_version

    def _set_ip_version(self, v, load=False):
        """
    Setter method for ip_version, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_version() directly.

    YANG Description: Specifies IP version of this L3 protocol.
Value:
• IPV4.
• IPV6.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                             default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_version must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'ipv4': {}, 'ipv6': {}},), default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__ip_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_version(self):
        self.__ip_version = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                  restriction_arg={'ipv4': {}, 'ipv6': {}}, ),
                                         default=six.text_type("ipv4"), is_leaf=True, yang_name="ip-version",
                                         parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_cidr(self):
        """
    Getter method for cidr, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        return self.__cidr

    def _set_cidr(self, v, load=False):
        """
    Setter method for cidr, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/cidr (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cidr is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cidr() directly.

    YANG Description: Specifies the CIDR (Classless InterDomain Routing)
of this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cidr must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__cidr = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cidr(self):
        self.__cidr = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="cidr", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_ip_allocation_pools(self):
        """
    Getter method for ip_allocation_pools, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        return self.__ip_allocation_pools

    def _set_ip_allocation_pools(self, v, load=False):
        """
    Setter method for ip_allocation_pools, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ip_allocation_pools (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ip_allocation_pools is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ip_allocation_pools() directly.

    YANG Description: Specifies the allocation pools with start and end
IP addresses for this L3 protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ip_allocation_pools must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="ip-allocation-pools", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__ip_allocation_pools = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ip_allocation_pools(self):
        self.__ip_allocation_pools = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                  is_leaf=False, yang_name="ip-allocation-pools", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_gateway_ip(self):
        """
    Getter method for gateway_ip, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        return self.__gateway_ip

    def _set_gateway_ip(self, v, load=False):
        """
    Setter method for gateway_ip, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/gateway_ip (inet:ip-address)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_gateway_ip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_gateway_ip() directly.

    YANG Description: Specifies the gateway IP address for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
                'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                      RestrictedClassType(base_type=six.text_type, restriction_dict={
                                          'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                             is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='inet:ip-address', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """gateway_ip must be of a type compatible with inet:ip-address""",
                'defined-type': "inet:ip-address",
                'generated-type': """YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),RestrictedClassType(base_type=six.text_type, restriction_dict={'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}),], is_leaf=True, yang_name="gateway-ip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='inet:ip-address', is_config=True)""",
            })

        self.__gateway_ip = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_gateway_ip(self):
        self.__gateway_ip = YANGDynClass(base=[RestrictedClassType(base_type=six.text_type, restriction_dict={
            'pattern': '(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\\p{N}\\p{L}]+)?'}),
                                               RestrictedClassType(base_type=six.text_type, restriction_dict={
                                                   'pattern': '((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\\p{N}\\p{L}]+)?'}), ],
                                         is_leaf=True, yang_name="gateway-ip", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='inet:ip-address', is_config=True)

    def _get_dhcp_enabled(self):
        """
    Getter method for dhcp_enabled, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        return self.__dhcp_enabled

    def _set_dhcp_enabled(self, v, load=False):
        """
    Setter method for dhcp_enabled, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/dhcp_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_dhcp_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_dhcp_enabled() directly.

    YANG Description: Indicates whether DHCP (Dynamic Host Configuration
Protocol) is enabled or disabled for this L3
protocol.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """dhcp_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__dhcp_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_dhcp_enabled(self):
        self.__dhcp_enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True,
                                           yang_name="dhcp-enabled", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                           yang_type='boolean', is_config=True)

    def _get_ipv6_address_mode(self):
        """
    Getter method for ipv6_address_mode, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)

    YANG Description: Specifies IPv6 address mode. Possible values:
• SLAAC.
• DHCPV6-STATEFUL.
• DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        return self.__ipv6_address_mode

    def _set_ipv6_address_mode(self, v, load=False):
        """
    Setter method for ipv6_address_mode, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/ipv6_address_mode (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ipv6_address_mode is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ipv6_address_mode() directly.

    YANG Description: Specifies IPv6 address mode. Possible values:
• SLAAC.
• DHCPV6-STATEFUL.
• DHCPV6-STATELESS.
May be present when the value of the ipVersion
attribute is 'IPV6' and shall be absent otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'slaac': {}, 'dhcpv6-stateful': {},
                                                                          'dhcpv6-stateless': {}}, ), is_leaf=True,
                             yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ipv6_address_mode must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}},), is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__ipv6_address_mode = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ipv6_address_mode(self):
        self.__ipv6_address_mode = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'slaac': {}, 'dhcpv6-stateful': {}, 'dhcpv6-stateless': {}}, ),
            is_leaf=True, yang_name="ipv6-address-mode", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/description (string)
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)

    def _get_security_group(self):
        """
    Getter method for security_group, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/security_group (string)

    YANG Description: Name of the security group
    """
        return self.__security_group

    def _set_security_group(self, v, load=False):
        """
    Setter method for security_group, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data/security_group (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group() directly.

    YANG Description: Name of the security group
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:various', defining_module='various',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:various', defining_module='various', yang_type='string', is_config=True)""",
            })

        self.__security_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group(self):
        self.__security_group = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="security-group", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:various',
                                             defining_module='various', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    ip_version = __builtin__.property(_get_ip_version, _set_ip_version)
    cidr = __builtin__.property(_get_cidr, _set_cidr)
    ip_allocation_pools = __builtin__.property(_get_ip_allocation_pools, _set_ip_allocation_pools)
    gateway_ip = __builtin__.property(_get_gateway_ip, _set_gateway_ip)
    dhcp_enabled = __builtin__.property(_get_dhcp_enabled, _set_dhcp_enabled)
    ipv6_address_mode = __builtin__.property(_get_ipv6_address_mode, _set_ipv6_address_mode)
    description = __builtin__.property(_get_description, _set_description)
    security_group = __builtin__.property(_get_security_group, _set_security_group)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('ip_version', ip_version), ('cidr', cidr), ('ip_allocation_pools', ip_allocation_pools),
         ('gateway_ip', gateway_ip), ('dhcp_enabled', dhcp_enabled), ('ipv6_address_mode', ipv6_address_mode),
         ('description', description), ('security_group', security_group), ])


class yc_virtual_link_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile/virtual-link-protocol-data. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__associated_layer_protocol', '__l2_protocol_data', '__l3_protocol_data',)

    _yang_name = 'virtual-link-protocol-data'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile', 'virtual-link-protocol-data']

    def _get_associated_layer_protocol(self):
        """
    Getter method for associated_layer_protocol, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        return self.__associated_layer_protocol

    def _set_associated_layer_protocol(self, v, load=False):
        """
    Setter method for associated_layer_protocol, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/associated_layer_protocol (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_associated_layer_protocol is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_associated_layer_protocol() directly.

    YANG Description: One of the values of the attribute layerProtocol of
the ConnectivityType IE.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={
                                                             'ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                                                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'mpls': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:mpls': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'odu2': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:odu2': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv4': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:ipv6': {'@module': 'etsi-nfv-descriptors',
                                                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                             '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                                                             'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                                                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ),
                             is_leaf=True, yang_name="associated-layer-protocol", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """associated_layer_protocol must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},), is_leaf=True, yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__associated_layer_protocol = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_associated_layer_protocol(self):
        self.__associated_layer_protocol = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'ethernet': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ethernet': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:mpls': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:odu2': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv4': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:ipv6': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:pseudo-wire': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, ), is_leaf=True,
            yang_name="associated-layer-protocol", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)

    def _get_l2_protocol_data(self):
        """
    Getter method for l2_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        return self.__l2_protocol_data

    def _set_l2_protocol_data(self, v, load=False):
        """
    Setter method for l2_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l2_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l2_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l2_protocol_data() directly.

    YANG Description: Specifies the L2 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L2 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l2_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
                             is_container='container', yang_name="l2-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l2_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l2_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data, is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l2_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l2_protocol_data(self):
        self.__l2_protocol_data = YANGDynClass(
            base=yc_l2_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l2_protocol_data,
            is_container='container', yang_name="l2-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_l3_protocol_data(self):
        """
    Getter method for l3_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        return self.__l3_protocol_data

    def _set_l3_protocol_data(self, v, load=False):
        """
    Setter method for l3_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data/l3_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_l3_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_l3_protocol_data() directly.

    YANG Description: Specifies the L3 protocol data for this virtual link.
Shall be present when the associatedLayerProtocol
attribute indicates a L3 protocol and shall be absent
otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_l3_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
                             is_container='container', yang_name="l3-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """l3_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_l3_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data, is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__l3_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_l3_protocol_data(self):
        self.__l3_protocol_data = YANGDynClass(
            base=yc_l3_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data_l3_protocol_data,
            is_container='container', yang_name="l3-protocol-data", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    associated_layer_protocol = __builtin__.property(_get_associated_layer_protocol, _set_associated_layer_protocol)
    l2_protocol_data = __builtin__.property(_get_l2_protocol_data, _set_l2_protocol_data)
    l3_protocol_data = __builtin__.property(_get_l3_protocol_data, _set_l3_protocol_data)

    _pyangbind_elements = OrderedDict(
        [('associated_layer_protocol', associated_layer_protocol), ('l2_protocol_data', l2_protocol_data),
         ('l3_protocol_data', l3_protocol_data), ])


class yc_virtual_link_profile_etsi_nfv_vnfd__vnfd_df_virtual_link_profile(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/virtual-link-profile. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__flavour', '__local_affinity_or_anti_affinity_rule',
                 '__affinity_or_anti_affinity_group', '__max_bit_rate_requirements', '__min_bit_rate_requirements',
                 '__virtual_link_protocol_data',)

    _yang_name = 'virtual-link-profile'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__flavour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                   is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)
        self.__max_bit_rate_requirements = YANGDynClass(
            base=yc_max_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_max_bit_rate_requirements,
            is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__min_bit_rate_requirements = YANGDynClass(
            base=yc_min_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_min_bit_rate_requirements,
            is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'virtual-link-profile']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/virtual_link_profile/id (leafref)

    YANG Description: Uniquely identifies a Vnf VLD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/virtual_link_profile/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a Vnf VLD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_flavour(self):
        """
    Getter method for flavour, mapped from YANG variable /vnfd/df/virtual_link_profile/flavour (leafref)

    YANG Description: Identifies a flavour within the VnfVirtualLinkDesc.
    """
        return self.__flavour

    def _set_flavour(self, v, load=False):
        """
    Setter method for flavour, mapped from YANG variable /vnfd/df/virtual_link_profile/flavour (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_flavour is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_flavour() directly.

    YANG Description: Identifies a flavour within the VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """flavour must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__flavour = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_flavour(self):
        self.__flavour = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="flavour", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                      defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_local_affinity_or_anti_affinity_rule(self):
        """
    Getter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    """
        return self.__local_affinity_or_anti_affinity_rule

    def _set_local_affinity_or_anti_affinity_rule(self, v, load=False):
        """
    Setter method for local_affinity_or_anti_affinity_rule, mapped from YANG variable /vnfd/df/virtual_link_profile/local_affinity_or_anti_affinity_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_local_affinity_or_anti_affinity_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_local_affinity_or_anti_affinity_rule() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("affinity_type affinity_scope",
                                                  yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                  yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper,
                                                  yang_keys='affinity-type affinity-scope', extensions=None),
                             is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """local_affinity_or_anti_affinity_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("affinity_type affinity_scope",yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule, yang_name="local-affinity-or-anti-affinity-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='affinity-type affinity-scope', extensions=None), is_container='list', yang_name="local-affinity-or-anti-affinity-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__local_affinity_or_anti_affinity_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_local_affinity_or_anti_affinity_rule(self):
        self.__local_affinity_or_anti_affinity_rule = YANGDynClass(base=YANGListType("affinity_type affinity_scope",
                                                                                     yc_local_affinity_or_anti_affinity_rule_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_local_affinity_or_anti_affinity_rule,
                                                                                     yang_name="local-affinity-or-anti-affinity-rule",
                                                                                     parent=self, is_container='list',
                                                                                     user_ordered=False,
                                                                                     path_helper=self._path_helper,
                                                                                     yang_keys='affinity-type affinity-scope',
                                                                                     extensions=None),
                                                                   is_container='list',
                                                                   yang_name="local-affinity-or-anti-affinity-rule",
                                                                   parent=self, path_helper=self._path_helper,
                                                                   extmethods=self._extmethods, register_paths=True,
                                                                   extensions=None,
                                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                   defining_module='etsi-nfv-vnfd', yang_type='list',
                                                                   is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/virtual_link_profile/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: Identifier(s) of the affinity or anti-affinity
group(s) the VnfVirtualLinkDesc belongs to.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)

    def _get_max_bit_rate_requirements(self):
        """
    Getter method for max_bit_rate_requirements, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements (container)

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__max_bit_rate_requirements

    def _set_max_bit_rate_requirements(self, v, load=False):
        """
    Setter method for max_bit_rate_requirements, mapped from YANG variable /vnfd/df/virtual_link_profile/max_bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_bit_rate_requirements() directly.

    YANG Description: Specifies the maximum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_max_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_max_bit_rate_requirements,
                             is_container='container', yang_name="max-bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_max_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_max_bit_rate_requirements, is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__max_bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_bit_rate_requirements(self):
        self.__max_bit_rate_requirements = YANGDynClass(
            base=yc_max_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_max_bit_rate_requirements,
            is_container='container', yang_name="max-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_min_bit_rate_requirements(self):
        """
    Getter method for min_bit_rate_requirements, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements (container)

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        return self.__min_bit_rate_requirements

    def _set_min_bit_rate_requirements(self, v, load=False):
        """
    Setter method for min_bit_rate_requirements, mapped from YANG variable /vnfd/df/virtual_link_profile/min_bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_bit_rate_requirements() directly.

    YANG Description: Specifies the minimum bitrate requirements for a VL
instantiated according to this profile.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_min_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_min_bit_rate_requirements,
                             is_container='container', yang_name="min-bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_min_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_min_bit_rate_requirements, is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__min_bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_bit_rate_requirements(self):
        self.__min_bit_rate_requirements = YANGDynClass(
            base=yc_min_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_min_bit_rate_requirements,
            is_container='container', yang_name="min-bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_virtual_link_protocol_data(self):
        """
    Getter method for virtual_link_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data (container)

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        return self.__virtual_link_protocol_data

    def _set_virtual_link_protocol_data(self, v, load=False):
        """
    Setter method for virtual_link_protocol_data, mapped from YANG variable /vnfd/df/virtual_link_profile/virtual_link_protocol_data (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_protocol_data is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_protocol_data() directly.

    YANG Description: Specifies the protocol data for a VL instantiated
according to this profile. Cardinality 0 is used when
no protocol data needs to be specified.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_virtual_link_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data,
                             is_container='container', yang_name="virtual-link-protocol-data", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_protocol_data must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_virtual_link_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data, is_container='container', yang_name="virtual-link-protocol-data", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__virtual_link_protocol_data = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_protocol_data(self):
        self.__virtual_link_protocol_data = YANGDynClass(
            base=yc_virtual_link_protocol_data_etsi_nfv_vnfd__vnfd_df_virtual_link_profile_virtual_link_protocol_data,
            is_container='container', yang_name="virtual-link-protocol-data", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    flavour = __builtin__.property(_get_flavour, _set_flavour)
    local_affinity_or_anti_affinity_rule = __builtin__.property(_get_local_affinity_or_anti_affinity_rule,
                                                                _set_local_affinity_or_anti_affinity_rule)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    max_bit_rate_requirements = __builtin__.property(_get_max_bit_rate_requirements, _set_max_bit_rate_requirements)
    min_bit_rate_requirements = __builtin__.property(_get_min_bit_rate_requirements, _set_min_bit_rate_requirements)
    virtual_link_protocol_data = __builtin__.property(_get_virtual_link_protocol_data, _set_virtual_link_protocol_data)

    _pyangbind_elements = OrderedDict([('id', id), ('flavour', flavour),
                                       ('local_affinity_or_anti_affinity_rule', local_affinity_or_anti_affinity_rule),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
                                       ('max_bit_rate_requirements', max_bit_rate_requirements),
                                       ('min_bit_rate_requirements', min_bit_rate_requirements),
                                       ('virtual_link_protocol_data', virtual_link_protocol_data), ])


class yc_vdu_level_etsi_nfv_vnfd__vnfd_df_instantiation_level_vdu_level(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/instantiation-level/vdu-level. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Sets the number of instances for the VDU in this
instantiation level.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vdu_id', '__number_of_instances',)

    _yang_name = 'vdu-level'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                     defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'instantiation-level', 'vdu-level']

    def _get_vdu_id(self):
        """
    Getter method for vdu_id, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level/vdu_id (leafref)

    YANG Description: Uniquely identifies a VDU.
    """
        return self.__vdu_id

    def _set_vdu_id(self, v, load=False):
        """
    Setter method for vdu_id, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level/vdu_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id() directly.

    YANG Description: Uniquely identifies a VDU.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_id(self):
        self.__vdu_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                     defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level/number_of_instances (uint16)

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for this level.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level/number_of_instances (uint16)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for this level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16),
                             default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},
                                                         int_size=16)(1), is_leaf=True, yang_name="number-of-instances",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint16""",
                'defined-type': "uint16",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16), default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']},int_size=16)(1), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(
            base=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16),
            default=RestrictedClassType(base_type=int, restriction_dict={'range': ['0..65535']}, int_size=16)(1),
            is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint16', is_config=True)

    vdu_id = __builtin__.property(_get_vdu_id, _set_vdu_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict([('vdu_id', vdu_id), ('number_of_instances', number_of_instances), ])


class yc_scaling_info_etsi_nfv_vnfd__vnfd_df_instantiation_level_scaling_info(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/instantiation-level/scaling-info. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
  """
    __slots__ = ('_path_helper', '_extmethods', '__scaling_aspect_id', '__scale_level',)

    _yang_name = 'scaling-info'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__scaling_aspect_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, is_keyval=True,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__scale_level = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'instantiation-level', 'scaling-info']

    def _get_scaling_aspect_id(self):
        """
    Getter method for scaling_aspect_id, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info/scaling_aspect_id (leafref)

    YANG Description: Identifier of the scaling aspect.
    """
        return self.__scaling_aspect_id

    def _set_scaling_aspect_id(self, v, load=False):
        """
    Setter method for scaling_aspect_id, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info/scaling_aspect_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_aspect_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_aspect_id() directly.

    YANG Description: Identifier of the scaling aspect.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_aspect_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__scaling_aspect_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_aspect_id(self):
        self.__scaling_aspect_id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="scaling-aspect-id",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, is_keyval=True,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_scale_level(self):
        """
    Getter method for scale_level, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info/scale_level (uint32)

    YANG Description: The scale level, greater than or equal to 0.
    """
        return self.__scale_level

    def _set_scale_level(self, v, load=False):
        """
    Setter method for scale_level, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info/scale_level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_level() directly.

    YANG Description: The scale level, greater than or equal to 0.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="scale-level",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_level must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__scale_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_level(self):
        self.__scale_level = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="scale-level", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    scaling_aspect_id = __builtin__.property(_get_scaling_aspect_id, _set_scaling_aspect_id)
    scale_level = __builtin__.property(_get_scale_level, _set_scale_level)

    _pyangbind_elements = OrderedDict([('scaling_aspect_id', scaling_aspect_id), ('scale_level', scale_level), ])


class yc_instantiation_level_etsi_nfv_vnfd__vnfd_df_instantiation_level(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/instantiation-level. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu_level', '__scaling_info',)

    _yang_name = 'instantiation-level'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__vdu_level = YANGDynClass(
            base=YANGListType("vdu_id", yc_vdu_level_etsi_nfv_vnfd__vnfd_df_instantiation_level_vdu_level,
                              yang_name="vdu-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list',
            yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__scaling_info = YANGDynClass(base=YANGListType("scaling_aspect_id",
                                                             yc_scaling_info_etsi_nfv_vnfd__vnfd_df_instantiation_level_scaling_info,
                                                             yang_name="scaling-info", parent=self, is_container='list',
                                                             user_ordered=False, path_helper=self._path_helper,
                                                             yang_keys='scaling-aspect-id', extensions=None),
                                           is_container='list', yang_name="scaling-info", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, extensions=None,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                           yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'instantiation-level']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/instantiation_level/id (string)

    YANG Description: Uniquely identifies a level with the DF.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/instantiation_level/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a level with the DF.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/df/instantiation_level/description (string)

    YANG Description: Human readable description of the instantiation level
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/df/instantiation_level/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the instantiation level
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_vdu_level(self):
        """
    Getter method for vdu_level, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level (list)

    YANG Description: Sets the number of instances for the VDU in this
instantiation level.
    """
        return self.__vdu_level

    def _set_vdu_level(self, v, load=False):
        """
    Setter method for vdu_level, mapped from YANG variable /vnfd/df/instantiation_level/vdu_level (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_level() directly.

    YANG Description: Sets the number of instances for the VDU in this
instantiation level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("vdu_id",
                                                  yc_vdu_level_etsi_nfv_vnfd__vnfd_df_instantiation_level_vdu_level,
                                                  yang_name="vdu-level", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id',
                                                  extensions=None), is_container='list', yang_name="vdu-level",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_level must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("vdu_id",yc_vdu_level_etsi_nfv_vnfd__vnfd_df_instantiation_level_vdu_level, yang_name="vdu-level", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list', yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_level(self):
        self.__vdu_level = YANGDynClass(
            base=YANGListType("vdu_id", yc_vdu_level_etsi_nfv_vnfd__vnfd_df_instantiation_level_vdu_level,
                              yang_name="vdu-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id', extensions=None), is_container='list',
            yang_name="vdu-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_scaling_info(self):
        """
    Getter method for scaling_info, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info (list)

    YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
    """
        return self.__scaling_info

    def _set_scaling_info(self, v, load=False):
        """
    Setter method for scaling_info, mapped from YANG variable /vnfd/df/instantiation_level/scaling_info (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_info() directly.

    YANG Description: The InstantiationLevel information element describes a
given level of resources to be instantiated within a
DF in term of the number of VNFC instances to be
created from each VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("scaling_aspect_id",
                                                  yc_scaling_info_etsi_nfv_vnfd__vnfd_df_instantiation_level_scaling_info,
                                                  yang_name="scaling-info", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='scaling-aspect-id', extensions=None), is_container='list',
                             yang_name="scaling-info", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_info must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("scaling_aspect_id",yc_scaling_info_etsi_nfv_vnfd__vnfd_df_instantiation_level_scaling_info, yang_name="scaling-info", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='scaling-aspect-id', extensions=None), is_container='list', yang_name="scaling-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__scaling_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_info(self):
        self.__scaling_info = YANGDynClass(base=YANGListType("scaling_aspect_id",
                                                             yc_scaling_info_etsi_nfv_vnfd__vnfd_df_instantiation_level_scaling_info,
                                                             yang_name="scaling-info", parent=self, is_container='list',
                                                             user_ordered=False, path_helper=self._path_helper,
                                                             yang_keys='scaling-aspect-id', extensions=None),
                                           is_container='list', yang_name="scaling-info", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, extensions=None,
                                           namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                           yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu_level = __builtin__.property(_get_vdu_level, _set_vdu_level)
    scaling_info = __builtin__.property(_get_scaling_info, _set_scaling_info)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('vdu_level', vdu_level), ('scaling_info', scaling_info), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/instantiate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'instantiate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_instantiate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/instantiate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the InstantiateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'instantiate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'instantiate-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the InstantiateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/scale-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_scale_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/scale-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the ScaleVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__scaling_by_more_than_one_step_supported',)

    _yang_name = 'scale-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)
        self.__scaling_by_more_than_one_step_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"),
                                                                      is_leaf=True,
                                                                      yang_name="scaling-by-more-than-one-step-supported",
                                                                      parent=self, path_helper=self._path_helper,
                                                                      extmethods=self._extmethods, register_paths=True,
                                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                      defining_module='etsi-nfv-vnfd',
                                                                      yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNFspecific parameters
to be passed when invoking the ScaleVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    def _get_scaling_by_more_than_one_step_supported(self):
        """
    Getter method for scaling_by_more_than_one_step_supported, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/scaling_by_more_than_one_step_supported (boolean)

    YANG Description: Signals whether passing a value larger than one in
the numScalingSteps parameter of the ScaleVnf
operation is supported by this VNF.
Default is FALSE, i.e. 'not supported'.
    """
        return self.__scaling_by_more_than_one_step_supported

    def _set_scaling_by_more_than_one_step_supported(self, v, load=False):
        """
    Setter method for scaling_by_more_than_one_step_supported, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config/scaling_by_more_than_one_step_supported (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_by_more_than_one_step_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_by_more_than_one_step_supported() directly.

    YANG Description: Signals whether passing a value larger than one in
the numScalingSteps parameter of the ScaleVnf
operation is supported by this VNF.
Default is FALSE, i.e. 'not supported'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True,
                             yang_name="scaling-by-more-than-one-step-supported", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_by_more_than_one_step_supported must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="scaling-by-more-than-one-step-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__scaling_by_more_than_one_step_supported = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_by_more_than_one_step_supported(self):
        self.__scaling_by_more_than_one_step_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"),
                                                                      is_leaf=True,
                                                                      yang_name="scaling-by-more-than-one-step-supported",
                                                                      parent=self, path_helper=self._path_helper,
                                                                      extmethods=self._extmethods, register_paths=True,
                                                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                      defining_module='etsi-nfv-vnfd',
                                                                      yang_type='boolean', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    scaling_by_more_than_one_step_supported = __builtin__.property(_get_scaling_by_more_than_one_step_supported,
                                                                   _set_scaling_by_more_than_one_step_supported)

    _pyangbind_elements = OrderedDict([('parameter', parameter), (
        'scaling_by_more_than_one_step_supported', scaling_by_more_than_one_step_supported), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/scale-vnf-to-level-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-to-level-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_scale_vnf_to_level_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/scale-vnf-to-level-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__arbitrary_target_levels_supported',)

    _yang_name = 'scale-vnf-to-level-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)
        self.__arbitrary_target_levels_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                                yang_name="arbitrary-target-levels-supported",
                                                                parent=self, path_helper=self._path_helper,
                                                                extmethods=self._extmethods, register_paths=True,
                                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                                is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'scale-vnf-to-level-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the ScaleVnfToLevel
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    def _get_arbitrary_target_levels_supported(self):
        """
    Getter method for arbitrary_target_levels_supported, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/arbitrary_target_levels_supported (boolean)

    YANG Description: Signals whether scaling according to the parameter
'scaleInfo' is supported by this VNF.
    """
        return self.__arbitrary_target_levels_supported

    def _set_arbitrary_target_levels_supported(self, v, load=False):
        """
    Setter method for arbitrary_target_levels_supported, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config/arbitrary_target_levels_supported (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_arbitrary_target_levels_supported is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_arbitrary_target_levels_supported() directly.

    YANG Description: Signals whether scaling according to the parameter
'scaleInfo' is supported by this VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True,
                             yang_name="arbitrary-target-levels-supported", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """arbitrary_target_levels_supported must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="arbitrary-target-levels-supported", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__arbitrary_target_levels_supported = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_arbitrary_target_levels_supported(self):
        self.__arbitrary_target_levels_supported = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                                                yang_name="arbitrary-target-levels-supported",
                                                                parent=self, path_helper=self._path_helper,
                                                                extmethods=self._extmethods, register_paths=True,
                                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                                defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                                is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    arbitrary_target_levels_supported = __builtin__.property(_get_arbitrary_target_levels_supported,
                                                             _set_arbitrary_target_levels_supported)

    _pyangbind_elements = OrderedDict(
        [('parameter', parameter), ('arbitrary_target_levels_supported', arbitrary_target_levels_supported), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/heal-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'heal-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_heal_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/heal-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter', '__cause',)

    _yang_name = 'heal-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)
        self.__cause = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                    yang_name="cause", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'heal-vnf-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the HealVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    def _get_cause(self):
        """
    Getter method for cause, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/cause (string)

    YANG Description: Supported 'cause' parameter values.
    """
        return self.__cause

    def _set_cause(self, v, load=False):
        """
    Setter method for cause, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config/cause (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cause is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cause() directly.

    YANG Description: Supported 'cause' parameter values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cause must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cause", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__cause = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cause(self):
        self.__cause = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                    yang_name="cause", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)
    cause = __builtin__.property(_get_cause, _set_cause)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ('cause', cause), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/terminate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'terminate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_terminate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/terminate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__min_graceful_termination', '__max_recommended_graceful_termination',
                 '__parameter',)

    _yang_name = 'terminate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)
        self.__max_recommended_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'terminate-vnf-op-config']

    def _get_min_graceful_termination(self):
        """
    Getter method for min_graceful_termination, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/min_graceful_termination (yang:timeticks)

    YANG Description: Minimum timeout value for graceful termination of
a VNF instance.
    """
        return self.__min_graceful_termination

    def _set_min_graceful_termination(self, v, load=False):
        """
    Setter method for min_graceful_termination, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/min_graceful_termination (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_termination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_termination() directly.

    YANG Description: Minimum timeout value for graceful termination of
a VNF instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True,
                             yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_graceful_termination must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__min_graceful_termination = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_graceful_termination(self):
        self.__min_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)

    def _get_max_recommended_graceful_termination(self):
        """
    Getter method for max_recommended_graceful_termination, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/max_recommended_graceful_termination (yang:timeticks)

    YANG Description: Maximum recommended timeout value that can be needed
to gracefully terminate a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator
facilitating the selection of optimal timeout value.
This value is not used as constraint.
    """
        return self.__max_recommended_graceful_termination

    def _set_max_recommended_graceful_termination(self, v, load=False):
        """
    Setter method for max_recommended_graceful_termination, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/max_recommended_graceful_termination (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_termination is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_termination() directly.

    YANG Description: Maximum recommended timeout value that can be needed
to gracefully terminate a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator
facilitating the selection of optimal timeout value.
This value is not used as constraint.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True,
                             yang_name="max-recommended-graceful-termination", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_recommended_graceful_termination must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__max_recommended_graceful_termination = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_recommended_graceful_termination(self):
        self.__max_recommended_graceful_termination = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-termination", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the TerminateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    min_graceful_termination = __builtin__.property(_get_min_graceful_termination, _set_min_graceful_termination)
    max_recommended_graceful_termination = __builtin__.property(_get_max_recommended_graceful_termination,
                                                                _set_max_recommended_graceful_termination)
    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('min_graceful_termination', min_graceful_termination),
                                       ('max_recommended_graceful_termination', max_recommended_graceful_termination),
                                       ('parameter', parameter), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_script_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__script_type',)

    _yang_name = 'script'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'rift': {}}, ), is_leaf=True,
                                          yang_name="script-type", parent=self, choice=('config-method', 'script'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                          defining_module='day1-2', yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'script']

    def _get_script_type(self):
        """
    Getter method for script_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/script/script_type (enumeration)

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        return self.__script_type

    def _set_script_type(self, v, load=False):
        """
    Setter method for script_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/script/script_type (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_type() directly.

    YANG Description: Script type - currently supported - Scripts confirming to Rift CA plugin
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'rift': {}}, ), is_leaf=True,
                             yang_name="script-type", parent=self, choice=('config-method', 'script'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_type must be of a type compatible with enumeration""",
                'defined-type': "day1-2:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'rift': {}},), is_leaf=True, yang_name="script-type", parent=self, choice=('config-method', 'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration', is_config=True)""",
            })

        self.__script_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_type(self):
        self.__script_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                   restriction_arg={'rift': {}}, ), is_leaf=True,
                                          yang_name="script-type", parent=self, choice=('config-method', 'script'),
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                          defining_module='day1-2', yang_type='enumeration', is_config=True)

    script_type = __builtin__.property(_get_script_type, _set_script_type)

    __choices__ = {'config-method': {'script': ['script_type']}}
    _pyangbind_elements = OrderedDict([('script_type', script_type), ])


class yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_juju(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__charm', '__proxy', '__cloud',)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='boolean', is_config=True)
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self, v, load=False):
        """
    Setter method for charm, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__charm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self, v, load=False):
        """
    Setter method for proxy, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__proxy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='boolean', is_config=True)

    def _get_cloud(self):
        """
    Getter method for cloud, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        return self.__cloud

    def _set_cloud(self, v, load=False):
        """
    Setter method for cloud, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'lxd': {}, 'k8s': {}}, ),
                             default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                             choice=('config-method', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud must be of a type compatible with enumeration""",
                'defined-type': "day1-2:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lxd': {}, 'k8s': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration', is_config=True)""",
            })

        self.__cloud = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud(self):
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('config-method', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='enumeration', is_config=True)

    charm = __builtin__.property(_get_charm, _set_charm)
    proxy = __builtin__.property(_get_proxy, _set_proxy)
    cloud = __builtin__.property(_get_cloud, _set_cloud)

    __choices__ = {'config-method': {'juju': ['charm', 'proxy', 'cloud']}}
    _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list_juju(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/execution-environment-list/juju. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__charm', '__proxy', '__cloud',)

    _yang_name = 'juju'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('execution-environment-model', 'juju'),
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='boolean', is_config=True)
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'execution-environment-list', 'juju']

    def _get_charm(self):
        """
    Getter method for charm, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/charm (string)

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        return self.__charm

    def _set_charm(self, v, load=False):
        """
    Setter method for charm, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/charm (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_charm is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_charm() directly.

    YANG Description: Juju charm to use with the VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """charm must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__charm = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_charm(self):
        self.__charm = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="charm", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

    def _get_proxy(self):
        """
    Getter method for proxy, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/proxy (boolean)

    YANG Description: Is this a proxy charm?
    """
        return self.__proxy

    def _set_proxy(self, v, load=False):
        """
    Setter method for proxy, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/proxy (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_proxy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_proxy() directly.

    YANG Description: Is this a proxy charm?
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """proxy must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__proxy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_proxy(self):
        self.__proxy = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="proxy",
                                    parent=self, choice=('execution-environment-model', 'juju'),
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='boolean', is_config=True)

    def _get_cloud(self):
        """
    Getter method for cloud, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/cloud (enumeration)

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        return self.__cloud

    def _set_cloud(self, v, load=False):
        """
    Setter method for cloud, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju/cloud (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cloud is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cloud() directly.

    YANG Description: Type of cloud where the charm will be deployed. It only
applies to proxy charms (not native)
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'lxd': {}, 'k8s': {}}, ),
                             default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cloud must be of a type compatible with enumeration""",
                'defined-type': "day1-2:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'lxd': {}, 'k8s': {}},), default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration', is_config=True)""",
            })

        self.__cloud = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cloud(self):
        self.__cloud = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'lxd': {}, 'k8s': {}}, ),
                                    default=six.text_type("lxd"), is_leaf=True, yang_name="cloud", parent=self,
                                    choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='enumeration', is_config=True)

    charm = __builtin__.property(_get_charm, _set_charm)
    proxy = __builtin__.property(_get_proxy, _set_proxy)
    cloud = __builtin__.property(_get_cloud, _set_cloud)

    __choices__ = {'execution-environment-model': {'juju': ['charm', 'proxy', 'cloud']}}
    _pyangbind_elements = OrderedDict([('charm', charm), ('proxy', proxy), ('cloud', cloud), ])


class yc_execution_environment_list_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/execution-environment-list. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__juju', '__helm_chart', '__helm_version', '__metric_service',
                 '__external_connection_point_ref',)

    _yang_name = 'execution-environment-list'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                 namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                 yang_type='string', is_config=True)
        self.__juju = YANGDynClass(
            base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list_juju,
            is_container='container', yang_name="juju", parent=self, choice=('execution-environment-model', 'juju'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('execution-environment-model', 'helm-chart'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                         defining_module='day1-2', yang_type='string', is_config=True)
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration',
            is_config=True)
        self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                                             choice=('config-method', 'execution-environment-list'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                             defining_module='day1-2', yang_type='string', is_config=True)
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            choice=('config-method', 'execution-environment-list'),
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:day1-2',
                                                            defining_module='day1-2', yang_type='string',
                                                            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'execution-environment-list']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/id (string)

    YANG Description: Execution environment identifier.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Execution environment identifier.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                                 extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                 namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                 yang_type='string', is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju (container)
    """
        return self.__juju

    def _set_juju(self, v, load=False):
        """
    Setter method for juju, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list_juju,
                             is_container='container', yang_name="juju", parent=self,
                             choice=('execution-environment-model', 'juju'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list_juju, is_container='container', yang_name="juju", parent=self, choice=('execution-environment-model', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container', is_config=True)""",
            })

        self.__juju = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(
            base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list_juju,
            is_container='container', yang_name="juju", parent=self, choice=('execution-environment-model', 'juju'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

    def _get_helm_chart(self):
        """
    Getter method for helm_chart, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/helm_chart (string)

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
        return self.__helm_chart

    def _set_helm_chart(self, v, load=False):
        """
    Setter method for helm_chart, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the execution environment, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder name under helm-charts folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under helm-charts folder in the package>
- <URL_where_to_fetch_chart>

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                             choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_chart must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__helm_chart = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_chart(self):
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('execution-environment-model', 'helm-chart'),
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                         defining_module='day1-2', yang_type='string', is_config=True)

    def _get_helm_version(self):
        """
    Getter method for helm_version, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/helm_version (enumeration)

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        return self.__helm_version

    def _set_helm_version(self, v, load=False):
        """
    Setter method for helm_version, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/helm_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_version() directly.

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'v2': {}, 'v3': {}}, ),
                             default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self,
                             choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_version must be of a type compatible with enumeration""",
                'defined-type': "day1-2:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'v2': {}, 'v3': {}},), default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration', is_config=True)""",
            })

        self.__helm_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_version(self):
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('execution-environment-model', 'helm-chart'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration',
            is_config=True)

    def _get_metric_service(self):
        """
    Getter method for metric_service, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/metric_service (string)

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
        return self.__metric_service

    def _set_metric_service(self, v, load=False):
        """
    Setter method for metric_service, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/metric_service (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metric_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metric_service() directly.

    YANG Description: Service name in the execution environment. For helm charts, it will be
the name of the kubernetes service used by the exporter to expose metrics
to the OSM collector.

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metric_service must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__metric_service = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metric_service(self):
        self.__metric_service = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="metric-service", parent=self,
                                             choice=('config-method', 'execution-environment-list'),
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                             defining_module='day1-2', yang_type='string', is_config=True)

    def _get_external_connection_point_ref(self):
        """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/external_connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
        return self.__external_connection_point_ref

    def _set_external_connection_point_ref(self, v, load=False):
        """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list/external_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point
This field should match /vnfd:vnfd-catalog/vnfd:vnfd/vnfd:id/vnfd:connection-point/vnfd:name

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref",
                             parent=self, choice=('config-method', 'execution-environment-list'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """external_connection_point_ref must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__external_connection_point_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_external_connection_point_ref(self):
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            choice=('config-method', 'execution-environment-list'),
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:day1-2',
                                                            defining_module='day1-2', yang_type='string',
                                                            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    juju = __builtin__.property(_get_juju, _set_juju)
    helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
    helm_version = __builtin__.property(_get_helm_version, _set_helm_version)
    metric_service = __builtin__.property(_get_metric_service, _set_metric_service)
    external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref,
                                                         _set_external_connection_point_ref)

    __choices__ = {
        'config-method': {'execution-environment-list': ['id', 'metric_service', 'external_connection_point_ref']},
        'execution-environment-model': {'juju': ['juju'], 'helm-chart': ['helm_chart', 'helm_version']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('juju', juju), ('helm_chart', helm_chart), ('helm_version', helm_version),
         ('metric_service', metric_service), ('external_connection_point_ref', external_connection_point_ref), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the config primitive.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__data_type', '__mandatory', '__default_value', '__parameter_pool',
        '__read_only', '__hidden',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)
        self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='boolean', is_config=True)
        self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                            defining_module='day1-2', yang_type='string', is_config=True)
        self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                             defining_module='day1-2', yang_type='string', is_config=True)
        self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='boolean', is_config=True)
        self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                     defining_module='day1-2', yang_type='boolean', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'config-primitive',
                    'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the name.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)

    def _get_mandatory(self):
        """
    Getter method for mandatory, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/mandatory (boolean)

    YANG Description: Is this field mandatory
    """
        return self.__mandatory

    def _set_mandatory(self, v, load=False):
        """
    Setter method for mandatory, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/mandatory (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mandatory is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mandatory() directly.

    YANG Description: Is this field mandatory
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mandatory must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__mandatory = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mandatory(self):
        self.__mandatory = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mandatory",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='boolean', is_config=True)

    def _get_default_value(self):
        """
    Getter method for default_value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/default_value (string)

    YANG Description: The default value for this field
    """
        return self.__default_value

    def _set_default_value(self, v, load=False):
        """
    Setter method for default_value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/default_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_value() directly.

    YANG Description: The default value for this field
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__default_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_value(self):
        self.__default_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-value", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                            defining_module='day1-2', yang_type='string', is_config=True)

    def _get_parameter_pool(self):
        """
    Getter method for parameter_pool, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/parameter_pool (string)

    YANG Description: NSD parameter pool name to use for this parameter
    """
        return self.__parameter_pool

    def _set_parameter_pool(self, v, load=False):
        """
    Setter method for parameter_pool, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/parameter_pool (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter_pool is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter_pool() directly.

    YANG Description: NSD parameter pool name to use for this parameter
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter_pool must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__parameter_pool = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter_pool(self):
        self.__parameter_pool = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="parameter-pool", parent=self,
                                             path_helper=self._path_helper, extmethods=self._extmethods,
                                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                             defining_module='day1-2', yang_type='string', is_config=True)

    def _get_read_only(self):
        """
    Getter method for read_only, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/read_only (boolean)

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        return self.__read_only

    def _set_read_only(self, v, load=False):
        """
    Setter method for read_only, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/read_only (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_read_only is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_read_only() directly.

    YANG Description: The value should be dimmed by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """read_only must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__read_only = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_read_only(self):
        self.__read_only = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="read-only",
                                        parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                        register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='boolean', is_config=True)

    def _get_hidden(self):
        """
    Getter method for hidden, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/hidden (boolean)

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        return self.__hidden

    def _set_hidden(self, v, load=False):
        """
    Setter method for hidden, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter/hidden (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_hidden is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_hidden() directly.

    YANG Description: The value should be hidden by the UI.
Only applies to parameters with default values.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """hidden must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__hidden = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_hidden(self):
        self.__hidden = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="hidden",
                                     parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                     register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                     defining_module='day1-2', yang_type='boolean', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    mandatory = __builtin__.property(_get_mandatory, _set_mandatory)
    default_value = __builtin__.property(_get_default_value, _set_default_value)
    parameter_pool = __builtin__.property(_get_parameter_pool, _set_parameter_pool)
    read_only = __builtin__.property(_get_read_only, _set_read_only)
    hidden = __builtin__.property(_get_hidden, _set_hidden)

    _pyangbind_elements = OrderedDict(
        [('name', name), ('data_type', data_type), ('mandatory', mandatory), ('default_value', default_value),
         ('parameter_pool', parameter_pool), ('read_only', read_only), ('hidden', hidden), ])


class yc_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__execution_environment_ref', '__execution_environment_primitive',
        '__parameter', '__user_defined_script',)

    _yang_name = 'config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)
        self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True,
                                                              yang_name="execution-environment-primitive", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              namespace='urn:etsi:osm:yang:augments:day1-2',
                                                              defining_module='day1-2', yang_type='string',
                                                              is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'config-primitive']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/name (string)

    YANG Description: Name of the config primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the config primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)

    def _get_execution_environment_primitive(self):
        """
    Getter method for execution_environment_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/execution_environment_primitive (string)

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
        return self.__execution_environment_primitive

    def _set_execution_environment_primitive(self, v, load=False):
        """
    Setter method for execution_environment_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/execution_environment_primitive (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_primitive() directly.

    YANG Description: Name of the primitive in the execution enviroment. If not explicit,
the leaf 'name' will be used as the name of the primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_primitive must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__execution_environment_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_primitive(self):
        self.__execution_environment_primitive = YANGDynClass(base=six.text_type, is_leaf=True,
                                                              yang_name="execution-environment-primitive", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              namespace='urn:etsi:osm:yang:augments:day1-2',
                                                              defining_module='day1-2', yang_type='string',
                                                              is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter (list)

    YANG Description: List of parameters to the config primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the config primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/user_defined_script (string)

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script. If user defined script is defined,
the script will be executed using bash
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    execution_environment_primitive = __builtin__.property(_get_execution_environment_primitive,
                                                           _set_execution_environment_primitive)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    _pyangbind_elements = OrderedDict([('name', name), ('execution_environment_ref', execution_environment_ref),
                                       ('execution_environment_primitive', execution_environment_primitive),
                                       ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/initial-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__data_type', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'initial-config-primitive', 'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, choice=('primitive-type', 'primitive-definition'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    value = __builtin__.property(_get_value, _set_value)

    __choices__ = {'primitive-type': {'primitive-definition': ['name', 'data_type', 'value']}}
    _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_initial_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/initial-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Initial set of configuration primitives.
  """
    __slots__ = ('_path_helper', '_extmethods', '__seq', '__name', '__execution_environment_ref', '__parameter',
                 '__user_defined_script',)

    _yang_name = 'initial-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        choice=('primitive-type', 'primitive-definition'),
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None, choice=False),
                                        is_container='list', yang_name="parameter", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, choice=('primitive-type', 'primitive-definition'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'initial-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self, v, load=False):
        """
    Setter method for seq, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="seq", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)""",
            })

        self.__seq = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        choice=('primitive-type', 'primitive-definition'),
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None, choice=False), is_container='list',
                             yang_name="parameter", parent=self, choice=('primitive-type', 'primitive-definition'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None, choice=False), is_container='list', yang_name="parameter", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None, choice=False),
                                        is_container='list', yang_name="parameter", parent=self,
                                        choice=('primitive-type', 'primitive-definition'),
                                        path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                        extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                                        defining_module='day1-2', yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, choice=('primitive-type', 'primitive-definition'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, choice=('primitive-type', 'primitive-definition'),
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

    seq = __builtin__.property(_get_seq, _set_seq)
    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    __choices__ = {'primitive-type': {
        'primitive-definition': ['name', 'execution_environment_ref', 'parameter', 'user_defined_script']}}
    _pyangbind_elements = OrderedDict(
        [('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref),
         ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/terminate-config-primitive/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of parameters to the configuration primitive.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__data_type', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'terminate-config-primitive', 'parameter']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/name (string)

    YANG Description: Name of the parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

    def _get_data_type(self):
        """
    Getter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/data_type (common:parameter-data-type)

    YANG Description: Data type associated with the value.
    """
        return self.__data_type

    def _set_data_type(self, v, load=False):
        """
    Setter method for data_type, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/data_type (common:parameter-data-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_data_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_data_type() directly.

    YANG Description: Data type associated with the value.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                          'BOOLEAN': {}}, ), is_leaf=True,
                             yang_name="data-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='common:parameter-data-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """data_type must be of a type compatible with common:parameter-data-type""",
                'defined-type': "common:parameter-data-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'STRING': {}, 'INTEGER': {}, 'BOOLEAN': {}},), is_leaf=True, yang_name="data-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='common:parameter-data-type', is_config=True)""",
            })

        self.__data_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_data_type(self):
        self.__data_type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                                 restriction_arg={'STRING': {}, 'INTEGER': {},
                                                                                  'BOOLEAN': {}}, ), is_leaf=True,
                                        yang_name="data-type", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='common:parameter-data-type', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/value (string)

    YANG Description: Value associated with the name.
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.

    YANG Description: Value associated with the name.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                    yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    data_type = __builtin__.property(_get_data_type, _set_data_type)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('name', name), ('data_type', data_type), ('value', value), ])


class yc_terminate_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/terminate-config-primitive. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Terminate set of configuration primitives.
  """
    __slots__ = ('_path_helper', '_extmethods', '__seq', '__name', '__execution_environment_ref', '__parameter',
                 '__user_defined_script',)

    _yang_name = 'terminate-config-primitive'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='list', is_config=True)
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2',
                    'terminate-config-primitive']

    def _get_seq(self):
        """
    Getter method for seq, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/seq (uint64)

    YANG Description: Sequence number for the configuration primitive.
    """
        return self.__seq

    def _set_seq(self, v, load=False):
        """
    Setter method for seq, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/seq (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_seq is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_seq() directly.

    YANG Description: Sequence number for the configuration primitive.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="seq", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """seq must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="seq", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)""",
            })

        self.__seq = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_seq(self):
        self.__seq = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="seq", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='uint64', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/name (string)

    YANG Description: Name of the configuration primitive.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                   yang_type='string', is_config=True)

    def _get_execution_environment_ref(self):
        """
    Getter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/execution_environment_ref (leafref)

    YANG Description: Leaf reference to the particular execution environment
    """
        return self.__execution_environment_ref

    def _set_execution_environment_ref(self, v, load=False):
        """
    Setter method for execution_environment_ref, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/execution_environment_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_ref() directly.

    YANG Description: Leaf reference to the particular execution environment
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="execution-environment-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='leafref', is_config=True)""",
            })

        self.__execution_environment_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_ref(self):
        self.__execution_environment_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                        yang_name="execution-environment-ref", parent=self,
                                                        path_helper=self._path_helper, extmethods=self._extmethods,
                                                        register_paths=True,
                                                        namespace='urn:etsi:osm:yang:augments:day1-2',
                                                        defining_module='day1-2', yang_type='leafref', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter (list)

    YANG Description: List of parameters to the configuration primitive.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: List of parameters to the configuration primitive.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("name",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='name', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                        yang_type='list', is_config=True)

    def _get_user_defined_script(self):
        """
    Getter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/user_defined_script (string)

    YANG Description: A user defined script.
    """
        return self.__user_defined_script

    def _set_user_defined_script(self, v, load=False):
        """
    Setter method for user_defined_script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive/user_defined_script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_user_defined_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_user_defined_script() directly.

    YANG Description: A user defined script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """user_defined_script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__user_defined_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_user_defined_script(self):
        self.__user_defined_script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="user-defined-script",
                                                  parent=self, path_helper=self._path_helper,
                                                  extmethods=self._extmethods, register_paths=True,
                                                  namespace='urn:etsi:osm:yang:augments:day1-2',
                                                  defining_module='day1-2', yang_type='string', is_config=True)

    seq = __builtin__.property(_get_seq, _set_seq)
    name = __builtin__.property(_get_name, _set_name)
    execution_environment_ref = __builtin__.property(_get_execution_environment_ref, _set_execution_environment_ref)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    user_defined_script = __builtin__.property(_get_user_defined_script, _set_user_defined_script)

    _pyangbind_elements = OrderedDict(
        [('seq', seq), ('name', name), ('execution_environment_ref', execution_environment_ref),
         ('parameter', parameter), ('user_defined_script', user_defined_script), ])


class yc_metrics_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_metrics(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/metrics. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of VNFC related metrics
  """
    __slots__ = ('_path_helper', '_extmethods', '__name',)

    _yang_name = 'metrics'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'metrics']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/metrics/name (string)

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/metrics/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the metric, as defined in the Juju charm.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)

    _pyangbind_elements = OrderedDict([('name', name), ])


class yc_entities_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation_entities(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/relation/entities. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__endpoint',)

    _yang_name = 'entities'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                 defining_module='day1-2', yang_type='string', is_config=True)
        self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'relation',
                    'entities']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities/id (string)

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A string, reference to the element id in the descriptor.
It could be a vnfd-id or a vdu-id in a VNFD,
or a nsd-id or member-vnf-index in a NSD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                 defining_module='day1-2', yang_type='string', is_config=True)

    def _get_endpoint(self):
        """
    Getter method for endpoint, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities/endpoint (string)

    YANG Description: Endpoint name defining the relation.
    """
        return self.__endpoint

    def _set_endpoint(self, v, load=False):
        """
    Setter method for endpoint, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities/endpoint (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_endpoint is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_endpoint() directly.

    YANG Description: Endpoint name defining the relation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """endpoint must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__endpoint = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_endpoint(self):
        self.__endpoint = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="endpoint", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    endpoint = __builtin__.property(_get_endpoint, _set_endpoint)

    _pyangbind_elements = OrderedDict([('id', id), ('endpoint', endpoint), ])


class yc_relation_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/relation. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of relations between elements in this descriptor.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__entities',)

    _yang_name = 'relation'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)
        self.__entities = YANGDynClass(base=YANGListType("id",
                                                         yc_entities_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation_entities,
                                                         yang_name="entities", parent=self, is_container='list',
                                                         user_ordered=False, path_helper=self._path_helper,
                                                         yang_keys='id', extensions=None), is_container='list',
                                       yang_name="entities", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True, extensions=None,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'relation']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/name (string)

    YANG Description: Name of the relation.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the relation.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                   defining_module='day1-2', yang_type='string', is_config=True)

    def _get_entities(self):
        """
    Getter method for entities, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities (list)

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
        return self.__entities

    def _set_entities(self, v, load=False):
        """
    Setter method for entities, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation/entities (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_entities is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_entities() directly.

    YANG Description: List of two elements to be related.
Elements to be related are identified by a pair (id, endpoint).
The relation will relate (id1, endpoint1) to (id2, endpoint2).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_entities_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation_entities,
                                                  yang_name="entities", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="entities",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """entities must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_entities_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation_entities, yang_name="entities", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="entities", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__entities = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_entities(self):
        self.__entities = YANGDynClass(base=YANGListType("id",
                                                         yc_entities_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation_entities,
                                                         yang_name="entities", parent=self, is_container='list',
                                                         user_ordered=False, path_helper=self._path_helper,
                                                         yang_keys='id', extensions=None), is_container='list',
                                       yang_name="entities", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True, extensions=None,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    entities = __builtin__.property(_get_entities, _set_entities)

    _pyangbind_elements = OrderedDict([('name', name), ('entities', entities), ])


class yc_ssh_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access_ssh_access(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/config-access/ssh-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
  """
    __slots__ = ('_path_helper', '_extmethods', '__required', '__default_user',)

    _yang_name = 'ssh-access'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required",
                                       parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                       register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                       defining_module='day1-2', yang_type='boolean', is_config=True)
        self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                           defining_module='day1-2', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'config-access',
                    'ssh-access']

    def _get_required(self):
        """
    Getter method for required, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access/required (boolean)

    YANG Description: whether ssh access is needed or not
    """
        return self.__required

    def _set_required(self, v, load=False):
        """
    Setter method for required, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access/required (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_required is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_required() directly.

    YANG Description: whether ssh access is needed or not
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """required must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='boolean', is_config=True)""",
            })

        self.__required = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_required(self):
        self.__required = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="required",
                                       parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                       register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                       defining_module='day1-2', yang_type='boolean', is_config=True)

    def _get_default_user(self):
        """
    Getter method for default_user, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access/default_user (string)

    YANG Description: Default user for ssh
    """
        return self.__default_user

    def _set_default_user(self, v, load=False):
        """
    Setter method for default_user, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access/default_user (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_user is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_user() directly.

    YANG Description: Default user for ssh
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-user", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_user must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__default_user = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_user(self):
        self.__default_user = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-user", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                           defining_module='day1-2', yang_type='string', is_config=True)

    required = __builtin__.property(_get_required, _set_required)
    default_user = __builtin__.property(_get_default_user, _set_default_user)

    _pyangbind_elements = OrderedDict([('required', required), ('default_user', default_user), ])


class yc_config_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2/config-access. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
  """
    __slots__ = ('_path_helper', '_extmethods', '__ssh_access',)

    _yang_name = 'config-access'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__ssh_access = YANGDynClass(
            base=yc_ssh_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access_ssh_access,
            is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2', 'config-access']

    def _get_ssh_access(self):
        """
    Getter method for ssh_access, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access (container)

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
        return self.__ssh_access

    def _set_ssh_access(self, v, load=False):
        """
    Setter method for ssh_access, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access/ssh_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ssh_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ssh_access() directly.

    YANG Description: If the xNF requires ssh and this parameter is set, SSH keys
will be injected so that VCA can configure the xNF or xDU via ssh.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_ssh_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access_ssh_access,
                             is_container='container', yang_name="ssh-access", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ssh_access must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_ssh_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access_ssh_access, is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container', is_config=True)""",
            })

        self.__ssh_access = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ssh_access(self):
        self.__ssh_access = YANGDynClass(
            base=yc_ssh_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access_ssh_access,
            is_container='container', yang_name="ssh-access", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

    ssh_access = __builtin__.property(_get_ssh_access, _set_ssh_access)

    _pyangbind_elements = OrderedDict([('ssh_access', ssh_access), ])


class yc_day1_2_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config/day1-2. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__script', '__juju', '__execution_environment_list',
        '__config_primitive',
        '__initial_config_primitive', '__terminate_config_primitive', '__metrics', '__relation', '__config_access',
        '__blacklist_config_primitive',)

    _yang_name = 'day1-2'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                 defining_module='day1-2', yang_type='string', is_config=True)
        self.__script = YANGDynClass(
            base=yc_script_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_script,
            is_container='container', yang_name="script", parent=self, choice=('config-method', 'script'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)
        self.__juju = YANGDynClass(
            base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_juju,
            is_container='container', yang_name="juju", parent=self, choice=('config-method', 'juju'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)
        self.__execution_environment_list = YANGDynClass(base=YANGListType("id",
                                                                           yc_execution_environment_list_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list,
                                                                           yang_name="execution-environment-list",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='id', extensions=None,
                                                                           choice=False), is_container='list',
                                                         yang_name="execution-environment-list", parent=self,
                                                         choice=('config-method', 'execution-environment-list'),
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True, extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='list', is_config=True)
        self.__config_primitive = YANGDynClass(base=YANGListType("name",
                                                                 yc_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive,
                                                                 yang_name="config-primitive", parent=self,
                                                                 is_container='list', user_ordered=False,
                                                                 path_helper=self._path_helper, yang_keys='name',
                                                                 extensions=None), is_container='list',
                                               yang_name="config-primitive", parent=self, path_helper=self._path_helper,
                                               extmethods=self._extmethods, register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                               yang_type='list', is_config=True)
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                         yc_initial_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive,
                                                                         yang_name="initial-config-primitive",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='seq',
                                                                         extensions=None), is_container='list',
                                                       yang_name="initial-config-primitive", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:osm:yang:augments:day1-2',
                                                       defining_module='day1-2', yang_type='list', is_config=True)
        self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                           yc_terminate_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive,
                                                                           yang_name="terminate-config-primitive",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='seq', extensions=None),
                                                         is_container='list', yang_name="terminate-config-primitive",
                                                         parent=self, path_helper=self._path_helper,
                                                         extmethods=self._extmethods, register_paths=True,
                                                         extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='list', is_config=True)
        self.__metrics = YANGDynClass(base=YANGListType("name",
                                                        yc_metrics_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_metrics,
                                                        yang_name="metrics", parent=self, is_container='list',
                                                        user_ordered=False, path_helper=self._path_helper,
                                                        yang_keys='name', extensions=None), is_container='list',
                                      yang_name="metrics", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                      namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                      yang_type='list', is_config=True)
        self.__relation = YANGDynClass(base=YANGListType("name",
                                                         yc_relation_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation,
                                                         yang_name="relation", parent=self, is_container='list',
                                                         user_ordered=False, path_helper=self._path_helper,
                                                         yang_keys='name', extensions=None), is_container='list',
                                       yang_name="relation", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True, extensions=None,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='list', is_config=True)
        self.__config_access = YANGDynClass(
            base=yc_config_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access,
            is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)
        self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'upgrade': {}, 'rollback': {}}, )), is_leaf=False,
                                                         yang_name="blacklist-config-primitive", parent=self,
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True,
                                                         namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='enumeration',
                                                         is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config', 'day1-2']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/id (string)

    YANG Description: Internal identifier for the VNF/VDU/KNF/KDU configuration
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Internal identifier for the VNF/VDU/KNF/KDU configuration
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:day1-2',
                                 defining_module='day1-2', yang_type='string', is_config=True)

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/script (container)
    """
        return self.__script

    def _set_script(self, v, load=False):
        """
    Setter method for script, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/script (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_script_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_script,
                             is_container='container', yang_name="script", parent=self,
                             choice=('config-method', 'script'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_script_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_script, is_container='container', yang_name="script", parent=self, choice=('config-method', 'script'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container', is_config=True)""",
            })

        self.__script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(
            base=yc_script_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_script,
            is_container='container', yang_name="script", parent=self, choice=('config-method', 'script'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

    def _get_juju(self):
        """
    Getter method for juju, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju (container)
    """
        return self.__juju

    def _set_juju(self, v, load=False):
        """
    Setter method for juju, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/juju (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_juju,
                             is_container='container', yang_name="juju", parent=self, choice=('config-method', 'juju'),
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """juju must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_juju, is_container='container', yang_name="juju", parent=self, choice=('config-method', 'juju'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container', is_config=True)""",
            })

        self.__juju = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_juju(self):
        self.__juju = YANGDynClass(
            base=yc_juju_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_juju,
            is_container='container', yang_name="juju", parent=self, choice=('config-method', 'juju'),
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

    def _get_execution_environment_list(self):
        """
    Getter method for execution_environment_list, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list (list)
    """
        return self.__execution_environment_list

    def _set_execution_environment_list(self, v, load=False):
        """
    Setter method for execution_environment_list, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/execution_environment_list (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_execution_environment_list is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_execution_environment_list() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_execution_environment_list_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list,
                                                  yang_name="execution-environment-list", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None,
                                                  choice=False), is_container='list',
                             yang_name="execution-environment-list", parent=self,
                             choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """execution_environment_list must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_execution_environment_list_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list, yang_name="execution-environment-list", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None, choice=False), is_container='list', yang_name="execution-environment-list", parent=self, choice=('config-method', 'execution-environment-list'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__execution_environment_list = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_execution_environment_list(self):
        self.__execution_environment_list = YANGDynClass(base=YANGListType("id",
                                                                           yc_execution_environment_list_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_execution_environment_list,
                                                                           yang_name="execution-environment-list",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='id', extensions=None,
                                                                           choice=False), is_container='list',
                                                         yang_name="execution-environment-list", parent=self,
                                                         choice=('config-method', 'execution-environment-list'),
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True, extensions=None,
                                                         namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='list', is_config=True)

    def _get_config_primitive(self):
        """
    Getter method for config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive (list)

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        return self.__config_primitive

    def _set_config_primitive(self, v, load=False):
        """
    Setter method for config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_primitive() directly.

    YANG Description: List of config primitives supported by the
configuration agent for this VNF or VDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive,
                                                  yang_name="config-primitive", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="config-primitive",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive, yang_name="config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_config_primitive(self):
        self.__config_primitive = YANGDynClass(base=YANGListType("name",
                                                                 yc_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_primitive,
                                                                 yang_name="config-primitive", parent=self,
                                                                 is_container='list', user_ordered=False,
                                                                 path_helper=self._path_helper, yang_keys='name',
                                                                 extensions=None), is_container='list',
                                               yang_name="config-primitive", parent=self, path_helper=self._path_helper,
                                               extmethods=self._extmethods, register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                               yang_type='list', is_config=True)

    def _get_initial_config_primitive(self):
        """
    Getter method for initial_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive (list)

    YANG Description: Initial set of configuration primitives.
    """
        return self.__initial_config_primitive

    def _set_initial_config_primitive(self, v, load=False):
        """
    Setter method for initial_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/initial_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_initial_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_initial_config_primitive() directly.

    YANG Description: Initial set of configuration primitives.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("seq",
                                                  yc_initial_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive,
                                                  yang_name="initial-config-primitive", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='seq', extensions=None),
                             is_container='list', yang_name="initial-config-primitive", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """initial_config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_initial_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive, yang_name="initial-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="initial-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__initial_config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_initial_config_primitive(self):
        self.__initial_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                         yc_initial_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_initial_config_primitive,
                                                                         yang_name="initial-config-primitive",
                                                                         parent=self, is_container='list',
                                                                         user_ordered=False,
                                                                         path_helper=self._path_helper, yang_keys='seq',
                                                                         extensions=None), is_container='list',
                                                       yang_name="initial-config-primitive", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, extensions=None,
                                                       namespace='urn:etsi:osm:yang:augments:day1-2',
                                                       defining_module='day1-2', yang_type='list', is_config=True)

    def _get_terminate_config_primitive(self):
        """
    Getter method for terminate_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive (list)

    YANG Description: Terminate set of configuration primitives.
    """
        return self.__terminate_config_primitive

    def _set_terminate_config_primitive(self, v, load=False):
        """
    Setter method for terminate_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/terminate_config_primitive (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_config_primitive() directly.

    YANG Description: Terminate set of configuration primitives.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("seq",
                                                  yc_terminate_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive,
                                                  yang_name="terminate-config-primitive", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='seq', extensions=None),
                             is_container='list', yang_name="terminate-config-primitive", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """terminate_config_primitive must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("seq",yc_terminate_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive, yang_name="terminate-config-primitive", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='seq', extensions=None), is_container='list', yang_name="terminate-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__terminate_config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_terminate_config_primitive(self):
        self.__terminate_config_primitive = YANGDynClass(base=YANGListType("seq",
                                                                           yc_terminate_config_primitive_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_terminate_config_primitive,
                                                                           yang_name="terminate-config-primitive",
                                                                           parent=self, is_container='list',
                                                                           user_ordered=False,
                                                                           path_helper=self._path_helper,
                                                                           yang_keys='seq', extensions=None),
                                                         is_container='list', yang_name="terminate-config-primitive",
                                                         parent=self, path_helper=self._path_helper,
                                                         extmethods=self._extmethods, register_paths=True,
                                                         extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='list', is_config=True)

    def _get_metrics(self):
        """
    Getter method for metrics, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/metrics (list)

    YANG Description: List of VNFC related metrics
    """
        return self.__metrics

    def _set_metrics(self, v, load=False):
        """
    Setter method for metrics, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/metrics (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metrics is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metrics() directly.

    YANG Description: List of VNFC related metrics
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_metrics_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_metrics,
                                                  yang_name="metrics", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="metrics",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metrics must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_metrics_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_metrics, yang_name="metrics", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="metrics", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__metrics = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metrics(self):
        self.__metrics = YANGDynClass(base=YANGListType("name",
                                                        yc_metrics_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_metrics,
                                                        yang_name="metrics", parent=self, is_container='list',
                                                        user_ordered=False, path_helper=self._path_helper,
                                                        yang_keys='name', extensions=None), is_container='list',
                                      yang_name="metrics", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, extensions=None,
                                      namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                      yang_type='list', is_config=True)

    def _get_relation(self):
        """
    Getter method for relation, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation (list)

    YANG Description: List of relations between elements in this descriptor.
    """
        return self.__relation

    def _set_relation(self, v, load=False):
        """
    Setter method for relation, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/relation (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_relation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_relation() directly.

    YANG Description: List of relations between elements in this descriptor.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_relation_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation,
                                                  yang_name="relation", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="relation",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """relation must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_relation_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation, yang_name="relation", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="relation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__relation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_relation(self):
        self.__relation = YANGDynClass(base=YANGListType("name",
                                                         yc_relation_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_relation,
                                                         yang_name="relation", parent=self, is_container='list',
                                                         user_ordered=False, path_helper=self._path_helper,
                                                         yang_keys='name', extensions=None), is_container='list',
                                       yang_name="relation", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True, extensions=None,
                                       namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                       yang_type='list', is_config=True)

    def _get_config_access(self):
        """
    Getter method for config_access, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access (container)

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
        return self.__config_access

    def _set_config_access(self, v, load=False):
        """
    Setter method for config_access, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/config_access (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_config_access is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_config_access() directly.

    YANG Description: Indicates the way to access to the xNF or xDU for VCA configuration.
For the moment there is a single way (ssh-access).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_config_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access,
                             is_container='container', yang_name="config-access", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """config_access must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_config_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access, is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container', is_config=True)""",
            })

        self.__config_access = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_config_access(self):
        self.__config_access = YANGDynClass(
            base=yc_config_access_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2_config_access,
            is_container='container', yang_name="config-access", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='container',
            is_config=True)

    def _get_blacklist_config_primitive(self):
        """
    Getter method for blacklist_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/blacklist_config_primitive (enumeration)

    YANG Description: List of blacklisted config primitives from the list of
default kdu config primitives
    """
        return self.__blacklist_config_primitive

    def _set_blacklist_config_primitive(self, v, load=False):
        """
    Setter method for blacklist_config_primitive, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2/blacklist_config_primitive (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_blacklist_config_primitive is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_blacklist_config_primitive() directly.

    YANG Description: List of blacklisted config primitives from the list of
default kdu config primitives
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                 restriction_arg={'upgrade': {}, 'rollback': {}}, )), is_leaf=False,
                             yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """blacklist_config_primitive must be of a type compatible with enumeration""",
                'defined-type': "day1-2:enumeration",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'upgrade': {}, 'rollback': {}},)), is_leaf=False, yang_name="blacklist-config-primitive", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='enumeration', is_config=True)""",
            })

        self.__blacklist_config_primitive = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_blacklist_config_primitive(self):
        self.__blacklist_config_primitive = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'upgrade': {}, 'rollback': {}}, )), is_leaf=False,
                                                         yang_name="blacklist-config-primitive", parent=self,
                                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                                         register_paths=True,
                                                         namespace='urn:etsi:osm:yang:augments:day1-2',
                                                         defining_module='day1-2', yang_type='enumeration',
                                                         is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    script = __builtin__.property(_get_script, _set_script)
    juju = __builtin__.property(_get_juju, _set_juju)
    execution_environment_list = __builtin__.property(_get_execution_environment_list, _set_execution_environment_list)
    config_primitive = __builtin__.property(_get_config_primitive, _set_config_primitive)
    initial_config_primitive = __builtin__.property(_get_initial_config_primitive, _set_initial_config_primitive)
    terminate_config_primitive = __builtin__.property(_get_terminate_config_primitive, _set_terminate_config_primitive)
    metrics = __builtin__.property(_get_metrics, _set_metrics)
    relation = __builtin__.property(_get_relation, _set_relation)
    config_access = __builtin__.property(_get_config_access, _set_config_access)
    blacklist_config_primitive = __builtin__.property(_get_blacklist_config_primitive, _set_blacklist_config_primitive)

    __choices__ = {'config-method': {'script': ['script'], 'juju': ['juju'],
                                     'execution-environment-list': ['execution_environment_list']}}
    _pyangbind_elements = OrderedDict(
        [('id', id), ('script', script), ('juju', juju), ('execution_environment_list', execution_environment_list),
         ('config_primitive', config_primitive), ('initial_config_primitive', initial_config_primitive),
         ('terminate_config_primitive', terminate_config_primitive), ('metrics', metrics), ('relation', relation),
         ('config_access', config_access), ('blacklist_config_primitive', blacklist_config_primitive), ])


class yc_operate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/operate-vnf-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__min_graceful_stop_timeout', '__max_recommended_graceful_stop_timeout',
        '__parameter', '__day1_2',)

    _yang_name = 'operate-vnf-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)
        self.__day1_2 = YANGDynClass(base=YANGListType("id",
                                                       yc_day1_2_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2,
                                                       yang_name="day1-2", parent=self, is_container='list',
                                                       user_ordered=False, path_helper=self._path_helper,
                                                       yang_keys='id', extensions=None), is_container='list',
                                     yang_name="day1-2", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True, extensions=None,
                                     namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                     yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'operate-vnf-op-config']

    def _get_min_graceful_stop_timeout(self):
        """
    Getter method for min_graceful_stop_timeout, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/min_graceful_stop_timeout (yang:timeticks)

    YANG Description: Minimum timeout value for graceful stop of a VNF
instance.
    """
        return self.__min_graceful_stop_timeout

    def _set_min_graceful_stop_timeout(self, v, load=False):
        """
    Setter method for min_graceful_stop_timeout, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/min_graceful_stop_timeout (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_min_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_min_graceful_stop_timeout() directly.

    YANG Description: Minimum timeout value for graceful stop of a VNF
instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32),
                             default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32)(1), is_leaf=True,
                             yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """min_graceful_stop_timeout must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1), is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__min_graceful_stop_timeout = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_min_graceful_stop_timeout(self):
        self.__min_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            default=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32)(1),
            is_leaf=True, yang_name="min-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)

    def _get_max_recommended_graceful_stop_timeout(self):
        """
    Getter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/max_recommended_graceful_stop_timeout (yang:timeticks)

    YANG Description: Maximum recommended timeout value that can be
needed to gracefully stop a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator facilitating
the selection of optimal timeout value. This value
is not used as constraint.
    """
        return self.__max_recommended_graceful_stop_timeout

    def _set_max_recommended_graceful_stop_timeout(self, v, load=False):
        """
    Setter method for max_recommended_graceful_stop_timeout, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/max_recommended_graceful_stop_timeout (yang:timeticks)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_recommended_graceful_stop_timeout is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_recommended_graceful_stop_timeout() directly.

    YANG Description: Maximum recommended timeout value that can be
needed to gracefully stop a VNF instance of a
particular type under certain conditions, such as
maximum load condition. This is provided by VNF
provider as information for the operator facilitating
the selection of optimal timeout value. This value
is not used as constraint.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True,
                             yang_name="max-recommended-graceful-stop-timeout", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='yang:timeticks', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_recommended_graceful_stop_timeout must be of a type compatible with yang:timeticks""",
                'defined-type': "yang:timeticks",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)""",
            })

        self.__max_recommended_graceful_stop_timeout = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_recommended_graceful_stop_timeout(self):
        self.__max_recommended_graceful_stop_timeout = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="max-recommended-graceful-stop-timeout", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='yang:timeticks', is_config=True)

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    def _get_day1_2(self):
        """
    Getter method for day1_2, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2 (list)
    """
        return self.__day1_2

    def _set_day1_2(self, v, load=False):
        """
    Setter method for day1_2, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config/day1_2 (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_day1_2 is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_day1_2() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_day1_2_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2,
                                                  yang_name="day1-2", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="day1-2",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2',
                             defining_module='day1-2', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """day1_2 must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_day1_2_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2, yang_name="day1-2", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="day1-2", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2', yang_type='list', is_config=True)""",
            })

        self.__day1_2 = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_day1_2(self):
        self.__day1_2 = YANGDynClass(base=YANGListType("id",
                                                       yc_day1_2_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config_day1_2,
                                                       yang_name="day1-2", parent=self, is_container='list',
                                                       user_ordered=False, path_helper=self._path_helper,
                                                       yang_keys='id', extensions=None), is_container='list',
                                     yang_name="day1-2", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True, extensions=None,
                                     namespace='urn:etsi:osm:yang:augments:day1-2', defining_module='day1-2',
                                     yang_type='list', is_config=True)

    min_graceful_stop_timeout = __builtin__.property(_get_min_graceful_stop_timeout, _set_min_graceful_stop_timeout)
    max_recommended_graceful_stop_timeout = __builtin__.property(_get_max_recommended_graceful_stop_timeout,
                                                                 _set_max_recommended_graceful_stop_timeout)
    parameter = __builtin__.property(_get_parameter, _set_parameter)
    day1_2 = __builtin__.property(_get_day1_2, _set_day1_2)

    _pyangbind_elements = OrderedDict([('min_graceful_stop_timeout', min_graceful_stop_timeout),
                                       ('max_recommended_graceful_stop_timeout', max_recommended_graceful_stop_timeout),
                                       ('parameter', parameter), ('day1_2', day1_2), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/change-vnf-flavour-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'change-vnf-flavour-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_vnf_flavour_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/change-vnf-flavour-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'change-vnf-flavour-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'change-vnf-flavour-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the OperateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/change-ext-vnf-connectivity-op-config/parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'change-ext-vnf-connectivity-op-config', 'parameter']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_change_ext_vnf_connectivity_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration/change-ext-vnf-connectivity-op-config. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__parameter',)

    _yang_name = 'change-ext-vnf-connectivity-op-config'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration', 'change-ext-vnf-connectivity-op-config']

    def _get_parameter(self):
        """
    Getter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter (list)

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
    """
        return self.__parameter

    def _set_parameter(self, v, load=False):
        """
    Setter method for parameter, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config/parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_parameter() directly.

    YANG Description: Array of KVP requirements for VNF-specific parameters
to be passed when invoking the
ChangeExtVnfConnectivity operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                  yang_name="parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="parameter",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter, yang_name="parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_parameter(self):
        self.__parameter = YANGDynClass(base=YANGListType("key",
                                                          yc_parameter_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config_parameter,
                                                          yang_name="parameter", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='key', extensions=None), is_container='list',
                                        yang_name="parameter", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    parameter = __builtin__.property(_get_parameter, _set_parameter)

    _pyangbind_elements = OrderedDict([('parameter', parameter), ])


class yc_lcm_operations_configuration_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/lcm-operations-configuration. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__instantiate_vnf_op_config', '__scale_vnf_op_config',
                 '__scale_vnf_to_level_op_config', '__heal_vnf_op_config', '__terminate_vnf_op_config',
                 '__operate_vnf_op_config', '__change_vnf_flavour_op_config',
                 '__change_ext_vnf_connectivity_op_config',)

    _yang_name = 'lcm-operations-configuration'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__instantiate_vnf_op_config = YANGDynClass(
            base=yc_instantiate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
            is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__scale_vnf_op_config = YANGDynClass(
            base=yc_scale_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
            is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__scale_vnf_to_level_op_config = YANGDynClass(
            base=yc_scale_vnf_to_level_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
            is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__heal_vnf_op_config = YANGDynClass(
            base=yc_heal_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
            is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__terminate_vnf_op_config = YANGDynClass(
            base=yc_terminate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
            is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__operate_vnf_op_config = YANGDynClass(
            base=yc_operate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
            is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__change_vnf_flavour_op_config = YANGDynClass(
            base=yc_change_vnf_flavour_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
            is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__change_ext_vnf_connectivity_op_config = YANGDynClass(
            base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
            is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'lcm-operations-configuration']

    def _get_instantiate_vnf_op_config(self):
        """
    Getter method for instantiate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config (container)

    YANG Description: Configuration parameters for the InstantiateVnf
operation.
    """
        return self.__instantiate_vnf_op_config

    def _set_instantiate_vnf_op_config(self, v, load=False):
        """
    Setter method for instantiate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/instantiate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiate_vnf_op_config() directly.

    YANG Description: Configuration parameters for the InstantiateVnf
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_instantiate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
                             is_container='container', yang_name="instantiate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_instantiate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config, is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__instantiate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiate_vnf_op_config(self):
        self.__instantiate_vnf_op_config = YANGDynClass(
            base=yc_instantiate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_instantiate_vnf_op_config,
            is_container='container', yang_name="instantiate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_scale_vnf_op_config(self):
        """
    Getter method for scale_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config (container)

    YANG Description: Configuration parameters for the ScaleVnf operation.
    """
        return self.__scale_vnf_op_config

    def _set_scale_vnf_op_config(self, v, load=False):
        """
    Setter method for scale_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_vnf_op_config() directly.

    YANG Description: Configuration parameters for the ScaleVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_scale_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
                             is_container='container', yang_name="scale-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_scale_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config, is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__scale_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_vnf_op_config(self):
        self.__scale_vnf_op_config = YANGDynClass(
            base=yc_scale_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_op_config,
            is_container='container', yang_name="scale-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_scale_vnf_to_level_op_config(self):
        """
    Getter method for scale_vnf_to_level_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
    """
        return self.__scale_vnf_to_level_op_config

    def _set_scale_vnf_to_level_op_config(self, v, load=False):
        """
    Setter method for scale_vnf_to_level_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/scale_vnf_to_level_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_vnf_to_level_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_vnf_to_level_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the ScaleVnfToLevel
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_scale_vnf_to_level_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
                             is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_vnf_to_level_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_scale_vnf_to_level_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config, is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__scale_vnf_to_level_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_vnf_to_level_op_config(self):
        self.__scale_vnf_to_level_op_config = YANGDynClass(
            base=yc_scale_vnf_to_level_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_scale_vnf_to_level_op_config,
            is_container='container', yang_name="scale-vnf-to-level-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_heal_vnf_op_config(self):
        """
    Getter method for heal_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
    """
        return self.__heal_vnf_op_config

    def _set_heal_vnf_op_config(self, v, load=False):
        """
    Setter method for heal_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/heal_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_heal_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_heal_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the HealVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_heal_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
                             is_container='container', yang_name="heal-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """heal_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_heal_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config, is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__heal_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_heal_vnf_op_config(self):
        self.__heal_vnf_op_config = YANGDynClass(
            base=yc_heal_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_heal_vnf_op_config,
            is_container='container', yang_name="heal-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_terminate_vnf_op_config(self):
        """
    Getter method for terminate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
    """
        return self.__terminate_vnf_op_config

    def _set_terminate_vnf_op_config(self, v, load=False):
        """
    Setter method for terminate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/terminate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_terminate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_terminate_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the TerminateVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_terminate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
                             is_container='container', yang_name="terminate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """terminate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_terminate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config, is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__terminate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_terminate_vnf_op_config(self):
        self.__terminate_vnf_op_config = YANGDynClass(
            base=yc_terminate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_terminate_vnf_op_config,
            is_container='container', yang_name="terminate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_operate_vnf_op_config(self):
        """
    Getter method for operate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config (container)

    YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
    """
        return self.__operate_vnf_op_config

    def _set_operate_vnf_op_config(self, v, load=False):
        """
    Setter method for operate_vnf_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/operate_vnf_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_operate_vnf_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_operate_vnf_op_config() directly.

    YANG Description: This information element defines attributes that
affect the invocation of the OperateVnf operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_operate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
                             is_container='container', yang_name="operate-vnf-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """operate_vnf_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_operate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config, is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__operate_vnf_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_operate_vnf_op_config(self):
        self.__operate_vnf_op_config = YANGDynClass(
            base=yc_operate_vnf_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_operate_vnf_op_config,
            is_container='container', yang_name="operate-vnf-op-config", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_change_vnf_flavour_op_config(self):
        """
    Getter method for change_vnf_flavour_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config (container)

    YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
    """
        return self.__change_vnf_flavour_op_config

    def _set_change_vnf_flavour_op_config(self, v, load=False):
        """
    Setter method for change_vnf_flavour_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_vnf_flavour_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_vnf_flavour_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_vnf_flavour_op_config() directly.

    YANG Description: Configuration parameters for the ChangeVnfFlavour
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_change_vnf_flavour_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
                             is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """change_vnf_flavour_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_change_vnf_flavour_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config, is_container='container', yang_name="change-vnf-flavour-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__change_vnf_flavour_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_change_vnf_flavour_op_config(self):
        self.__change_vnf_flavour_op_config = YANGDynClass(
            base=yc_change_vnf_flavour_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_vnf_flavour_op_config,
            is_container='container', yang_name="change-vnf-flavour-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_change_ext_vnf_connectivity_op_config(self):
        """
    Getter method for change_ext_vnf_connectivity_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config (container)

    YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
    """
        return self.__change_ext_vnf_connectivity_op_config

    def _set_change_ext_vnf_connectivity_op_config(self, v, load=False):
        """
    Setter method for change_ext_vnf_connectivity_op_config, mapped from YANG variable /vnfd/df/lcm_operations_configuration/change_ext_vnf_connectivity_op_config (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_change_ext_vnf_connectivity_op_config is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_change_ext_vnf_connectivity_op_config() directly.

    YANG Description: Configuration parameters for the
ChangeExtVnfConnectivity operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
                             is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """change_ext_vnf_connectivity_op_config must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config, is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__change_ext_vnf_connectivity_op_config = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_change_ext_vnf_connectivity_op_config(self):
        self.__change_ext_vnf_connectivity_op_config = YANGDynClass(
            base=yc_change_ext_vnf_connectivity_op_config_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration_change_ext_vnf_connectivity_op_config,
            is_container='container', yang_name="change-ext-vnf-connectivity-op-config", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    instantiate_vnf_op_config = __builtin__.property(_get_instantiate_vnf_op_config, _set_instantiate_vnf_op_config)
    scale_vnf_op_config = __builtin__.property(_get_scale_vnf_op_config, _set_scale_vnf_op_config)
    scale_vnf_to_level_op_config = __builtin__.property(_get_scale_vnf_to_level_op_config,
                                                        _set_scale_vnf_to_level_op_config)
    heal_vnf_op_config = __builtin__.property(_get_heal_vnf_op_config, _set_heal_vnf_op_config)
    terminate_vnf_op_config = __builtin__.property(_get_terminate_vnf_op_config, _set_terminate_vnf_op_config)
    operate_vnf_op_config = __builtin__.property(_get_operate_vnf_op_config, _set_operate_vnf_op_config)
    change_vnf_flavour_op_config = __builtin__.property(_get_change_vnf_flavour_op_config,
                                                        _set_change_vnf_flavour_op_config)
    change_ext_vnf_connectivity_op_config = __builtin__.property(_get_change_ext_vnf_connectivity_op_config,
                                                                 _set_change_ext_vnf_connectivity_op_config)

    _pyangbind_elements = OrderedDict(
        [('instantiate_vnf_op_config', instantiate_vnf_op_config), ('scale_vnf_op_config', scale_vnf_op_config),
         ('scale_vnf_to_level_op_config', scale_vnf_to_level_op_config), ('heal_vnf_op_config', heal_vnf_op_config),
         ('terminate_vnf_op_config', terminate_vnf_op_config), ('operate_vnf_op_config', operate_vnf_op_config),
         ('change_vnf_flavour_op_config', change_vnf_flavour_op_config),
         ('change_ext_vnf_connectivity_op_config', change_ext_vnf_connectivity_op_config), ])


class yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_affinity_or_anti_affinity_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/affinity-or-anti-affinity-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__type', '__scope',)

    _yang_name = 'affinity-or-anti-affinity-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='affinity-type', is_config=True)
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='affinity-scope', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'affinity-or-anti-affinity-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/id (string)

    YANG Description: Identifies an affinity or anti-affinity group to which
the affinity or anti-affinity rule applies.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifies an affinity or anti-affinity group to which
the affinity or anti-affinity rule applies.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_type(self):
        """
    Getter method for type, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/type (affinity-type)

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        return self.__type

    def _set_type(self, v, load=False):
        """
    Setter method for type, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/type (affinity-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_type() directly.

    YANG Description: Specifies whether the rule is an affinity rule or an
anti-affinity rule.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                             is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='affinity-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """type must be of a type compatible with affinity-type""",
                'defined-type': "etsi-nfv-vnfd:affinity-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'affinity': {}, 'anti-affinity': {}},), is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-type', is_config=True)""",
            })

        self.__type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_type(self):
        self.__type = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'affinity': {}, 'anti-affinity': {}}, ),
                                   is_leaf=True, yang_name="type", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='affinity-type', is_config=True)

    def _get_scope(self):
        """
    Getter method for scope, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/scope (affinity-scope)

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        return self.__scope

    def _set_scope(self, v, load=False):
        """
    Setter method for scope, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group/scope (affinity-scope)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scope is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scope() directly.

    YANG Description: Specifies the scope of the rule, possible values are
'NFVI-PoP', 'Zone', 'ZoneGroup', 'NFVI-node'.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {},
                                                                          'nfvi-pop': {}}, ), is_leaf=True,
                             yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='affinity-scope', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scope must be of a type compatible with affinity-scope""",
                'defined-type': "etsi-nfv-vnfd:affinity-scope",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'nfvi-node': {}, 'zone-group': {}, 'zone': {}, 'nfvi-pop': {}},), is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='affinity-scope', is_config=True)""",
            })

        self.__scope = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scope(self):
        self.__scope = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                             restriction_arg={'nfvi-node': {}, 'zone-group': {},
                                                                              'zone': {}, 'nfvi-pop': {}}, ),
                                    is_leaf=True, yang_name="scope", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='affinity-scope', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    type = __builtin__.property(_get_type, _set_type)
    scope = __builtin__.property(_get_scope, _set_scope)

    _pyangbind_elements = OrderedDict([('id', id), ('type', type), ('scope', scope), ])


class yc_indicator_etsi_nfv_vnfd__vnfd_df_indicator(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/indicator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__indicator_value', '__source',)

    _yang_name = 'indicator'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__indicator_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value",
                                              parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'indicator']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/indicator/id (string)

    YANG Description: Unique identifier.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/indicator/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/indicator/name (string)

    YANG Description: The human readable name of the VnfIndicator.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/indicator/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The human readable name of the VnfIndicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_indicator_value(self):
        """
    Getter method for indicator_value, mapped from YANG variable /vnfd/df/indicator/indicator_value (string)

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        return self.__indicator_value

    def _set_indicator_value(self, v, load=False):
        """
    Setter method for indicator_value, mapped from YANG variable /vnfd/df/indicator/indicator_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator_value() directly.

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="indicator-value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__indicator_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator_value(self):
        self.__indicator_value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="indicator-value",
                                              parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_source(self):
        """
    Getter method for source, mapped from YANG variable /vnfd/df/indicator/source (enumeration)

    YANG Description: Describe the source of the indicator. The possible
values are:
• VNF.
• EM.
• Both.

This tells the consumer where to send the subscription
request.
    """
        return self.__source

    def _set_source(self, v, load=False):
        """
    Setter method for source, mapped from YANG variable /vnfd/df/indicator/source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Describe the source of the indicator. The possible
values are:
• VNF.
• EM.
• Both.

This tells the consumer where to send the subscription
request.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                             is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """source must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf': {}, 'em': {}, 'both': {}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__source = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_source(self):
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    indicator_value = __builtin__.property(_get_indicator_value, _set_indicator_value)
    source = __builtin__.property(_get_source, _set_source)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('indicator_value', indicator_value), ('source', source), ])


class yc_interface_details_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces_interface_details(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/supported-vnf-interfaces/interface-details. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'interface-details'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'supported-vnf-interfaces', 'interface-details']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_supported_vnf_interfaces_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/supported-vnf-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__cpd_id', '__interface_details',)

    _yang_name = 'supported-vnf-interfaces'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'vnf-configuration': {},
                                                                             'vnf-indicator': {}}, ), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='enumeration', is_config=True)
        self.__cpd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                     yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='leafref', is_config=True)
        self.__interface_details = YANGDynClass(base=YANGListType("key",
                                                                  yc_interface_details_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces_interface_details,
                                                                  yang_name="interface-details", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='key',
                                                                  extensions=None), is_container='list',
                                                yang_name="interface-details", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'supported-vnf-interfaces']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/name (enumeration)

    YANG Description: Identifies an interface produced by the VNF. Valid
values:
- VNF_CONFIGURATION
- VNF_INDICATOR
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/name (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Identifies an interface produced by the VNF. Valid
values:
- VNF_CONFIGURATION
- VNF_INDICATOR
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf-configuration': {},
                                                                          'vnf-indicator': {}}, ), is_leaf=True,
                             yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf-configuration': {}, 'vnf-indicator': {}},), is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                            restriction_arg={'vnf-configuration': {},
                                                                             'vnf-indicator': {}}, ), is_leaf=True,
                                   yang_name="name", parent=self, path_helper=self._path_helper,
                                   extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='enumeration', is_config=True)

    def _get_cpd_id(self):
        """
    Getter method for cpd_id, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/cpd_id (leafref)

    YANG Description: References one or more CPDs from which to instantiate
external CPs through which interface endpoints on the
VNF side can be reached by the VNFM.
    """
        return self.__cpd_id

    def _set_cpd_id(self, v, load=False):
        """
    Setter method for cpd_id, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/cpd_id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cpd_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cpd_id() directly.

    YANG Description: References one or more CPDs from which to instantiate
external CPs through which interface endpoints on the
VNF side can be reached by the VNFM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cpd_id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="cpd-id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__cpd_id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cpd_id(self):
        self.__cpd_id = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                     yang_name="cpd-id", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='leafref', is_config=True)

    def _get_interface_details(self):
        """
    Getter method for interface_details, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details (list)
    """
        return self.__interface_details

    def _set_interface_details(self, v, load=False):
        """
    Setter method for interface_details, mapped from YANG variable /vnfd/df/supported_vnf_interfaces/interface_details (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_details() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_interface_details_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces_interface_details,
                                                  yang_name="interface-details", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="interface-details",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """interface_details must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_interface_details_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces_interface_details, yang_name="interface-details", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="interface-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__interface_details = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_interface_details(self):
        self.__interface_details = YANGDynClass(base=YANGListType("key",
                                                                  yc_interface_details_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces_interface_details,
                                                                  yang_name="interface-details", parent=self,
                                                                  is_container='list', user_ordered=False,
                                                                  path_helper=self._path_helper, yang_keys='key',
                                                                  extensions=None), is_container='list',
                                                yang_name="interface-details", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, extensions=None,
                                                namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    cpd_id = __builtin__.property(_get_cpd_id, _set_cpd_id)
    interface_details = __builtin__.property(_get_interface_details, _set_interface_details)

    _pyangbind_elements = OrderedDict([('name', name), ('cpd_id', cpd_id), ('interface_details', interface_details), ])


class yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_df_monitoring_parameter(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/monitoring-parameter. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__performance_metric', '__collection_period',)

    _yang_name = 'monitoring-parameter'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'monitoring-parameter']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/monitoring_parameter/id (string)

    YANG Description: Unique identifier of the monitoring parameter.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/monitoring_parameter/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of the monitoring parameter.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/monitoring_parameter/name (string)

    YANG Description: Human readable name of the monitoring parameter.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/monitoring_parameter/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the monitoring parameter.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_performance_metric(self):
        """
    Getter method for performance_metric, mapped from YANG variable /vnfd/df/monitoring_parameter/performance_metric (string)

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        return self.__performance_metric

    def _set_performance_metric(self, v, load=False):
        """
    Setter method for performance_metric, mapped from YANG variable /vnfd/df/monitoring_parameter/performance_metric (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_performance_metric is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_performance_metric() directly.

    YANG Description: Performance metric that is monitored. This attribute shall
contain the related 'Measurement Name' value as defined in
clause 7.2 of ETSI GS NFV-IFA 027
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """performance_metric must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__performance_metric = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_performance_metric(self):
        self.__performance_metric = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="performance-metric",
                                                 parent=self, path_helper=self._path_helper,
                                                 extmethods=self._extmethods, register_paths=True,
                                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_collection_period(self):
        """
    Getter method for collection_period, mapped from YANG variable /vnfd/df/monitoring_parameter/collection_period (uint64)

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        return self.__collection_period

    def _set_collection_period(self, v, load=False):
        """
    Setter method for collection_period, mapped from YANG variable /vnfd/df/monitoring_parameter/collection_period (uint64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_collection_period is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_collection_period() directly.

    YANG Description: An attribute that describes the recommended periodicity at
which to collect the performance information. VNFM determines
if this parameter is considered.

The vendor may provide this information as a guidance for
creating PmJobs if needed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long,
                                                         restriction_dict={'range': ['0..18446744073709551615']},
                                                         int_size=64), is_leaf=True, yang_name="collection-period",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """collection_period must be of a type compatible with uint64""",
                'defined-type': "uint64",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range':  ['0..18446744073709551615']}, int_size=64), is_leaf=True, yang_name="collection-period", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64', is_config=True)""",
            })

        self.__collection_period = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_collection_period(self):
        self.__collection_period = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..18446744073709551615']},
                                     int_size=64), is_leaf=True, yang_name="collection-period", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint64',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    performance_metric = __builtin__.property(_get_performance_metric, _set_performance_metric)
    collection_period = __builtin__.property(_get_collection_period, _set_collection_period)

    _pyangbind_elements = OrderedDict([('id', id), ('name', name), ('performance_metric', performance_metric),
                                       ('collection_period', collection_period), ])


class yc_vdu_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/aspect-delta-details/deltas/vdu-delta. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__number_of_instances',)

    _yang_name = 'vdu-delta'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        self.__number_of_instances = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas', 'vdu-delta']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/id (leafref)

    YANG Description: Uniquely identifies a VDU.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/id (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a VDU.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    def _get_number_of_instances(self):
        """
    Getter method for number_of_instances, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/number_of_instances (uint32)

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for an instantiation level or for a
scaling delta. Shall be zero or greater.
    """
        return self.__number_of_instances

    def _set_number_of_instances(self, v, load=False):
        """
    Setter method for number_of_instances, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta/number_of_instances (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_number_of_instances is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_number_of_instances() directly.

    YANG Description: Number of instances of VNFC based on this VDU to
deploy for an instantiation level or for a
scaling delta. Shall be zero or greater.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                              int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True,
                             yang_name="number-of-instances", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """number_of_instances must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__number_of_instances = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_number_of_instances(self):
        self.__number_of_instances = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['0..max']}), is_leaf=True, yang_name="number-of-instances", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    number_of_instances = __builtin__.property(_get_number_of_instances, _set_number_of_instances)

    _pyangbind_elements = OrderedDict([('id', id), ('number_of_instances', number_of_instances), ])


class yc_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/aspect-delta-details/deltas/virtual-link-bit-rate-delta/bit-rate-requirements. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
  """
    __slots__ = ('_path_helper', '_extmethods', '__root', '__leaf',)

    _yang_name = 'bit-rate-requirements'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas', 'virtual-link-bit-rate-delta',
                    'bit-rate-requirements']

    def _get_root(self):
        """
    Getter method for root, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/root (uint32)

    YANG Description: Throughput requirement of the link (e.g.
bitrate of E-Line, root bitrate of E-Tree,
aggregate capacity of E-LAN).
    """
        return self.__root

    def _set_root(self, v, load=False):
        """
    Setter method for root, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/root (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_root is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_root() directly.

    YANG Description: Throughput requirement of the link (e.g.
bitrate of E-Line, root bitrate of E-Tree,
aggregate capacity of E-LAN).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="root", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """root must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__root = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_root(self):
        self.__root = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="root", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    def _get_leaf(self):
        """
    Getter method for leaf, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/leaf (uint32)

    YANG Description: Throughput requirement of leaf connections to
the link when applicable to the connectivity
type (e.g. for E-Tree and E-LAN branches).
    """
        return self.__leaf

    def _set_leaf(self, v, load=False):
        """
    Setter method for leaf, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements/leaf (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_leaf is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_leaf() directly.

    YANG Description: Throughput requirement of leaf connections to
the link when applicable to the connectivity
type (e.g. for E-Tree and E-LAN branches).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="leaf", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """leaf must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__leaf = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_leaf(self):
        self.__leaf = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="leaf", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='uint32', is_config=True)

    root = __builtin__.property(_get_root, _set_root)
    leaf = __builtin__.property(_get_leaf, _set_leaf)

    _pyangbind_elements = OrderedDict([('root', root), ('leaf', leaf), ])


class yc_virtual_link_bit_rate_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/aspect-delta-details/deltas/virtual-link-bit-rate-delta. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__bit_rate_requirements',)

    _yang_name = 'virtual-link-bit-rate-delta'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__bit_rate_requirements = YANGDynClass(
            base=yc_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
            is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas', 'virtual-link-bit-rate-delta']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/id (string)

    YANG Description: Uniquely identifies a VnfVirtualLinkDesc.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Uniquely identifies a VnfVirtualLinkDesc.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_bit_rate_requirements(self):
        """
    Getter method for bit_rate_requirements, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements (container)

    YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
    """
        return self.__bit_rate_requirements

    def _set_bit_rate_requirements(self, v, load=False):
        """
    Setter method for bit_rate_requirements, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta/bit_rate_requirements (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_bit_rate_requirements is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_bit_rate_requirements() directly.

    YANG Description: Bitrate requirements for an instantiation level
or bitrate delta for a scaling step.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
                             is_container='container', yang_name="bit-rate-requirements", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """bit_rate_requirements must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements, is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__bit_rate_requirements = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_bit_rate_requirements(self):
        self.__bit_rate_requirements = YANGDynClass(
            base=yc_bit_rate_requirements_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta_bit_rate_requirements,
            is_container='container', yang_name="bit-rate-requirements", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    bit_rate_requirements = __builtin__.property(_get_bit_rate_requirements, _set_bit_rate_requirements)

    _pyangbind_elements = OrderedDict([('id', id), ('bit_rate_requirements', bit_rate_requirements), ])


class yc_deltas_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/aspect-delta-details/deltas. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__vdu_delta', '__virtual_link_bit_rate_delta',)

    _yang_name = 'deltas'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__vdu_delta = YANGDynClass(base=YANGListType("id",
                                                          yc_vdu_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                          yang_name="vdu-delta", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='id', extensions=None), is_container='list',
                                        yang_name="vdu-delta", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)
        self.__virtual_link_bit_rate_delta = YANGDynClass(base=YANGListType("id",
                                                                            yc_virtual_link_bit_rate_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                                            yang_name="virtual-link-bit-rate-delta",
                                                                            parent=self, is_container='list',
                                                                            user_ordered=False,
                                                                            path_helper=self._path_helper,
                                                                            yang_keys='id', extensions=None),
                                                          is_container='list', yang_name="virtual-link-bit-rate-delta",
                                                          parent=self, path_helper=self._path_helper,
                                                          extmethods=self._extmethods, register_paths=True,
                                                          extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                          defining_module='etsi-nfv-vnfd', yang_type='list',
                                                          is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'aspect-delta-details', 'deltas']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/id (string)

    YANG Description: Identifier of this scaling delta.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this scaling delta.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_vdu_delta(self):
        """
    Getter method for vdu_delta, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta (list)

    YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
    """
        return self.__vdu_delta

    def _set_vdu_delta(self, v, load=False):
        """
    Setter method for vdu_delta, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/vdu_delta (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_delta() directly.

    YANG Description: The number of VNFC instances based on particular
VDUs to be created or removed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_vdu_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                  yang_name="vdu-delta", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vdu-delta",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_delta must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta, yang_name="vdu-delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_delta = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_delta(self):
        self.__vdu_delta = YANGDynClass(base=YANGListType("id",
                                                          yc_vdu_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_vdu_delta,
                                                          yang_name="vdu-delta", parent=self, is_container='list',
                                                          user_ordered=False, path_helper=self._path_helper,
                                                          yang_keys='id', extensions=None), is_container='list',
                                        yang_name="vdu-delta", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True, extensions=None,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='list', is_config=True)

    def _get_virtual_link_bit_rate_delta(self):
        """
    Getter method for virtual_link_bit_rate_delta, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta (list)

    YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
    """
        return self.__virtual_link_bit_rate_delta

    def _set_virtual_link_bit_rate_delta(self, v, load=False):
        """
    Setter method for virtual_link_bit_rate_delta, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas/virtual_link_bit_rate_delta (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_bit_rate_delta is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_bit_rate_delta() directly.

    YANG Description: The bitrate to be added or removed to virtual links
created from particular virtual link descriptors.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_virtual_link_bit_rate_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                  yang_name="virtual-link-bit-rate-delta", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="virtual-link-bit-rate-delta", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_bit_rate_delta must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_link_bit_rate_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta, yang_name="virtual-link-bit-rate-delta", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-link-bit-rate-delta", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_bit_rate_delta = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_bit_rate_delta(self):
        self.__virtual_link_bit_rate_delta = YANGDynClass(base=YANGListType("id",
                                                                            yc_virtual_link_bit_rate_delta_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas_virtual_link_bit_rate_delta,
                                                                            yang_name="virtual-link-bit-rate-delta",
                                                                            parent=self, is_container='list',
                                                                            user_ordered=False,
                                                                            path_helper=self._path_helper,
                                                                            yang_keys='id', extensions=None),
                                                          is_container='list', yang_name="virtual-link-bit-rate-delta",
                                                          parent=self, path_helper=self._path_helper,
                                                          extmethods=self._extmethods, register_paths=True,
                                                          extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                          defining_module='etsi-nfv-vnfd', yang_type='list',
                                                          is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    vdu_delta = __builtin__.property(_get_vdu_delta, _set_vdu_delta)
    virtual_link_bit_rate_delta = __builtin__.property(_get_virtual_link_bit_rate_delta,
                                                       _set_virtual_link_bit_rate_delta)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('vdu_delta', vdu_delta), ('virtual_link_bit_rate_delta', virtual_link_bit_rate_delta), ])


class yc_aspect_delta_details_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/aspect-delta-details. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
  """
    __slots__ = ('_path_helper', '_extmethods', '__deltas', '__step_deltas',)

    _yang_name = 'aspect-delta-details'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__deltas = YANGDynClass(
            base=YANGListType("id", yc_deltas_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                              yang_name="deltas", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__step_deltas = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'aspect-delta-details']

    def _get_deltas(self):
        """
    Getter method for deltas, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas (list)

    YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
    """
        return self.__deltas

    def _set_deltas(self, v, load=False):
        """
    Setter method for deltas, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/deltas (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_deltas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_deltas() directly.

    YANG Description: Declares different scaling deltas, each of which is
applied for one or more scaling steps of this
aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_deltas_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                                                  yang_name="deltas", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="deltas",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """deltas must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_deltas_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas, yang_name="deltas", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__deltas = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_deltas(self):
        self.__deltas = YANGDynClass(
            base=YANGListType("id", yc_deltas_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details_deltas,
                              yang_name="deltas", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_step_deltas(self):
        """
    Getter method for step_deltas, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/step_deltas (leafref)

    YANG Description: Identifiers of the individual scaling deltas to be
applied for the subsequent scaling steps of this
aspect. The first entry in the array shall correspond
to the first scaling step (between scale levels 0 to
1) and the last entry in the array shall correspond
to the last scaling step (between maxScaleLevel-1
and maxScaleLevel).

Each referenced scaling delta shall be declared in
the 'deltas' attribute.
    """
        return self.__step_deltas

    def _set_step_deltas(self, v, load=False):
        """
    Setter method for step_deltas, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details/step_deltas (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_step_deltas is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_step_deltas() directly.

    YANG Description: Identifiers of the individual scaling deltas to be
applied for the subsequent scaling steps of this
aspect. The first entry in the array shall correspond
to the first scaling step (between scale levels 0 to
1) and the last entry in the array shall correspond
to the last scaling step (between maxScaleLevel-1
and maxScaleLevel).

Each referenced scaling delta shall be declared in
the 'deltas' attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """step_deltas must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__step_deltas = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_step_deltas(self):
        self.__step_deltas = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="step-deltas", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    deltas = __builtin__.property(_get_deltas, _set_deltas)
    step_deltas = __builtin__.property(_get_step_deltas, _set_step_deltas)

    _pyangbind_elements = OrderedDict([('deltas', deltas), ('step_deltas', step_deltas), ])


class yc_scaling_criteria_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy_scaling_criteria(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/scaling-policy/scaling-criteria. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: list of conditions to be met for generating scaling
  requests
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__scale_in_threshold', '__scale_in_relational_operation',
                 '__scale_out_threshold', '__scale_out_relational_operation', '__vnf_monitoring_param_ref',)

    _yang_name = 'scaling-criteria'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                   defining_module='scaling', yang_type='string', is_config=True)
        self.__scale_in_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                                                 yang_name="scale-in-threshold", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                                 defining_module='scaling', yang_type='decimal64', is_config=True)
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}}, ),
            default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:relational-operation-type', is_config=True)
        self.__scale_out_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                                                  yang_name="scale-out-threshold", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                                  defining_module='scaling', yang_type='decimal64', is_config=True)
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}}, ),
            default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:relational-operation-type', is_config=True)
        self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="vnf-monitoring-param-ref", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True,
                                                       namespace='urn:etsi:osm:yang:augments:scaling',
                                                       defining_module='scaling', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'scaling-policy', 'scaling-criteria']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/name (string)
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                   defining_module='scaling', yang_type='string', is_config=True)

    def _get_scale_in_threshold(self):
        """
    Getter method for scale_in_threshold, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_in_threshold (decimal64)

    YANG Description: Value below which scale-in requests are generated
    """
        return self.__scale_in_threshold

    def _set_scale_in_threshold(self, v, load=False):
        """
    Setter method for scale_in_threshold, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_in_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_threshold() directly.

    YANG Description: Value below which scale-in requests are generated
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                             yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_in_threshold must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-in-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='decimal64', is_config=True)""",
            })

        self.__scale_in_threshold = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_in_threshold(self):
        self.__scale_in_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                                                 yang_name="scale-in-threshold", parent=self,
                                                 path_helper=self._path_helper, extmethods=self._extmethods,
                                                 register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                                 defining_module='scaling', yang_type='decimal64', is_config=True)

    def _get_scale_in_relational_operation(self):
        """
    Getter method for scale_in_relational_operation, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_in_relational_operation (common:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        return self.__scale_in_relational_operation

    def _set_scale_in_relational_operation(self, v, load=False):
        """
    Setter method for scale_in_relational_operation, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_in_relational_operation (common:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-in-threshold.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {},
                                                                          'EQ': {}}, ), default=six.text_type("LE"),
                             is_leaf=True, yang_name="scale-in-relational-operation", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='common:relational-operation-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_in_relational_operation must be of a type compatible with common:relational-operation-type""",
                'defined-type': "common:relational-operation-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}},), default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:relational-operation-type', is_config=True)""",
            })

        self.__scale_in_relational_operation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_in_relational_operation(self):
        self.__scale_in_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}}, ),
            default=six.text_type("LE"), is_leaf=True, yang_name="scale-in-relational-operation", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:relational-operation-type', is_config=True)

    def _get_scale_out_threshold(self):
        """
    Getter method for scale_out_threshold, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_out_threshold (decimal64)

    YANG Description: Value above which scale-out requests are generated
    """
        return self.__scale_out_threshold

    def _set_scale_out_threshold(self, v, load=False):
        """
    Setter method for scale_out_threshold, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_out_threshold (decimal64)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_threshold is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_threshold() directly.

    YANG Description: Value above which scale-out requests are generated
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                             yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='decimal64', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_out_threshold must be of a type compatible with decimal64""",
                'defined-type': "decimal64",
                'generated-type': """YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True, yang_name="scale-out-threshold", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='decimal64', is_config=True)""",
            })

        self.__scale_out_threshold = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_out_threshold(self):
        self.__scale_out_threshold = YANGDynClass(base=RestrictedPrecisionDecimalType(precision=10), is_leaf=True,
                                                  yang_name="scale-out-threshold", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                                  defining_module='scaling', yang_type='decimal64', is_config=True)

    def _get_scale_out_relational_operation(self):
        """
    Getter method for scale_out_relational_operation, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_out_relational_operation (common:relational-operation-type)

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        return self.__scale_out_relational_operation

    def _set_scale_out_relational_operation(self, v, load=False):
        """
    Setter method for scale_out_relational_operation, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/scale_out_relational_operation (common:relational-operation-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_relational_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_relational_operation() directly.

    YANG Description: The relational operator used to compare the monitoring param
against the scale-out-threshold.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {},
                                                                          'EQ': {}}, ), default=six.text_type("GE"),
                             is_leaf=True, yang_name="scale-out-relational-operation", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='common:relational-operation-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_out_relational_operation must be of a type compatible with common:relational-operation-type""",
                'defined-type': "common:relational-operation-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}},), default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:relational-operation-type', is_config=True)""",
            })

        self.__scale_out_relational_operation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_out_relational_operation(self):
        self.__scale_out_relational_operation = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'GE': {}, 'LE': {}, 'GT': {}, 'LT': {}, 'EQ': {}}, ),
            default=six.text_type("GE"), is_leaf=True, yang_name="scale-out-relational-operation", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:relational-operation-type', is_config=True)

    def _get_vnf_monitoring_param_ref(self):
        """
    Getter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (string)

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        return self.__vnf_monitoring_param_ref

    def _set_vnf_monitoring_param_ref(self, v, load=False):
        """
    Setter method for vnf_monitoring_param_ref, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria/vnf_monitoring_param_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_monitoring_param_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_monitoring_param_ref() directly.

    YANG Description: Reference to the VNF level monitoring parameter
that is aggregated
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_monitoring_param_ref must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-monitoring-param-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='string', is_config=True)""",
            })

        self.__vnf_monitoring_param_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_monitoring_param_ref(self):
        self.__vnf_monitoring_param_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="vnf-monitoring-param-ref", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True,
                                                       namespace='urn:etsi:osm:yang:augments:scaling',
                                                       defining_module='scaling', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    scale_in_threshold = __builtin__.property(_get_scale_in_threshold, _set_scale_in_threshold)
    scale_in_relational_operation = __builtin__.property(_get_scale_in_relational_operation,
                                                         _set_scale_in_relational_operation)
    scale_out_threshold = __builtin__.property(_get_scale_out_threshold, _set_scale_out_threshold)
    scale_out_relational_operation = __builtin__.property(_get_scale_out_relational_operation,
                                                          _set_scale_out_relational_operation)
    vnf_monitoring_param_ref = __builtin__.property(_get_vnf_monitoring_param_ref, _set_vnf_monitoring_param_ref)

    _pyangbind_elements = OrderedDict([('name', name), ('scale_in_threshold', scale_in_threshold),
                                       ('scale_in_relational_operation', scale_in_relational_operation),
                                       ('scale_out_threshold', scale_out_threshold),
                                       ('scale_out_relational_operation', scale_out_relational_operation),
                                       ('vnf_monitoring_param_ref', vnf_monitoring_param_ref), ])


class yc_scaling_policy_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/scaling-policy. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__scaling_type', '__enabled', '__scale_in_operation_type',
                 '__scale_out_operation_type', '__threshold_time', '__cooldown_time', '__scaling_criteria',)

    _yang_name = 'scaling-policy'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                   defining_module='scaling', yang_type='string', is_config=True)
        self.__scaling_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'manual': {'value': 1}, 'automatic': {'value': 2}}, ),
            is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='common:scaling-policy-type', is_config=True)
        self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled",
                                      parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                      register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                      defining_module='scaling', yang_type='boolean', is_config=True)
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
            default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:scaling-criteria-operation', is_config=True)
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
            default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:scaling-criteria-operation', is_config=True)
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='uint32', is_config=True)
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='uint32', is_config=True)
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name",
                                                                 yc_scaling_criteria_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy_scaling_criteria,
                                                                 yang_name="scaling-criteria", parent=self,
                                                                 is_container='list', user_ordered=False,
                                                                 path_helper=self._path_helper, yang_keys='name',
                                                                 extensions=None), is_container='list',
                                               yang_name="scaling-criteria", parent=self, path_helper=self._path_helper,
                                               extmethods=self._extmethods, register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:scaling',
                                               defining_module='scaling', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'scaling-policy']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/name (string)

    YANG Description: Name of the scaling policy
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the scaling policy
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                   defining_module='scaling', yang_type='string', is_config=True)

    def _get_scaling_type(self):
        """
    Getter method for scaling_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_type (common:scaling-policy-type)

    YANG Description: Type of scaling
    """
        return self.__scaling_type

    def _set_scaling_type(self, v, load=False):
        """
    Setter method for scaling_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_type (common:scaling-policy-type)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_type() directly.

    YANG Description: Type of scaling
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'manual': {'value': 1},
                                                                          'automatic': {'value': 2}}, ), is_leaf=True,
                             yang_name="scaling-type", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='common:scaling-policy-type', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_type must be of a type compatible with common:scaling-policy-type""",
                'defined-type': "common:scaling-policy-type",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'manual': {'value': 1}, 'automatic': {'value': 2}},), is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:scaling-policy-type', is_config=True)""",
            })

        self.__scaling_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_type(self):
        self.__scaling_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'manual': {'value': 1}, 'automatic': {'value': 2}}, ),
            is_leaf=True, yang_name="scaling-type", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='common:scaling-policy-type', is_config=True)

    def _get_enabled(self):
        """
    Getter method for enabled, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/enabled (boolean)

    YANG Description: Specifies if the scaling policy can be applied
    """
        return self.__enabled

    def _set_enabled(self, v, load=False):
        """
    Setter method for enabled, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_enabled() directly.

    YANG Description: Specifies if the scaling policy can be applied
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='boolean', is_config=True)""",
            })

        self.__enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_enabled(self):
        self.__enabled = YANGDynClass(base=YANGBool, default=YANGBool("true"), is_leaf=True, yang_name="enabled",
                                      parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                      register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                                      defining_module='scaling', yang_type='boolean', is_config=True)

    def _get_scale_in_operation_type(self):
        """
    Getter method for scale_in_operation_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scale_in_operation_type (common:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        return self.__scale_in_operation_type

    def _set_scale_in_operation_type(self, v, load=False):
        """
    Setter method for scale_in_operation_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scale_in_operation_type (common:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_in_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_in_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale in threshold condition has been met.
Defaults to AND
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
                             default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='common:scaling-criteria-operation', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_in_operation_type must be of a type compatible with common:scaling-criteria-operation""",
                'defined-type': "common:scaling-criteria-operation",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}},), default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:scaling-criteria-operation', is_config=True)""",
            })

        self.__scale_in_operation_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_in_operation_type(self):
        self.__scale_in_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
            default=six.text_type("AND"), is_leaf=True, yang_name="scale-in-operation-type", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:scaling-criteria-operation', is_config=True)

    def _get_scale_out_operation_type(self):
        """
    Getter method for scale_out_operation_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scale_out_operation_type (common:scaling-criteria-operation)

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        return self.__scale_out_operation_type

    def _set_scale_out_operation_type(self, v, load=False):
        """
    Setter method for scale_out_operation_type, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scale_out_operation_type (common:scaling-criteria-operation)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scale_out_operation_type is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scale_out_operation_type() directly.

    YANG Description: Operation to be applied to check between scaling criterias to
check if the scale out threshold condition has been met.
Defauls to OR
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
                             default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='common:scaling-criteria-operation', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scale_out_operation_type must be of a type compatible with common:scaling-criteria-operation""",
                'defined-type': "common:scaling-criteria-operation",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}},), default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:scaling-criteria-operation', is_config=True)""",
            })

        self.__scale_out_operation_type = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scale_out_operation_type(self):
        self.__scale_out_operation_type = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'AND': {'value': 1}, 'OR': {'value': 2}}, ),
            default=six.text_type("OR"), is_leaf=True, yang_name="scale-out-operation-type", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
            yang_type='common:scaling-criteria-operation', is_config=True)

    def _get_threshold_time(self):
        """
    Getter method for threshold_time, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/threshold_time (uint32)

    YANG Description: The duration for which the criteria must hold true
    """
        return self.__threshold_time

    def _set_threshold_time(self, v, load=False):
        """
    Setter method for threshold_time, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/threshold_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_threshold_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_threshold_time() directly.

    YANG Description: The duration for which the criteria must hold true
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="threshold-time",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """threshold_time must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='uint32', is_config=True)""",
            })

        self.__threshold_time = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_threshold_time(self):
        self.__threshold_time = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="threshold-time", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='uint32', is_config=True)

    def _get_cooldown_time(self):
        """
    Getter method for cooldown_time, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/cooldown_time (uint32)

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        return self.__cooldown_time

    def _set_cooldown_time(self, v, load=False):
        """
    Setter method for cooldown_time, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/cooldown_time (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cooldown_time is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cooldown_time() directly.

    YANG Description: The duration after a scaling-in/scaling-out action has been
triggered, for which there will be no further optional
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                                         int_size=32), is_leaf=True, yang_name="cooldown-time",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cooldown_time must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='uint32', is_config=True)""",
            })

        self.__cooldown_time = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cooldown_time(self):
        self.__cooldown_time = YANGDynClass(
            base=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            is_leaf=True, yang_name="cooldown-time", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='uint32', is_config=True)

    def _get_scaling_criteria(self):
        """
    Getter method for scaling_criteria, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria (list)

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        return self.__scaling_criteria

    def _set_scaling_criteria(self, v, load=False):
        """
    Setter method for scaling_criteria, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy/scaling_criteria (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_criteria is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_criteria() directly.

    YANG Description: list of conditions to be met for generating scaling
  requests
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_scaling_criteria_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy_scaling_criteria,
                                                  yang_name="scaling-criteria", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="scaling-criteria",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_criteria must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_criteria_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy_scaling_criteria, yang_name="scaling-criteria", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-criteria", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='list', is_config=True)""",
            })

        self.__scaling_criteria = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_criteria(self):
        self.__scaling_criteria = YANGDynClass(base=YANGListType("name",
                                                                 yc_scaling_criteria_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy_scaling_criteria,
                                                                 yang_name="scaling-criteria", parent=self,
                                                                 is_container='list', user_ordered=False,
                                                                 path_helper=self._path_helper, yang_keys='name',
                                                                 extensions=None), is_container='list',
                                               yang_name="scaling-criteria", parent=self, path_helper=self._path_helper,
                                               extmethods=self._extmethods, register_paths=True, extensions=None,
                                               namespace='urn:etsi:osm:yang:augments:scaling',
                                               defining_module='scaling', yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    scaling_type = __builtin__.property(_get_scaling_type, _set_scaling_type)
    enabled = __builtin__.property(_get_enabled, _set_enabled)
    scale_in_operation_type = __builtin__.property(_get_scale_in_operation_type, _set_scale_in_operation_type)
    scale_out_operation_type = __builtin__.property(_get_scale_out_operation_type, _set_scale_out_operation_type)
    threshold_time = __builtin__.property(_get_threshold_time, _set_threshold_time)
    cooldown_time = __builtin__.property(_get_cooldown_time, _set_cooldown_time)
    scaling_criteria = __builtin__.property(_get_scaling_criteria, _set_scaling_criteria)

    _pyangbind_elements = OrderedDict([('name', name), ('scaling_type', scaling_type), ('enabled', enabled),
                                       ('scale_in_operation_type', scale_in_operation_type),
                                       ('scale_out_operation_type', scale_out_operation_type),
                                       ('threshold_time', threshold_time), ('cooldown_time', cooldown_time),
                                       ('scaling_criteria', scaling_criteria), ])


class yc_scaling_config_action_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_config_action(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect/scaling-config-action. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of scaling config actions
  """
    __slots__ = ('_path_helper', '_extmethods', '__trigger', '__vnf_config_primitive_name_ref',)

    _yang_name = 'scaling-config-action'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                               restriction_arg={'pre-scale-in': {'value': 1},
                                                                                'post-scale-in': {'value': 2},
                                                                                'pre-scale-out': {'value': 3},
                                                                                'post-scale-out': {'value': 4}}, ),
                                      is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                      namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                                      yang_type='common:scaling-trigger', is_config=True)
        self.__vnf_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="vnf-config-primitive-name-ref", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:scaling',
                                                            defining_module='scaling', yang_type='leafref',
                                                            is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect', 'scaling-config-action']

    def _get_trigger(self):
        """
    Getter method for trigger, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action/trigger (common:scaling-trigger)

    YANG Description: scaling trigger
    """
        return self.__trigger

    def _set_trigger(self, v, load=False):
        """
    Setter method for trigger, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action/trigger (common:scaling-trigger)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_trigger is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_trigger() directly.

    YANG Description: scaling trigger
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'pre-scale-in': {'value': 1},
                                                                          'post-scale-in': {'value': 2},
                                                                          'pre-scale-out': {'value': 3},
                                                                          'post-scale-out': {'value': 4}}, ),
                             is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, is_keyval=True,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='common:scaling-trigger', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """trigger must be of a type compatible with common:scaling-trigger""",
                'defined-type': "common:scaling-trigger",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'pre-scale-in': {'value': 1}, 'post-scale-in': {'value': 2}, 'pre-scale-out': {'value': 3}, 'post-scale-out': {'value': 4}},), is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='common:scaling-trigger', is_config=True)""",
            })

        self.__trigger = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_trigger(self):
        self.__trigger = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                               restriction_arg={'pre-scale-in': {'value': 1},
                                                                                'post-scale-in': {'value': 2},
                                                                                'pre-scale-out': {'value': 3},
                                                                                'post-scale-out': {'value': 4}}, ),
                                      is_leaf=True, yang_name="trigger", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True, is_keyval=True,
                                      namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                                      yang_type='common:scaling-trigger', is_config=True)

    def _get_vnf_config_primitive_name_ref(self):
        """
    Getter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action/vnf_config_primitive_name_ref (leafref)

    YANG Description: Reference to the VNF config primitive
    """
        return self.__vnf_config_primitive_name_ref

    def _set_vnf_config_primitive_name_ref(self, v, load=False):
        """
    Setter method for vnf_config_primitive_name_ref, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action/vnf_config_primitive_name_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnf_config_primitive_name_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnf_config_primitive_name_ref() directly.

    YANG Description: Reference to the VNF config primitive
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnf_config_primitive_name_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vnf-config-primitive-name-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='leafref', is_config=True)""",
            })

        self.__vnf_config_primitive_name_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnf_config_primitive_name_ref(self):
        self.__vnf_config_primitive_name_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="vnf-config-primitive-name-ref", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:scaling',
                                                            defining_module='scaling', yang_type='leafref',
                                                            is_config=True)

    trigger = __builtin__.property(_get_trigger, _set_trigger)
    vnf_config_primitive_name_ref = __builtin__.property(_get_vnf_config_primitive_name_ref,
                                                         _set_vnf_config_primitive_name_ref)

    _pyangbind_elements = OrderedDict(
        [('trigger', trigger), ('vnf_config_primitive_name_ref', vnf_config_primitive_name_ref), ])


class yc_scaling_aspect_etsi_nfv_vnfd__vnfd_df_scaling_aspect(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df/scaling-aspect. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__name', '__description', '__max_scale_level', '__aspect_delta_details',
        '__scaling_policy', '__scaling_config_action',)

    _yang_name = 'scaling-aspect'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__max_scale_level = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)
        self.__aspect_delta_details = YANGDynClass(
            base=yc_aspect_delta_details_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details,
            is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__scaling_policy = YANGDynClass(
            base=YANGListType("name", yc_scaling_policy_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy,
                              yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='list', is_config=True)
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",
                                                                      yc_scaling_config_action_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_config_action,
                                                                      yang_name="scaling-config-action", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper,
                                                                      yang_keys='trigger', extensions=None),
                                                    is_container='list', yang_name="scaling-config-action", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:osm:yang:augments:scaling',
                                                    defining_module='scaling', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df', 'scaling-aspect']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/id (string)

    YANG Description: Unique identifier of this aspect in the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/scaling_aspect/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this aspect in the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/name (string)

    YANG Description: Human readable name of the aspect.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/df/scaling_aspect/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Human readable name of the aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/df/scaling_aspect/description (string)

    YANG Description: Human readable description of the aspect.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/df/scaling_aspect/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the aspect.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_max_scale_level(self):
        """
    Getter method for max_scale_level, mapped from YANG variable /vnfd/df/scaling_aspect/max_scale_level (uint32)

    YANG Description: The maximum scaleLevel for total number of scaling
steps that can be applied w.r.t. this aspect. The
value of this attribute corresponds to the number of
scaling steps can be applied to this aspect when
scaling it from the minimum scale level (i.e. 0) to the
maximum scale level defined by this attribute.
    """
        return self.__max_scale_level

    def _set_max_scale_level(self, v, load=False):
        """
    Setter method for max_scale_level, mapped from YANG variable /vnfd/df/scaling_aspect/max_scale_level (uint32)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_max_scale_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_max_scale_level() directly.

    YANG Description: The maximum scaleLevel for total number of scaling
steps that can be applied w.r.t. this aspect. The
value of this attribute corresponds to the number of
scaling steps can be applied to this aspect when
scaling it from the minimum scale level (i.e. 0) to the
maximum scale level defined by this attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(
                base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']},
                                              int_size=32), restriction_dict={'range': ['1..max']}), is_leaf=True,
                             yang_name="max-scale-level", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='uint32', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """max_scale_level must be of a type compatible with uint32""",
                'defined-type': "uint32",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32), restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)""",
            })

        self.__max_scale_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_max_scale_level(self):
        self.__max_scale_level = YANGDynClass(base=RestrictedClassType(
            base_type=RestrictedClassType(base_type=long, restriction_dict={'range': ['0..4294967295']}, int_size=32),
            restriction_dict={'range': ['1..max']}), is_leaf=True, yang_name="max-scale-level", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='uint32', is_config=True)

    def _get_aspect_delta_details(self):
        """
    Getter method for aspect_delta_details, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details (container)

    YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
    """
        return self.__aspect_delta_details

    def _set_aspect_delta_details(self, v, load=False):
        """
    Setter method for aspect_delta_details, mapped from YANG variable /vnfd/df/scaling_aspect/aspect_delta_details (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_aspect_delta_details is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_aspect_delta_details() directly.

    YANG Description: A specification of the deltas in terms of number of
instances of VNFCs and virtual link bit rates that
correspond to the scaling steps of this aspect. A
cardinality of zero indicates that this mapping has to
be specified in a lifecycle management script or be
otherwise known to the VNFM. The information in this
attribute, if provided, shall be consistent with the
information provided in the 'InstantiationLevel'
information element. If this attribute is provided, it
shall be provided for all scaling aspects.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_aspect_delta_details_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details,
                             is_container='container', yang_name="aspect-delta-details", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """aspect_delta_details must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_aspect_delta_details_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details, is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__aspect_delta_details = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_aspect_delta_details(self):
        self.__aspect_delta_details = YANGDynClass(
            base=yc_aspect_delta_details_etsi_nfv_vnfd__vnfd_df_scaling_aspect_aspect_delta_details,
            is_container='container', yang_name="aspect-delta-details", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_scaling_policy(self):
        """
    Getter method for scaling_policy, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy (list)
    """
        return self.__scaling_policy

    def _set_scaling_policy(self, v, load=False):
        """
    Setter method for scaling_policy, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_policy (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_policy is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_policy() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_scaling_policy_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy,
                                                  yang_name="scaling-policy", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                                                  extensions=None), is_container='list', yang_name="scaling-policy",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling',
                             defining_module='scaling', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_policy must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_scaling_policy_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy, yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='list', is_config=True)""",
            })

        self.__scaling_policy = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_policy(self):
        self.__scaling_policy = YANGDynClass(
            base=YANGListType("name", yc_scaling_policy_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_policy,
                              yang_name="scaling-policy", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list',
            yang_name="scaling-policy", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling',
            defining_module='scaling', yang_type='list', is_config=True)

    def _get_scaling_config_action(self):
        """
    Getter method for scaling_config_action, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action (list)

    YANG Description: List of scaling config actions
    """
        return self.__scaling_config_action

    def _set_scaling_config_action(self, v, load=False):
        """
    Setter method for scaling_config_action, mapped from YANG variable /vnfd/df/scaling_aspect/scaling_config_action (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_config_action is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_config_action() directly.

    YANG Description: List of scaling config actions
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("trigger",
                                                  yc_scaling_config_action_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_config_action,
                                                  yang_name="scaling-config-action", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='trigger', extensions=None), is_container='list',
                             yang_name="scaling-config-action", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_config_action must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("trigger",yc_scaling_config_action_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_config_action, yang_name="scaling-config-action", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='trigger', extensions=None), is_container='list', yang_name="scaling-config-action", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:scaling', defining_module='scaling', yang_type='list', is_config=True)""",
            })

        self.__scaling_config_action = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_config_action(self):
        self.__scaling_config_action = YANGDynClass(base=YANGListType("trigger",
                                                                      yc_scaling_config_action_etsi_nfv_vnfd__vnfd_df_scaling_aspect_scaling_config_action,
                                                                      yang_name="scaling-config-action", parent=self,
                                                                      is_container='list', user_ordered=False,
                                                                      path_helper=self._path_helper,
                                                                      yang_keys='trigger', extensions=None),
                                                    is_container='list', yang_name="scaling-config-action", parent=self,
                                                    path_helper=self._path_helper, extmethods=self._extmethods,
                                                    register_paths=True, extensions=None,
                                                    namespace='urn:etsi:osm:yang:augments:scaling',
                                                    defining_module='scaling', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    max_scale_level = __builtin__.property(_get_max_scale_level, _set_max_scale_level)
    aspect_delta_details = __builtin__.property(_get_aspect_delta_details, _set_aspect_delta_details)
    scaling_policy = __builtin__.property(_get_scaling_policy, _set_scaling_policy)
    scaling_config_action = __builtin__.property(_get_scaling_config_action, _set_scaling_config_action)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('description', description), ('max_scale_level', max_scale_level),
         ('aspect_delta_details', aspect_delta_details), ('scaling_policy', scaling_policy),
         ('scaling_config_action', scaling_config_action), ])


class yc_df_etsi_nfv_vnfd__vnfd_df(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/df. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu_profile', '__virtual_link_profile',
                 '__instantiation_level', '__default_instantiation_level', '__supported_operation',
                 '__lcm_operations_configuration', '__affinity_or_anti_affinity_group', '__indicator',
                 '__supported_vnf_interfaces', '__monitoring_parameter', '__scaling_aspect',)

    _yang_name = 'df'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__vdu_profile = YANGDynClass(
            base=YANGListType("id", yc_vdu_profile_etsi_nfv_vnfd__vnfd_df_vdu_profile, yang_name="vdu-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id flavour", yc_virtual_link_profile_etsi_nfv_vnfd__vnfd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id flavour', extensions=None),
            is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_instantiation_level_etsi_nfv_vnfd__vnfd_df_instantiation_level,
                              yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                          defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                          is_config=True)
        self.__supported_operation = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'query-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                                  is_leaf=False, yang_name="supported-operation", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                  defining_module='etsi-nfv-vnfd', yang_type='identityref',
                                                  is_config=True)
        self.__lcm_operations_configuration = YANGDynClass(
            base=yc_lcm_operations_configuration_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration,
            is_container='container', yang_name="lcm-operations-configuration", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_df_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__supported_vnf_interfaces = YANGDynClass(
            base=YANGListType("name", yc_supported_vnf_interfaces_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces,
                              yang_name="supported-vnf-interfaces", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_df_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_vnfd__vnfd_df_scaling_aspect, yang_name="scaling-aspect",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="scaling-aspect",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'df']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/df/id (string)

    YANG Description: Identifier of this DF within the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/df/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this DF within the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/df/description (string)

    YANG Description: Human readable description of the deployment flavour
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/df/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the deployment flavour
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_vdu_profile(self):
        """
    Getter method for vdu_profile, mapped from YANG variable /vnfd/df/vdu_profile (list)

    YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
    """
        return self.__vdu_profile

    def _set_vdu_profile(self, v, load=False):
        """
    Setter method for vdu_profile, mapped from YANG variable /vnfd/df/vdu_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_profile() directly.

    YANG Description: The Vduprofile describes additional instantiation data for
a given VDU used in a deployment flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vdu_profile_etsi_nfv_vnfd__vnfd_df_vdu_profile,
                                                  yang_name="vdu-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="vdu-profile",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_profile_etsi_nfv_vnfd__vnfd_df_vdu_profile, yang_name="vdu-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_profile(self):
        self.__vdu_profile = YANGDynClass(
            base=YANGListType("id", yc_vdu_profile_etsi_nfv_vnfd__vnfd_df_vdu_profile, yang_name="vdu-profile",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="vdu-profile",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

    def _get_virtual_link_profile(self):
        """
    Getter method for virtual_link_profile, mapped from YANG variable /vnfd/df/virtual_link_profile (list)

    YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
    """
        return self.__virtual_link_profile

    def _set_virtual_link_profile(self, v, load=False):
        """
    Setter method for virtual_link_profile, mapped from YANG variable /vnfd/df/virtual_link_profile (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_profile is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_profile() directly.

    YANG Description: Defines the internal VLD along with additional data which
is used in this DF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id flavour",
                                                  yc_virtual_link_profile_etsi_nfv_vnfd__vnfd_df_virtual_link_profile,
                                                  yang_name="virtual-link-profile", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='id flavour', extensions=None), is_container='list',
                             yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_profile must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id flavour",yc_virtual_link_profile_etsi_nfv_vnfd__vnfd_df_virtual_link_profile, yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id flavour', extensions=None), is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_link_profile = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_profile(self):
        self.__virtual_link_profile = YANGDynClass(
            base=YANGListType("id flavour", yc_virtual_link_profile_etsi_nfv_vnfd__vnfd_df_virtual_link_profile,
                              yang_name="virtual-link-profile", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id flavour', extensions=None),
            is_container='list', yang_name="virtual-link-profile", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_instantiation_level(self):
        """
    Getter method for instantiation_level, mapped from YANG variable /vnfd/df/instantiation_level (list)

    YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
    """
        return self.__instantiation_level

    def _set_instantiation_level(self, v, load=False):
        """
    Setter method for instantiation_level, mapped from YANG variable /vnfd/df/instantiation_level (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_instantiation_level() directly.

    YANG Description: Describes the various levels of resources that can be
used to instantiate the VNF using this flavour.
Examples: Small, Medium, Large. If there is only one
'instantiationLevel' entry, it shall be treated as the
default instantiation level for this DF.

The InstantiationLevel information element describes a
given level of resources to be instantiated within a
deployment flavour in term of the number of VNFC instances
to be created from each VDU.
All the VDUs referenced in the level shall be part of the
corresponding deployment flavour and their number shall
be within the range (min/max) for this deployment flavour.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_instantiation_level_etsi_nfv_vnfd__vnfd_df_instantiation_level,
                                               yang_name="instantiation-level", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="instantiation-level",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """instantiation_level must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_instantiation_level_etsi_nfv_vnfd__vnfd_df_instantiation_level, yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_instantiation_level(self):
        self.__instantiation_level = YANGDynClass(
            base=YANGListType("id", yc_instantiation_level_etsi_nfv_vnfd__vnfd_df_instantiation_level,
                              yang_name="instantiation-level", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_default_instantiation_level(self):
        """
    Getter method for default_instantiation_level, mapped from YANG variable /vnfd/df/default_instantiation_level (leafref)

    YANG Description: This attribute references the 'instantiationLevel'
entry which defines the default instantiation level for
this DF. It shall be present if there are multiple
'instantiationLevel' entries.
    """
        return self.__default_instantiation_level

    def _set_default_instantiation_level(self, v, load=False):
        """
    Setter method for default_instantiation_level, mapped from YANG variable /vnfd/df/default_instantiation_level (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_instantiation_level is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_instantiation_level() directly.

    YANG Description: This attribute references the 'instantiationLevel'
entry which defines the default instantiation level for
this DF. It shall be present if there are multiple
'instantiationLevel' entries.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_instantiation_level must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-instantiation-level", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__default_instantiation_level = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_instantiation_level(self):
        self.__default_instantiation_level = YANGDynClass(base=six.text_type, is_leaf=True,
                                                          yang_name="default-instantiation-level", parent=self,
                                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                                          register_paths=True,
                                                          namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                          defining_module='etsi-nfv-vnfd', yang_type='leafref',
                                                          is_config=True)

    def _get_supported_operation(self):
        """
    Getter method for supported_operation, mapped from YANG variable /vnfd/df/supported_operation (identityref)

    YANG Description: Indicates which operations are available for this DF via
the VNF LCM interface. Instantiate VNF, Query VNF and
Terminate VNF are supported in all DF and therefore
need not be included in this list.
    """
        return self.__supported_operation

    def _set_supported_operation(self, v, load=False):
        """
    Setter method for supported_operation, mapped from YANG variable /vnfd/df/supported_operation (identityref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_operation is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_operation() directly.

    YANG Description: Indicates which operations are available for this DF via
the VNF LCM interface. Instantiate VNF, Query VNF and
Terminate VNF are supported in all DF and therefore
need not be included in this list.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                    'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                            '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                          '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                     '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                    'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                                   '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                             is_leaf=False, yang_name="supported-operation", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='identityref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_operation must be of a type compatible with identityref""",
                'defined-type': "etsi-nfv-vnfd:identityref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={'instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}, 'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}},)), is_leaf=False, yang_name="supported-operation", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='identityref', is_config=True)""",
            })

        self.__supported_operation = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_operation(self):
        self.__supported_operation = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key", restriction_arg={
                'instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:instantiate-vnf': {'@module': 'etsi-nfv-descriptors',
                                        '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:scale-vnf-to-level': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                       '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:change-vnf-flavour': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:terminate-vnf': {'@module': 'etsi-nfv-descriptors',
                                      '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'query-vnf': {'@module': 'etsi-nfv-descriptors',
                              '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:query-vnf': {'@module': 'etsi-nfv-descriptors',
                                  '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'heal-vnf': {'@module': 'etsi-nfv-descriptors', '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:heal-vnf': {'@module': 'etsi-nfv-descriptors',
                                 '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:operate-vnf': {'@module': 'etsi-nfv-descriptors',
                                    '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                           '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'nfv:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'},
                'vnf:modify-vnf-information': {'@module': 'etsi-nfv-descriptors',
                                               '@namespace': 'urn:etsi:nfv:yang:etsi-nfv-descriptors'}}, )),
                                                  is_leaf=False, yang_name="supported-operation", parent=self,
                                                  path_helper=self._path_helper, extmethods=self._extmethods,
                                                  register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                  defining_module='etsi-nfv-vnfd', yang_type='identityref',
                                                  is_config=True)

    def _get_lcm_operations_configuration(self):
        """
    Getter method for lcm_operations_configuration, mapped from YANG variable /vnfd/df/lcm_operations_configuration (container)

    YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
    """
        return self.__lcm_operations_configuration

    def _set_lcm_operations_configuration(self, v, load=False):
        """
    Setter method for lcm_operations_configuration, mapped from YANG variable /vnfd/df/lcm_operations_configuration (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lcm_operations_configuration is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lcm_operations_configuration() directly.

    YANG Description: This information element is a container for all
attributes that affect the invocation of the VNF
Lifecycle Management operations, structured by
operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=yc_lcm_operations_configuration_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration,
                             is_container='container', yang_name="lcm-operations-configuration", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lcm_operations_configuration must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_lcm_operations_configuration_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration, is_container='container', yang_name="lcm-operations-configuration", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__lcm_operations_configuration = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lcm_operations_configuration(self):
        self.__lcm_operations_configuration = YANGDynClass(
            base=yc_lcm_operations_configuration_etsi_nfv_vnfd__vnfd_df_lcm_operations_configuration,
            is_container='container', yang_name="lcm-operations-configuration", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_affinity_or_anti_affinity_group(self):
        """
    Getter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group (list)

    YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
    """
        return self.__affinity_or_anti_affinity_group

    def _set_affinity_or_anti_affinity_group(self, v, load=False):
        """
    Setter method for affinity_or_anti_affinity_group, mapped from YANG variable /vnfd/df/affinity_or_anti_affinity_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_affinity_or_anti_affinity_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_affinity_or_anti_affinity_group() directly.

    YANG Description: The AffinityOrAntiAffinityGroup describes the affinity
or anti-affinity relationship applicable between the
virtualization containers to be created based on
different VDUs, or between internal VLs to be created
based on different VnfVirtualLinkDesc(s).

Per VNF, the affinity/anti-affinity rules defined using
this information element, using the
LocalAffinityOrAntiAffinityRule information element, and
using the placement constraints in the
GrantLifecycleOperation as defined in ETSI GS NFV-IFA
007 [i.3] should be conflict-free. In case of conflicts,
the placement constraints in the
GrantLifecycleOperation shall take precedence.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_affinity_or_anti_affinity_group,
                                                  yang_name="affinity-or-anti-affinity-group", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """affinity_or_anti_affinity_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_affinity_or_anti_affinity_group, yang_name="affinity-or-anti-affinity-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="affinity-or-anti-affinity-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__affinity_or_anti_affinity_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_affinity_or_anti_affinity_group(self):
        self.__affinity_or_anti_affinity_group = YANGDynClass(base=YANGListType("id",
                                                                                yc_affinity_or_anti_affinity_group_etsi_nfv_vnfd__vnfd_df_affinity_or_anti_affinity_group,
                                                                                yang_name="affinity-or-anti-affinity-group",
                                                                                parent=self, is_container='list',
                                                                                user_ordered=False,
                                                                                path_helper=self._path_helper,
                                                                                yang_keys='id', extensions=None),
                                                              is_container='list',
                                                              yang_name="affinity-or-anti-affinity-group", parent=self,
                                                              path_helper=self._path_helper,
                                                              extmethods=self._extmethods, register_paths=True,
                                                              extensions=None,
                                                              namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                              defining_module='etsi-nfv-vnfd', yang_type='list',
                                                              is_config=True)

    def _get_indicator(self):
        """
    Getter method for indicator, mapped from YANG variable /vnfd/df/indicator (list)

    YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
    """
        return self.__indicator

    def _set_indicator(self, v, load=False):
        """
    Setter method for indicator, mapped from YANG variable /vnfd/df/indicator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator() directly.

    YANG Description: Declares the VNF indicators that are supported by this
VNF (specific to this DF).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_df_indicator,
                                                  yang_name="indicator", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="indicator",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_indicator_etsi_nfv_vnfd__vnfd_df_indicator, yang_name="indicator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__indicator = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator(self):
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_df_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_supported_vnf_interfaces(self):
        """
    Getter method for supported_vnf_interfaces, mapped from YANG variable /vnfd/df/supported_vnf_interfaces (list)

    YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
    """
        return self.__supported_vnf_interfaces

    def _set_supported_vnf_interfaces(self, v, load=False):
        """
    Setter method for supported_vnf_interfaces, mapped from YANG variable /vnfd/df/supported_vnf_interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_supported_vnf_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_supported_vnf_interfaces() directly.

    YANG Description: Indicates which interfaces the VNF produces and provides
additional details on how to access the interface
endpoints.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name",
                                                  yc_supported_vnf_interfaces_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces,
                                                  yang_name="supported-vnf-interfaces", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="supported-vnf-interfaces", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """supported_vnf_interfaces must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_supported_vnf_interfaces_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces, yang_name="supported-vnf-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__supported_vnf_interfaces = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_supported_vnf_interfaces(self):
        self.__supported_vnf_interfaces = YANGDynClass(
            base=YANGListType("name", yc_supported_vnf_interfaces_etsi_nfv_vnfd__vnfd_df_supported_vnf_interfaces,
                              yang_name="supported-vnf-interfaces", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="supported-vnf-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_monitoring_parameter(self):
        """
    Getter method for monitoring_parameter, mapped from YANG variable /vnfd/df/monitoring_parameter (list)

    YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
    """
        return self.__monitoring_parameter

    def _set_monitoring_parameter(self, v, load=False):
        """
    Setter method for monitoring_parameter, mapped from YANG variable /vnfd/df/monitoring_parameter (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_monitoring_parameter is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_monitoring_parameter() directly.

    YANG Description: Defines the virtualised resources monitoring parameters
on VNF level.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_df_monitoring_parameter,
                                                  yang_name="monitoring-parameter", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """monitoring_parameter must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_df_monitoring_parameter, yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__monitoring_parameter = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_monitoring_parameter(self):
        self.__monitoring_parameter = YANGDynClass(
            base=YANGListType("id", yc_monitoring_parameter_etsi_nfv_vnfd__vnfd_df_monitoring_parameter,
                              yang_name="monitoring-parameter", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="monitoring-parameter", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_scaling_aspect(self):
        """
    Getter method for scaling_aspect, mapped from YANG variable /vnfd/df/scaling_aspect (list)

    YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
    """
        return self.__scaling_aspect

    def _set_scaling_aspect(self, v, load=False):
        """
    Setter method for scaling_aspect, mapped from YANG variable /vnfd/df/scaling_aspect (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_scaling_aspect is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_scaling_aspect() directly.

    YANG Description: The scaling aspects supported by this DF of the VNF.
scalingAspect shall be present if the VNF supports
scaling.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_scaling_aspect_etsi_nfv_vnfd__vnfd_df_scaling_aspect,
                                                  yang_name="scaling-aspect", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="scaling-aspect",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """scaling_aspect must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_scaling_aspect_etsi_nfv_vnfd__vnfd_df_scaling_aspect, yang_name="scaling-aspect", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="scaling-aspect", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__scaling_aspect = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_scaling_aspect(self):
        self.__scaling_aspect = YANGDynClass(
            base=YANGListType("id", yc_scaling_aspect_etsi_nfv_vnfd__vnfd_df_scaling_aspect, yang_name="scaling-aspect",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="scaling-aspect",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu_profile = __builtin__.property(_get_vdu_profile, _set_vdu_profile)
    virtual_link_profile = __builtin__.property(_get_virtual_link_profile, _set_virtual_link_profile)
    instantiation_level = __builtin__.property(_get_instantiation_level, _set_instantiation_level)
    default_instantiation_level = __builtin__.property(_get_default_instantiation_level,
                                                       _set_default_instantiation_level)
    supported_operation = __builtin__.property(_get_supported_operation, _set_supported_operation)
    lcm_operations_configuration = __builtin__.property(_get_lcm_operations_configuration,
                                                        _set_lcm_operations_configuration)
    affinity_or_anti_affinity_group = __builtin__.property(_get_affinity_or_anti_affinity_group,
                                                           _set_affinity_or_anti_affinity_group)
    indicator = __builtin__.property(_get_indicator, _set_indicator)
    supported_vnf_interfaces = __builtin__.property(_get_supported_vnf_interfaces, _set_supported_vnf_interfaces)
    monitoring_parameter = __builtin__.property(_get_monitoring_parameter, _set_monitoring_parameter)
    scaling_aspect = __builtin__.property(_get_scaling_aspect, _set_scaling_aspect)

    _pyangbind_elements = OrderedDict([('id', id), ('description', description), ('vdu_profile', vdu_profile),
                                       ('virtual_link_profile', virtual_link_profile),
                                       ('instantiation_level', instantiation_level),
                                       ('default_instantiation_level', default_instantiation_level),
                                       ('supported_operation', supported_operation),
                                       ('lcm_operations_configuration', lcm_operations_configuration),
                                       ('affinity_or_anti_affinity_group', affinity_or_anti_affinity_group),
                                       ('indicator', indicator), ('supported_vnf_interfaces', supported_vnf_interfaces),
                                       ('monitoring_parameter', monitoring_parameter),
                                       ('scaling_aspect', scaling_aspect), ])


class yc_additional_configurable_property_etsi_nfv_vnfd__vnfd_configurable_properties_additional_configurable_property(
    PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/configurable-properties/additional-configurable-property. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'additional-configurable-property'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'configurable-properties', 'additional-configurable-property']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property/key (string)
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_configurable_properties_etsi_nfv_vnfd__vnfd_configurable_properties(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/configurable-properties. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
  """
    __slots__ = ('_path_helper', '_extmethods', '__is_auto_scalable_enabled', '__is_auto_heal_enabled',
                 '__additional_configurable_property',)

    _yang_name = 'configurable-properties'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__is_auto_scalable_enabled = YANGDynClass(base=YANGBool, is_leaf=True,
                                                       yang_name="is-auto-scalable-enabled", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                       is_config=True)
        self.__is_auto_heal_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)
        self.__additional_configurable_property = YANGDynClass(base=YANGListType("key",
                                                                                 yc_additional_configurable_property_etsi_nfv_vnfd__vnfd_configurable_properties_additional_configurable_property,
                                                                                 yang_name="additional-configurable-property",
                                                                                 parent=self, is_container='list',
                                                                                 user_ordered=False,
                                                                                 path_helper=self._path_helper,
                                                                                 yang_keys='key', extensions=None),
                                                               is_container='list',
                                                               yang_name="additional-configurable-property",
                                                               parent=self, path_helper=self._path_helper,
                                                               extmethods=self._extmethods, register_paths=True,
                                                               extensions=None,
                                                               namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                               defining_module='etsi-nfv-vnfd', yang_type='list',
                                                               is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'configurable-properties']

    def _get_is_auto_scalable_enabled(self):
        """
    Getter method for is_auto_scalable_enabled, mapped from YANG variable /vnfd/configurable_properties/is_auto_scalable_enabled (boolean)

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-scaling functionality.
    """
        return self.__is_auto_scalable_enabled

    def _set_is_auto_scalable_enabled(self, v, load=False):
        """
    Setter method for is_auto_scalable_enabled, mapped from YANG variable /vnfd/configurable_properties/is_auto_scalable_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_auto_scalable_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_auto_scalable_enabled() directly.

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-scaling functionality.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="is-auto-scalable-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """is_auto_scalable_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-scalable-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__is_auto_scalable_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_is_auto_scalable_enabled(self):
        self.__is_auto_scalable_enabled = YANGDynClass(base=YANGBool, is_leaf=True,
                                                       yang_name="is-auto-scalable-enabled", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='boolean',
                                                       is_config=True)

    def _get_is_auto_heal_enabled(self):
        """
    Getter method for is_auto_heal_enabled, mapped from YANG variable /vnfd/configurable_properties/is_auto_heal_enabled (boolean)

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-healing functionality.
    """
        return self.__is_auto_heal_enabled

    def _set_is_auto_heal_enabled(self, v, load=False):
        """
    Setter method for is_auto_heal_enabled, mapped from YANG variable /vnfd/configurable_properties/is_auto_heal_enabled (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_is_auto_heal_enabled is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_is_auto_heal_enabled() directly.

    YANG Description: It permits to enable (TRUE) / disable (FALSE) the
auto-healing functionality.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """is_auto_heal_enabled must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)""",
            })

        self.__is_auto_heal_enabled = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_is_auto_heal_enabled(self):
        self.__is_auto_heal_enabled = YANGDynClass(base=YANGBool, is_leaf=True, yang_name="is-auto-heal-enabled",
                                                   parent=self, path_helper=self._path_helper,
                                                   extmethods=self._extmethods, register_paths=True,
                                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='boolean', is_config=True)

    def _get_additional_configurable_property(self):
        """
    Getter method for additional_configurable_property, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property (list)

    YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
    """
        return self.__additional_configurable_property

    def _set_additional_configurable_property(self, v, load=False):
        """
    Setter method for additional_configurable_property, mapped from YANG variable /vnfd/configurable_properties/additional_configurable_property (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_additional_configurable_property is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_additional_configurable_property() directly.

    YANG Description: It provides VNF specific configurable properties that can
be modified using the ModifyVnfConfiguration operation.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_additional_configurable_property_etsi_nfv_vnfd__vnfd_configurable_properties_additional_configurable_property,
                                                  yang_name="additional-configurable-property", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='key', extensions=None),
                             is_container='list', yang_name="additional-configurable-property", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """additional_configurable_property must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_additional_configurable_property_etsi_nfv_vnfd__vnfd_configurable_properties_additional_configurable_property, yang_name="additional-configurable-property", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="additional-configurable-property", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__additional_configurable_property = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_additional_configurable_property(self):
        self.__additional_configurable_property = YANGDynClass(base=YANGListType("key",
                                                                                 yc_additional_configurable_property_etsi_nfv_vnfd__vnfd_configurable_properties_additional_configurable_property,
                                                                                 yang_name="additional-configurable-property",
                                                                                 parent=self, is_container='list',
                                                                                 user_ordered=False,
                                                                                 path_helper=self._path_helper,
                                                                                 yang_keys='key', extensions=None),
                                                               is_container='list',
                                                               yang_name="additional-configurable-property",
                                                               parent=self, path_helper=self._path_helper,
                                                               extmethods=self._extmethods, register_paths=True,
                                                               extensions=None,
                                                               namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                               defining_module='etsi-nfv-vnfd', yang_type='list',
                                                               is_config=True)

    is_auto_scalable_enabled = __builtin__.property(_get_is_auto_scalable_enabled, _set_is_auto_scalable_enabled)
    is_auto_heal_enabled = __builtin__.property(_get_is_auto_heal_enabled, _set_is_auto_heal_enabled)
    additional_configurable_property = __builtin__.property(_get_additional_configurable_property,
                                                            _set_additional_configurable_property)

    _pyangbind_elements = OrderedDict(
        [('is_auto_scalable_enabled', is_auto_scalable_enabled), ('is_auto_heal_enabled', is_auto_heal_enabled),
         ('additional_configurable_property', additional_configurable_property), ])


class yc_modifiable_attributes_etsi_nfv_vnfd__vnfd_modifiable_attributes(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/modifiable-attributes. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the modifiable attributes of the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__extension', '__metadata',)

    _yang_name = 'modifiable-attributes'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__extension = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="extension", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)
        self.__metadata = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                       yang_name="metadata", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'modifiable-attributes']

    def _get_extension(self):
        """
    Getter method for extension, mapped from YANG variable /vnfd/modifiable_attributes/extension (string)

    YANG Description: Additional VNF-specific attributes of VnfInfo that
affect the lifecycle management of a VNF instance and
that are writeable.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and
modified through the VNFM.

These attributes are intended to be consumed by the
VNFM or by the lifecycle management scripts during the
execution of VNF lifecycle management operations.

Modifying these values has no direct effect on the VNF
instance; however, modified values can be considered
during subsequent VNF lifecycle management operations,
which means that the modified values can indirectly
affect the configuration of the VNF instance.
    """
        return self.__extension

    def _set_extension(self, v, load=False):
        """
    Setter method for extension, mapped from YANG variable /vnfd/modifiable_attributes/extension (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_extension is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_extension() directly.

    YANG Description: Additional VNF-specific attributes of VnfInfo that
affect the lifecycle management of a VNF instance and
that are writeable.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and
modified through the VNFM.

These attributes are intended to be consumed by the
VNFM or by the lifecycle management scripts during the
execution of VNF lifecycle management operations.

Modifying these values has no direct effect on the VNF
instance; however, modified values can be considered
during subsequent VNF lifecycle management operations,
which means that the modified values can indirectly
affect the configuration of the VNF instance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="extension", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """extension must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="extension", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__extension = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_extension(self):
        self.__extension = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="extension", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)

    def _get_metadata(self):
        """
    Getter method for metadata, mapped from YANG variable /vnfd/modifiable_attributes/metadata (string)

    YANG Description: Additional VNF-specific attributes of VnfInfo that are
writeable and that provide metadata describing the VNF
instance.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and modified
through the VNFM.

These attributes are intended to provide information to
functional blocks external to the VNFM and will not be
used by the VNFM or the VNF lifecycle management
scripts when executing lifecycle management operations.

Modifying these attributes has no effect on the VNF
instance. It only affects the attribute values stored by
the VNFM.
    """
        return self.__metadata

    def _set_metadata(self, v, load=False):
        """
    Setter method for metadata, mapped from YANG variable /vnfd/modifiable_attributes/metadata (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_metadata is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_metadata() directly.

    YANG Description: Additional VNF-specific attributes of VnfInfo that are
writeable and that provide metadata describing the VNF
instance.

For each VNF instance, these attributes are stored
persistently by the VNFM and can be queried and modified
through the VNFM.

These attributes are intended to provide information to
functional blocks external to the VNFM and will not be
used by the VNFM or the VNF lifecycle management
scripts when executing lifecycle management operations.

Modifying these attributes has no effect on the VNF
instance. It only affects the attribute values stored by
the VNFM.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="metadata", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """metadata must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="metadata", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__metadata = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_metadata(self):
        self.__metadata = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                       yang_name="metadata", parent=self, path_helper=self._path_helper,
                                       extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='string', is_config=True)

    extension = __builtin__.property(_get_extension, _set_extension)
    metadata = __builtin__.property(_get_metadata, _set_metadata)

    _pyangbind_elements = OrderedDict([('extension', extension), ('metadata', metadata), ])


class yc_script_input_etsi_nfv_vnfd__vnfd_lifecycle_management_script_script_input(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/lifecycle-management-script/script-input. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
  """
    __slots__ = ('_path_helper', '_extmethods', '__key', '__value',)

    _yang_name = 'script-input'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'lifecycle-management-script', 'script-input']

    def _get_key(self):
        """
    Getter method for key, mapped from YANG variable /vnfd/lifecycle_management_script/script_input/key (string)

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.

The string value specified here is a path to a file in
the VNF package.
    """
        return self.__key

    def _set_key(self, v, load=False):
        """
    Setter method for key, mapped from YANG variable /vnfd/lifecycle_management_script/script_input/key (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_key is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_key() directly.

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.

The string value specified here is a path to a file in
the VNF package.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """key must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__key = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_key(self):
        self.__key = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="key", parent=self,
                                  path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                  is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                  defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_value(self):
        """
    Getter method for value, mapped from YANG variable /vnfd/lifecycle_management_script/script_input/value (string)
    """
        return self.__value

    def _set_value(self, v, load=False):
        """
    Setter method for value, mapped from YANG variable /vnfd/lifecycle_management_script/script_input/value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_value() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_value(self):
        self.__value = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="value", parent=self,
                                    path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='string', is_config=True)

    key = __builtin__.property(_get_key, _set_key)
    value = __builtin__.property(_get_value, _set_value)

    _pyangbind_elements = OrderedDict([('key', key), ('value', value), ])


class yc_lifecycle_management_script_etsi_nfv_vnfd__vnfd_lifecycle_management_script(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/lifecycle-management-script. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__event', '__lcm_transition_event', '__script', '__script_dsl',
                 '__script_input',)

    _yang_name = 'lifecycle-management-script'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__event = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                              'start-scaling': {}, 'end-scaling': {},
                                                              'start-healing': {}, 'end-healing': {},
                                                              'start-termination': {}, 'end-termination': {},
                                                              'start-vnf-flavour-change': {},
                                                              'end-vnf-flavour-change': {},
                                                              'start-vnf-operation-change': {},
                                                              'end-vnf-operation-change': {},
                                                              'start-vnf-ext-conn-change': {},
                                                              'end-vnf-ext-conn-change': {},
                                                              'start-vnfinfo-modification': {},
                                                              'end-vnfinfo-modification': {}}, )), is_leaf=False,
                                    yang_name="event", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='internal-lifecycle-management-script-event', is_config=True)
        self.__lcm_transition_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="lcm-transition-event", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='string', is_config=True)
        self.__script_dsl = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__script_input = YANGDynClass(
            base=YANGListType("key", yc_script_input_etsi_nfv_vnfd__vnfd_lifecycle_management_script_script_input,
                              yang_name="script-input", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'lifecycle-management-script']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/lifecycle_management_script/id (string)

    YANG Description: A unique string that identfies the script in question.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/lifecycle_management_script/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: A unique string that identfies the script in question.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_event(self):
        """
    Getter method for event, mapped from YANG variable /vnfd/lifecycle_management_script/event (internal-lifecycle-management-script-event)

    YANG Description: Describes VNF lifecycle event(s) or an external stimulus
detected on a VNFM reference point.
    """
        return self.__event

    def _set_event(self, v, load=False):
        """
    Setter method for event, mapped from YANG variable /vnfd/lifecycle_management_script/event (internal-lifecycle-management-script-event)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_event() directly.

    YANG Description: Describes VNF lifecycle event(s) or an external stimulus
detected on a VNFM reference point.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                 restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                                  'start-scaling': {}, 'end-scaling': {},
                                                                  'start-healing': {}, 'end-healing': {},
                                                                  'start-termination': {}, 'end-termination': {},
                                                                  'start-vnf-flavour-change': {},
                                                                  'end-vnf-flavour-change': {},
                                                                  'start-vnf-operation-change': {},
                                                                  'end-vnf-operation-change': {},
                                                                  'start-vnf-ext-conn-change': {},
                                                                  'end-vnf-ext-conn-change': {},
                                                                  'start-vnfinfo-modification': {},
                                                                  'end-vnfinfo-modification': {}}, )), is_leaf=False,
                             yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='internal-lifecycle-management-script-event',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """event must be of a type compatible with internal-lifecycle-management-script-event""",
                'defined-type': "etsi-nfv-vnfd:internal-lifecycle-management-script-event",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'start-instantiation': {}, 'end-instantiation': {}, 'start-scaling': {}, 'end-scaling': {}, 'start-healing': {}, 'end-healing': {}, 'start-termination': {}, 'end-termination': {}, 'start-vnf-flavour-change': {}, 'end-vnf-flavour-change': {}, 'start-vnf-operation-change': {}, 'end-vnf-operation-change': {}, 'start-vnf-ext-conn-change': {}, 'end-vnf-ext-conn-change': {}, 'start-vnfinfo-modification': {}, 'end-vnfinfo-modification': {}},)), is_leaf=False, yang_name="event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='internal-lifecycle-management-script-event', is_config=True)""",
            })

        self.__event = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_event(self):
        self.__event = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'start-instantiation': {}, 'end-instantiation': {},
                                                              'start-scaling': {}, 'end-scaling': {},
                                                              'start-healing': {}, 'end-healing': {},
                                                              'start-termination': {}, 'end-termination': {},
                                                              'start-vnf-flavour-change': {},
                                                              'end-vnf-flavour-change': {},
                                                              'start-vnf-operation-change': {},
                                                              'end-vnf-operation-change': {},
                                                              'start-vnf-ext-conn-change': {},
                                                              'end-vnf-ext-conn-change': {},
                                                              'start-vnfinfo-modification': {},
                                                              'end-vnfinfo-modification': {}}, )), is_leaf=False,
                                    yang_name="event", parent=self, path_helper=self._path_helper,
                                    extmethods=self._extmethods, register_paths=True,
                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                    yang_type='internal-lifecycle-management-script-event', is_config=True)

    def _get_lcm_transition_event(self):
        """
    Getter method for lcm_transition_event, mapped from YANG variable /vnfd/lifecycle_management_script/lcm_transition_event (string)

    YANG Description: Describes the transition VNF lifecycle event(s) that
cannot be mapped to any of the enumerated values
defined for the event attribute.
    """
        return self.__lcm_transition_event

    def _set_lcm_transition_event(self, v, load=False):
        """
    Setter method for lcm_transition_event, mapped from YANG variable /vnfd/lifecycle_management_script/lcm_transition_event (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lcm_transition_event is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lcm_transition_event() directly.

    YANG Description: Describes the transition VNF lifecycle event(s) that
cannot be mapped to any of the enumerated values
defined for the event attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="lcm-transition-event", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lcm_transition_event must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="lcm-transition-event", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__lcm_transition_event = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lcm_transition_event(self):
        self.__lcm_transition_event = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                   is_leaf=False, yang_name="lcm-transition-event", parent=self,
                                                   path_helper=self._path_helper, extmethods=self._extmethods,
                                                   register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                   defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_script(self):
        """
    Getter method for script, mapped from YANG variable /vnfd/lifecycle_management_script/script (string)

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.
    """
        return self.__script

    def _set_script(self, v, load=False):
        """
    Setter method for script, mapped from YANG variable /vnfd/lifecycle_management_script/script (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script() directly.

    YANG Description: Includes a VNF LCM script (e.g. written in a DSL as
specified in requirement VNF_PACK.LCM.001) triggered to
react to one of the events listed in the event
attribute.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script(self):
        self.__script = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script", parent=self,
                                     path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='string', is_config=True)

    def _get_script_dsl(self):
        """
    Getter method for script_dsl, mapped from YANG variable /vnfd/lifecycle_management_script/script_dsl (string)

    YANG Description: Defines the domain specific language (i.e. the type) of
script that is provided. Types of scripts could include
bash, python, etc.
    """
        return self.__script_dsl

    def _set_script_dsl(self, v, load=False):
        """
    Setter method for script_dsl, mapped from YANG variable /vnfd/lifecycle_management_script/script_dsl (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_dsl is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_dsl() directly.

    YANG Description: Defines the domain specific language (i.e. the type) of
script that is provided. Types of scripts could include
bash, python, etc.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_dsl must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__script_dsl = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_dsl(self):
        self.__script_dsl = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="script-dsl", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                         defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_script_input(self):
        """
    Getter method for script_input, mapped from YANG variable /vnfd/lifecycle_management_script/script_input (list)

    YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
    """
        return self.__script_input

    def _set_script_input(self, v, load=False):
        """
    Setter method for script_input, mapped from YANG variable /vnfd/lifecycle_management_script/script_input (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_script_input is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_script_input() directly.

    YANG Description: Array of KVP requirements with the key as the parameter
name and the value as the parameter that need to be
passed as an input to the script.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("key",
                                                  yc_script_input_etsi_nfv_vnfd__vnfd_lifecycle_management_script_script_input,
                                                  yang_name="script-input", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='key',
                                                  extensions=None), is_container='list', yang_name="script-input",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """script_input must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("key",yc_script_input_etsi_nfv_vnfd__vnfd_lifecycle_management_script_script_input, yang_name="script-input", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list', yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__script_input = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_script_input(self):
        self.__script_input = YANGDynClass(
            base=YANGListType("key", yc_script_input_etsi_nfv_vnfd__vnfd_lifecycle_management_script_script_input,
                              yang_name="script-input", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='key', extensions=None), is_container='list',
            yang_name="script-input", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    event = __builtin__.property(_get_event, _set_event)
    lcm_transition_event = __builtin__.property(_get_lcm_transition_event, _set_lcm_transition_event)
    script = __builtin__.property(_get_script, _set_script)
    script_dsl = __builtin__.property(_get_script_dsl, _set_script_dsl)
    script_input = __builtin__.property(_get_script_input, _set_script_input)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('event', event), ('lcm_transition_event', lcm_transition_event), ('script', script),
         ('script_dsl', script_dsl), ('script_input', script_input), ])


class yc_element_group_etsi_nfv_vnfd__vnfd_element_group(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/element-group. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__description', '__vdu', '__virtual_link_desc',)

    _yang_name = 'element-group'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__vdu = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                  yang_name="vdu", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='leafref', is_config=True)
        self.__virtual_link_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                is_leaf=False, yang_name="virtual-link-desc", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'element-group']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/element_group/id (string)

    YANG Description: Unique identifier of this group in the VNFD.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/element_group/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier of this group in the VNFD.
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/element_group/description (string)

    YANG Description: Human readable description of the group.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/element_group/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Human readable description of the group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                          defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /vnfd/element_group/vdu (leafref)

    YANG Description: References to Vdus that are part of this group.
    """
        return self.__vdu

    def _set_vdu(self, v, load=False):
        """
    Setter method for vdu, mapped from YANG variable /vnfd/element_group/vdu (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: References to Vdus that are part of this group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__vdu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                  yang_name="vdu", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                  yang_type='leafref', is_config=True)

    def _get_virtual_link_desc(self):
        """
    Getter method for virtual_link_desc, mapped from YANG variable /vnfd/element_group/virtual_link_desc (leafref)

    YANG Description: References to VnfVirtualLinkDesc that are part of this
group.
    """
        return self.__virtual_link_desc

    def _set_virtual_link_desc(self, v, load=False):
        """
    Setter method for virtual_link_desc, mapped from YANG variable /vnfd/element_group/virtual_link_desc (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_link_desc() directly.

    YANG Description: References to VnfVirtualLinkDesc that are part of this
group.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_link_desc must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)""",
            })

        self.__virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_link_desc(self):
        self.__virtual_link_desc = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                                is_leaf=False, yang_name="virtual-link-desc", parent=self,
                                                path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='leafref', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    description = __builtin__.property(_get_description, _set_description)
    vdu = __builtin__.property(_get_vdu, _set_vdu)
    virtual_link_desc = __builtin__.property(_get_virtual_link_desc, _set_virtual_link_desc)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('description', description), ('vdu', vdu), ('virtual_link_desc', virtual_link_desc), ])


class yc_indicator_etsi_nfv_vnfd__vnfd_indicator(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/indicator. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Declares the VNF indicators that are supported by this
VNF.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id', '__name', '__indicator_value', '__source',)

    _yang_name = 'indicator'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)
        self.__indicator_value = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="indicator-value", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'indicator']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/indicator/id (string)

    YANG Description: Unique identifier
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/indicator/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Unique identifier
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                 defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/indicator/name (string)

    YANG Description: The human readable name of the VnfIndicator.
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/indicator/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: The human readable name of the VnfIndicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                   yang_type='string', is_config=True)

    def _get_indicator_value(self):
        """
    Getter method for indicator_value, mapped from YANG variable /vnfd/indicator/indicator_value (string)

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        return self.__indicator_value

    def _set_indicator_value(self, v, load=False):
        """
    Setter method for indicator_value, mapped from YANG variable /vnfd/indicator/indicator_value (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator_value is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator_value() directly.

    YANG Description: Defines the allowed values or value ranges of this
indicator.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="indicator-value", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator_value must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="indicator-value", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__indicator_value = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator_value(self):
        self.__indicator_value = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type),
                                              is_leaf=False, yang_name="indicator-value", parent=self,
                                              path_helper=self._path_helper, extmethods=self._extmethods,
                                              register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                              defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_source(self):
        """
    Getter method for source, mapped from YANG variable /vnfd/indicator/source (enumeration)

    YANG Description: Describe the source of the indicator. The possible values
are:
• VNF.
• EM.
• Both.
This tells the consumer where to send the subscription
request.
    """
        return self.__source

    def _set_source(self, v, load=False):
        """
    Setter method for source, mapped from YANG variable /vnfd/indicator/source (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_source is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_source() directly.

    YANG Description: Describe the source of the indicator. The possible values
are:
• VNF.
• EM.
• Both.
This tells the consumer where to send the subscription
request.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                             is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='enumeration', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """source must be of a type compatible with enumeration""",
                'defined-type': "etsi-nfv-vnfd:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'vnf': {}, 'em': {}, 'both': {}},), is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='enumeration', is_config=True)""",
            })

        self.__source = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_source(self):
        self.__source = YANGDynClass(base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                              restriction_arg={'vnf': {}, 'em': {}, 'both': {}}, ),
                                     is_leaf=True, yang_name="source", parent=self, path_helper=self._path_helper,
                                     extmethods=self._extmethods, register_paths=True,
                                     namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                     yang_type='enumeration', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    name = __builtin__.property(_get_name, _set_name)
    indicator_value = __builtin__.property(_get_indicator_value, _set_indicator_value)
    source = __builtin__.property(_get_source, _set_source)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('name', name), ('indicator_value', indicator_value), ('source', source), ])


class yc_kdu_etsi_nfv_vnfd__vnfd_kdu(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/kdu. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of K8s Deployment Units
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__name', '__description', '__helm_chart', '__helm_version', '__juju_bundle',)

    _yang_name = 'kdu'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                   yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
                                          defining_module='kdu', yang_type='string', is_config=True)
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                         yang_type='string', is_config=True)
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
            defining_module='kdu', yang_type='enumeration', is_config=True)
        self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self,
                                          choice=('kdu-model', 'juju-bundle'), path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                          yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'kdu']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/kdu/name (string)

    YANG Description: Unique name for the KDU
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/kdu/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Unique name for the KDU
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                   yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/kdu/description (string)

    YANG Description: Description of the KDU.
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/kdu/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.

    YANG Description: Description of the KDU.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
                                          defining_module='kdu', yang_type='string', is_config=True)

    def _get_helm_chart(self):
        """
    Getter method for helm_chart, mapped from YANG variable /vnfd/kdu/helm_chart (string)

    YANG Description: Helm chart that models the KDU, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under k8s_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
        return self.__helm_chart

    def _set_helm_chart(self, v, load=False):
        """
    Setter method for helm_chart, mapped from YANG variable /vnfd/kdu/helm_chart (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_chart is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_chart() directly.

    YANG Description: Helm chart that models the KDU, in any of the following ways:
- <helm-repo>/<helm-chart>
- <helm-chart folder under k8s_models folder in the package>
- <helm-chart tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_chart>

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                             choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_chart must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self, choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__helm_chart = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_chart(self):
        self.__helm_chart = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="helm-chart", parent=self,
                                         choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                         yang_type='string', is_config=True)

    def _get_helm_version(self):
        """
    Getter method for helm_version, mapped from YANG variable /vnfd/kdu/helm_version (enumeration)

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        return self.__helm_version

    def _set_helm_version(self, v, load=False):
        """
    Setter method for helm_version, mapped from YANG variable /vnfd/kdu/helm_version (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_helm_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_helm_version() directly.

    YANG Description: Helm version to use for this helm-chart, v3 by default
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                         restriction_arg={'v2': {}, 'v3': {}}, ),
                             default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self,
                             choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='enumeration',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """helm_version must be of a type compatible with enumeration""",
                'defined-type': "kdu:enumeration",
                'generated-type': """YANGDynClass(base=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'v2': {}, 'v3': {}},), default=six.text_type("v3"), is_leaf=True, yang_name="helm-version", parent=self, choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='enumeration', is_config=True)""",
            })

        self.__helm_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_helm_version(self):
        self.__helm_version = YANGDynClass(
            base=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                     restriction_arg={'v2': {}, 'v3': {}}, ), default=six.text_type("v3"), is_leaf=True,
            yang_name="helm-version", parent=self, choice=('kdu-model', 'helm-chart'), path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu',
            defining_module='kdu', yang_type='enumeration', is_config=True)

    def _get_juju_bundle(self):
        """
    Getter method for juju_bundle, mapped from YANG variable /vnfd/kdu/juju_bundle (string)

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
        return self.__juju_bundle

    def _set_juju_bundle(self, v, load=False):
        """
    Setter method for juju_bundle, mapped from YANG variable /vnfd/kdu/juju_bundle (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_juju_bundle is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_juju_bundle() directly.

    YANG Description: Juju bundle that models the KDU, in any of the following ways:
- <juju-repo>/<juju-bundle>
- <juju-bundle folder under k8s_models folder in the package>
- <juju-bundle tgz file (w/ or w/o extension) under k8s_models folder in the package>
- <URL_where_to_fetch_juju_bundle>

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self,
                             choice=('kdu-model', 'juju-bundle'), path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """juju_bundle must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self, choice=('kdu-model', 'juju-bundle'), path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__juju_bundle = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_juju_bundle(self):
        self.__juju_bundle = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="juju-bundle", parent=self,
                                          choice=('kdu-model', 'juju-bundle'), path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True,
                                          namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                          yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    description = __builtin__.property(_get_description, _set_description)
    helm_chart = __builtin__.property(_get_helm_chart, _set_helm_chart)
    helm_version = __builtin__.property(_get_helm_version, _set_helm_version)
    juju_bundle = __builtin__.property(_get_juju_bundle, _set_juju_bundle)

    __choices__ = {'kdu-model': {'helm-chart': ['helm_chart', 'helm_version'], 'juju-bundle': ['juju_bundle']}}
    _pyangbind_elements = OrderedDict(
        [('name', name), ('description', description), ('helm_chart', helm_chart), ('helm_version', helm_version),
         ('juju_bundle', juju_bundle), ])


class yc_nets_etsi_nfv_vnfd__vnfd_k8s_cluster_nets(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/k8s-cluster/nets. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
  """
    __slots__ = ('_path_helper', '_extmethods', '__id',)

    _yang_name = 'nets'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                 yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'k8s-cluster', 'nets']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/k8s_cluster/nets/id (string)

    YANG Description: Internal identifier for the K8s cluster network in this VNF
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/k8s_cluster/nets/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Internal identifier for the K8s cluster network in this VNF
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                 yang_type='string', is_config=True)

    id = __builtin__.property(_get_id, _set_id)

    _pyangbind_elements = OrderedDict([('id', id), ])


class yc_k8s_cluster_etsi_nfv_vnfd__vnfd_k8s_cluster(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/k8s-cluster. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__version', '__cni', '__nets',)

    _yang_name = 'k8s-cluster'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="version", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                      yang_type='string', is_config=True)
        self.__cni = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'calico': {}, 'flannel': {}, 'multus': {}}, )),
                                  is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                  yang_type='enumeration', is_config=True)
        self.__nets = YANGDynClass(
            base=YANGListType("id", yc_nets_etsi_nfv_vnfd__vnfd_k8s_cluster_nets, yang_name="nets", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="nets", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'k8s-cluster']

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /vnfd/k8s_cluster/version (string)

    YANG Description: List of supported K8s versions.
The cluster where the KDUs will be deployed will have to match
one of these versions.
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /vnfd/k8s_cluster/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: List of supported K8s versions.
The cluster where the KDUs will be deployed will have to match
one of these versions.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="version", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                      yang_name="version", parent=self, path_helper=self._path_helper,
                                      extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                      yang_type='string', is_config=True)

    def _get_cni(self):
        """
    Getter method for cni, mapped from YANG variable /vnfd/k8s_cluster/cni (enumeration)

    YANG Description: List of supported CNI plugins.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
        return self.__cni

    def _set_cni(self, v, load=False):
        """
    Setter method for cni, mapped from YANG variable /vnfd/k8s_cluster/cni (enumeration)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_cni is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_cni() directly.

    YANG Description: List of supported CNI plugins.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(
                allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                                 restriction_arg={'calico': {}, 'flannel': {}, 'multus': {}}, )),
                             is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='enumeration',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """cni must be of a type compatible with enumeration""",
                'defined-type': "kdu:enumeration",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=RestrictedClassType(base_type=six.text_type,                                     restriction_type="dict_key",                                     restriction_arg={'calico': {}, 'flannel': {}, 'multus': {}},)), is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='enumeration', is_config=True)""",
            })

        self.__cni = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_cni(self):
        self.__cni = YANGDynClass(unique=True, base=TypedListType(
            allowed_type=RestrictedClassType(base_type=six.text_type, restriction_type="dict_key",
                                             restriction_arg={'calico': {}, 'flannel': {}, 'multus': {}}, )),
                                  is_leaf=False, yang_name="cni", parent=self, path_helper=self._path_helper,
                                  extmethods=self._extmethods, register_paths=True,
                                  namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                  yang_type='enumeration', is_config=True)

    def _get_nets(self):
        """
    Getter method for nets, mapped from YANG variable /vnfd/k8s_cluster/nets (list)

    YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
        return self.__nets

    def _set_nets(self, v, load=False):
        """
    Setter method for nets, mapped from YANG variable /vnfd/k8s_cluster/nets (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_nets is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_nets() directly.

    YANG Description: List of required networks in the K8s cluster.
The cluster where the KDUs will be deployed will have to use
one of these CNI plugins.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_nets_etsi_nfv_vnfd__vnfd_k8s_cluster_nets, yang_name="nets",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """nets must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_nets_etsi_nfv_vnfd__vnfd_k8s_cluster_nets, yang_name="nets", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="nets", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)""",
            })

        self.__nets = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_nets(self):
        self.__nets = YANGDynClass(
            base=YANGListType("id", yc_nets_etsi_nfv_vnfd__vnfd_k8s_cluster_nets, yang_name="nets", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="nets", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)

    version = __builtin__.property(_get_version, _set_version)
    cni = __builtin__.property(_get_cni, _set_cni)
    nets = __builtin__.property(_get_nets, _set_nets)

    _pyangbind_elements = OrderedDict([('version', version), ('cni', cni), ('nets', nets), ])


class yc_service_etsi_nfv_vnfd__vnfd_service(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/service. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__mgmt_service', '__external_connection_point_ref',)

    _yang_name = 'service'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                   yang_type='string', is_config=True)
        self.__mgmt_service = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                           yang_name="mgmt-service", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                           yang_type='boolean', is_config=True)
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:kdu',
                                                            defining_module='kdu', yang_type='string', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'service']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/service/name (string)

    YANG Description: Name of the Kubernetes service exposed by he KDU model
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/service/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the Kubernetes service exposed by he KDU model
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                   yang_type='string', is_config=True)

    def _get_mgmt_service(self):
        """
    Getter method for mgmt_service, mapped from YANG variable /vnfd/service/mgmt_service (boolean)

    YANG Description: Flag to indicate that this Kubernetes service is a mgmt service
to be used for KDU configuration. Defaults to false (if no present).
All services with mgmt-service set to true will be passed to the execution
environment in charge of the KDU configuration.
    """
        return self.__mgmt_service

    def _set_mgmt_service(self, v, load=False):
        """
    Setter method for mgmt_service, mapped from YANG variable /vnfd/service/mgmt_service (boolean)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_service() directly.

    YANG Description: Flag to indicate that this Kubernetes service is a mgmt service
to be used for KDU configuration. Defaults to false (if no present).
All services with mgmt-service set to true will be passed to the execution
environment in charge of the KDU configuration.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                             yang_type='boolean', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mgmt_service must be of a type compatible with boolean""",
                'defined-type': "boolean",
                'generated-type': """YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True, yang_name="mgmt-service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='boolean', is_config=True)""",
            })

        self.__mgmt_service = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mgmt_service(self):
        self.__mgmt_service = YANGDynClass(base=YANGBool, default=YANGBool("false"), is_leaf=True,
                                           yang_name="mgmt-service", parent=self, path_helper=self._path_helper,
                                           extmethods=self._extmethods, register_paths=True,
                                           namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                           yang_type='boolean', is_config=True)

    def _get_external_connection_point_ref(self):
        """
    Getter method for external_connection_point_ref, mapped from YANG variable /vnfd/service/external_connection_point_ref (string)

    YANG Description: String representing a leaf reference to the particular external connection point.
This field should match /etsi-nfv-vnfd:vnfd/etsi-nfv-vnfd:ext-cpd/etsi-nfv-vnfd:id

    """
        return self.__external_connection_point_ref

    def _set_external_connection_point_ref(self, v, load=False):
        """
    Setter method for external_connection_point_ref, mapped from YANG variable /vnfd/service/external_connection_point_ref (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_external_connection_point_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_external_connection_point_ref() directly.

    YANG Description: String representing a leaf reference to the particular external connection point.
This field should match /etsi-nfv-vnfd:vnfd/etsi-nfv-vnfd:ext-cpd/etsi-nfv-vnfd:id

    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """external_connection_point_ref must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="external-connection-point-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='string', is_config=True)""",
            })

        self.__external_connection_point_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_external_connection_point_ref(self):
        self.__external_connection_point_ref = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="external-connection-point-ref", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:osm:yang:augments:kdu',
                                                            defining_module='kdu', yang_type='string', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    mgmt_service = __builtin__.property(_get_mgmt_service, _set_mgmt_service)
    external_connection_point_ref = __builtin__.property(_get_external_connection_point_ref,
                                                         _set_external_connection_point_ref)

    _pyangbind_elements = OrderedDict([('name', name), ('mgmt_service', mgmt_service),
                                       ('external_connection_point_ref', external_connection_point_ref), ])


class yc_paired_interfaces_etsi_nfv_vnfd__vnfd_vip_paired_interfaces(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vip/paired-interfaces. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vdu_id_ref', '__interface_ref',)

    _yang_name = 'paired-interfaces'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vdu_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, is_keyval=True,
                                         namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                                         yang_type='leafref', is_config=True)
        self.__interface_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-ref", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:osm:yang:augments:vip',
                                            defining_module='vip', yang_type='leafref', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vip', 'paired-interfaces']

    def _get_vdu_id_ref(self):
        """
    Getter method for vdu_id_ref, mapped from YANG variable /vnfd/vip/paired_interfaces/vdu_id_ref (leafref)

    YANG Description: Reference to the VDU
    """
        return self.__vdu_id_ref

    def _set_vdu_id_ref(self, v, load=False):
        """
    Setter method for vdu_id_ref, mapped from YANG variable /vnfd/vip/paired_interfaces/vdu_id_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu_id_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu_id_ref() directly.

    YANG Description: Reference to the VDU
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu_id_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='leafref', is_config=True)""",
            })

        self.__vdu_id_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu_id_ref(self):
        self.__vdu_id_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="vdu-id-ref", parent=self,
                                         path_helper=self._path_helper, extmethods=self._extmethods,
                                         register_paths=True, is_keyval=True,
                                         namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                                         yang_type='leafref', is_config=True)

    def _get_interface_ref(self):
        """
    Getter method for interface_ref, mapped from YANG variable /vnfd/vip/paired_interfaces/interface_ref (leafref)

    YANG Description: Reference to the interface
    """
        return self.__interface_ref

    def _set_interface_ref(self, v, load=False):
        """
    Setter method for interface_ref, mapped from YANG variable /vnfd/vip/paired_interfaces/interface_ref (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_interface_ref is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_interface_ref() directly.

    YANG Description: Reference to the interface
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="interface-ref", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='leafref',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """interface_ref must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-ref", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='leafref', is_config=True)""",
            })

        self.__interface_ref = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_interface_ref(self):
        self.__interface_ref = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="interface-ref", parent=self,
                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                            register_paths=True, namespace='urn:etsi:osm:yang:augments:vip',
                                            defining_module='vip', yang_type='leafref', is_config=True)

    vdu_id_ref = __builtin__.property(_get_vdu_id_ref, _set_vdu_id_ref)
    interface_ref = __builtin__.property(_get_interface_ref, _set_interface_ref)

    _pyangbind_elements = OrderedDict([('vdu_id_ref', vdu_id_ref), ('interface_ref', interface_ref), ])


class yc_vip_etsi_nfv_vnfd__vnfd_vip(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd/vip. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Paired interfaces from different VDUs that share a Virtual IP
  """
    __slots__ = ('_path_helper', '_extmethods', '__name', '__paired_interfaces',)

    _yang_name = 'vip'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                                   yang_type='string', is_config=True)
        self.__paired_interfaces = YANGDynClass(
            base=YANGListType("vdu_id_ref", yc_paired_interfaces_etsi_nfv_vnfd__vnfd_vip_paired_interfaces,
                              yang_name="paired-interfaces", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None),
            is_container='list', yang_name="paired-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd', 'vip']

    def _get_name(self):
        """
    Getter method for name, mapped from YANG variable /vnfd/vip/name (string)

    YANG Description: Name of the Virtual IP
    """
        return self.__name

    def _set_name(self, v, load=False):
        """
    Setter method for name, mapped from YANG variable /vnfd/vip/name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_name() directly.

    YANG Description: Name of the Virtual IP
    """
        parent = getattr(self, "_parent", None)
        if parent is not None and load is False:
            raise AttributeError("Cannot set keys directly when" +
                                 " within an instantiated list")

        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='string', is_config=True)""",
            })

        self.__name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_name(self):
        self.__name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="name", parent=self,
                                   path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                   is_keyval=True, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip',
                                   yang_type='string', is_config=True)

    def _get_paired_interfaces(self):
        """
    Getter method for paired_interfaces, mapped from YANG variable /vnfd/vip/paired_interfaces (list)
    """
        return self.__paired_interfaces

    def _set_paired_interfaces(self, v, load=False):
        """
    Setter method for paired_interfaces, mapped from YANG variable /vnfd/vip/paired_interfaces (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_paired_interfaces is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_paired_interfaces() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("vdu_id_ref",
                                                  yc_paired_interfaces_etsi_nfv_vnfd__vnfd_vip_paired_interfaces,
                                                  yang_name="paired-interfaces", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper,
                                                  yang_keys='vdu-id-ref', extensions=None), is_container='list',
                             yang_name="paired-interfaces", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """paired_interfaces must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("vdu_id_ref",yc_paired_interfaces_etsi_nfv_vnfd__vnfd_vip_paired_interfaces, yang_name="paired-interfaces", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None), is_container='list', yang_name="paired-interfaces", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)""",
            })

        self.__paired_interfaces = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_paired_interfaces(self):
        self.__paired_interfaces = YANGDynClass(
            base=YANGListType("vdu_id_ref", yc_paired_interfaces_etsi_nfv_vnfd__vnfd_vip_paired_interfaces,
                              yang_name="paired-interfaces", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='vdu-id-ref', extensions=None),
            is_container='list', yang_name="paired-interfaces", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)

    name = __builtin__.property(_get_name, _set_name)
    paired_interfaces = __builtin__.property(_get_paired_interfaces, _set_paired_interfaces)

    _pyangbind_elements = OrderedDict([('name', name), ('paired_interfaces', paired_interfaces), ])


class yc_vnfd_etsi_nfv_vnfd__vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.
  """
    __slots__ = (
        '_path_helper', '_extmethods', '__id', '__provider', '__product_name', '__software_version', '__version',
        '__product_info_name', '__product_info_description', '__vnfm_info', '__localization_language',
        '__default_localization_language', '__vdu', '__virtual_compute_desc', '__virtual_storage_desc',
        '__sw_image_desc',
        '__int_virtual_link_desc', '__security_group_rule', '__ext_cpd', '__df', '__configurable_properties',
        '__modifiable_attributes', '__lifecycle_management_script', '__element_group', '__indicator', '__auto_scale',
        '__description', '__kdu', '__k8s_cluster', '__service', '__mgmt_cp', '__vip',)

    _yang_name = 'vnfd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                 yang_type='string', is_config=True)
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='string', is_config=True)
        self.__product_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                      yang_type='string', is_config=True)
        self.__product_info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__product_info_description = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="product-info-description", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='string',
                                                       is_config=True)
        self.__vnfm_info = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)
        self.__localization_language = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        self.__default_localization_language = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="default-localization-language", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='string',
                                                            is_config=True)
        self.__vdu = YANGDynClass(
            base=YANGListType("id", yc_vdu_etsi_nfv_vnfd__vnfd_vdu, yang_name="vdu", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__virtual_compute_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_compute_desc_etsi_nfv_vnfd__vnfd_virtual_compute_desc,
                              yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__virtual_storage_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_storage_desc_etsi_nfv_vnfd__vnfd_virtual_storage_desc,
                              yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__sw_image_desc = YANGDynClass(
            base=YANGListType("id", yc_sw_image_desc_etsi_nfv_vnfd__vnfd_sw_image_desc, yang_name="sw-image-desc",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)
        self.__int_virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_int_virtual_link_desc_etsi_nfv_vnfd__vnfd_int_virtual_link_desc,
                              yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_vnfd__vnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_vnfd__vnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_vnfd__vnfd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__configurable_properties = YANGDynClass(
            base=yc_configurable_properties_etsi_nfv_vnfd__vnfd_configurable_properties, is_container='container',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)
        self.__modifiable_attributes = YANGDynClass(
            base=yc_modifiable_attributes_etsi_nfv_vnfd__vnfd_modifiable_attributes, is_container='container',
            yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("id", yc_lifecycle_management_script_etsi_nfv_vnfd__vnfd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__element_group = YANGDynClass(
            base=YANGListType("id", yc_element_group_etsi_nfv_vnfd__vnfd_element_group, yang_name="element-group",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="element-group",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)
        self.__auto_scale = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                         yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                         yang_type='string', is_config=True)
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)
        self.__kdu = YANGDynClass(
            base=YANGListType("name", yc_kdu_etsi_nfv_vnfd__vnfd_kdu, yang_name="kdu", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)
        self.__k8s_cluster = YANGDynClass(base=yc_k8s_cluster_etsi_nfv_vnfd__vnfd_k8s_cluster, is_container='container',
                                          yang_name="k8s-cluster", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True, extensions=None,
                                          namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                          yang_type='container', is_config=True)
        self.__service = YANGDynClass(
            base=YANGListType("name", yc_service_etsi_nfv_vnfd__vnfd_service, yang_name="service", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                              extensions=None), is_container='list', yang_name="service", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)
        self.__mgmt_cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-cp", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:mgmt-interface',
                                      defining_module='mgmt-interface', yang_type='leafref', is_config=True)
        self.__vip = YANGDynClass(
            base=YANGListType("name", yc_vip_etsi_nfv_vnfd__vnfd_vip, yang_name="vip", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="vip", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return ['vnfd']

    def _get_id(self):
        """
    Getter method for id, mapped from YANG variable /vnfd/id (string)

    YANG Description: Identifier of this VNFD information element. This attribute
shall be globally unique. The format will be defined in the
data model specification phase.
    """
        return self.__id

    def _set_id(self, v, load=False):
        """
    Setter method for id, mapped from YANG variable /vnfd/id (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_id is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_id() directly.

    YANG Description: Identifier of this VNFD information element. This attribute
shall be globally unique. The format will be defined in the
data model specification phase.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """id must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__id = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_id(self):
        self.__id = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="id", parent=self,
                                 path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                 namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                 yang_type='string', is_config=True)

    def _get_provider(self):
        """
    Getter method for provider, mapped from YANG variable /vnfd/provider (string)

    YANG Description: Provider of the VNF and of the VNFD
    """
        return self.__provider

    def _set_provider(self, v, load=False):
        """
    Setter method for provider, mapped from YANG variable /vnfd/provider (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_provider is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_provider() directly.

    YANG Description: Provider of the VNF and of the VNFD
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """provider must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__provider = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_provider(self):
        self.__provider = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="provider", parent=self,
                                       path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                       namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                       yang_type='string', is_config=True)

    def _get_product_name(self):
        """
    Getter method for product_name, mapped from YANG variable /vnfd/product_name (string)

    YANG Description: Name to identify the VNF Product. Invariant for the VNF
Product lifetime.
    """
        return self.__product_name

    def _set_product_name(self, v, load=False):
        """
    Setter method for product_name, mapped from YANG variable /vnfd/product_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_name() directly.

    YANG Description: Name to identify the VNF Product. Invariant for the VNF
Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__product_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_name(self):
        self.__product_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-name", parent=self,
                                           path_helper=self._path_helper, extmethods=self._extmethods,
                                           register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                           defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_software_version(self):
        """
    Getter method for software_version, mapped from YANG variable /vnfd/software_version (string)

    YANG Description: Software version of the VNF. This is changed when there is
any change to the software that is included in the VNF
Package
    """
        return self.__software_version

    def _set_software_version(self, v, load=False):
        """
    Setter method for software_version, mapped from YANG variable /vnfd/software_version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_software_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_software_version() directly.

    YANG Description: Software version of the VNF. This is changed when there is
any change to the software that is included in the VNF
Package
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="software-version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """software_version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__software_version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_software_version(self):
        self.__software_version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="software-version",
                                               parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                               register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                               defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_version(self):
        """
    Getter method for version, mapped from YANG variable /vnfd/version (string)

    YANG Description: Identifies the version of the VNFD
    """
        return self.__version

    def _set_version(self, v, load=False):
        """
    Setter method for version, mapped from YANG variable /vnfd/version (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_version is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_version() directly.

    YANG Description: Identifies the version of the VNFD
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """version must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__version = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_version(self):
        self.__version = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="version", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                      yang_type='string', is_config=True)

    def _get_product_info_name(self):
        """
    Getter method for product_info_name, mapped from YANG variable /vnfd/product_info_name (string)

    YANG Description: Human readable name of the VNFD. Can change
during the VNF Product lifetime.
    """
        return self.__product_info_name

    def _set_product_info_name(self, v, load=False):
        """
    Setter method for product_info_name, mapped from YANG variable /vnfd/product_info_name (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_info_name is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_info_name() directly.

    YANG Description: Human readable name of the VNFD. Can change
during the VNF Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-info-name", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_info_name must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__product_info_name = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_info_name(self):
        self.__product_info_name = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-name",
                                                parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                                register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_product_info_description(self):
        """
    Getter method for product_info_description, mapped from YANG variable /vnfd/product_info_description (string)

    YANG Description: Human readable description of the VNFD. Can change during
the VNF Product lifetime.
    """
        return self.__product_info_description

    def _set_product_info_description(self, v, load=False):
        """
    Setter method for product_info_description, mapped from YANG variable /vnfd/product_info_description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_product_info_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_product_info_description() directly.

    YANG Description: Human readable description of the VNFD. Can change during
the VNF Product lifetime.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="product-info-description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """product_info_description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="product-info-description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__product_info_description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_product_info_description(self):
        self.__product_info_description = YANGDynClass(base=six.text_type, is_leaf=True,
                                                       yang_name="product-info-description", parent=self,
                                                       path_helper=self._path_helper, extmethods=self._extmethods,
                                                       register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                       defining_module='etsi-nfv-vnfd', yang_type='string',
                                                       is_config=True)

    def _get_vnfm_info(self):
        """
    Getter method for vnfm_info, mapped from YANG variable /vnfd/vnfm_info (string)

    YANG Description: Identifies VNFM(s) compatible with the VNF described in
this version of the VNFD.
    """
        return self.__vnfm_info

    def _set_vnfm_info(self, v, load=False):
        """
    Setter method for vnfm_info, mapped from YANG variable /vnfd/vnfm_info (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfm_info is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfm_info() directly.

    YANG Description: Identifies VNFM(s) compatible with the VNF described in
this version of the VNFD.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfm_info must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="vnfm-info", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__vnfm_info = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfm_info(self):
        self.__vnfm_info = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                        yang_name="vnfm-info", parent=self, path_helper=self._path_helper,
                                        extmethods=self._extmethods, register_paths=True,
                                        namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                        yang_type='string', is_config=True)

    def _get_localization_language(self):
        """
    Getter method for localization_language, mapped from YANG variable /vnfd/localization_language (string)

    YANG Description: Information about the language of the VNF.
    """
        return self.__localization_language

    def _set_localization_language(self, v, load=False):
        """
    Setter method for localization_language, mapped from YANG variable /vnfd/localization_language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_localization_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_localization_language() directly.

    YANG Description: Information about the language of the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="localization-language", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """localization_language must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__localization_language = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_localization_language(self):
        self.__localization_language = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="localization-language",
                                                    parent=self, path_helper=self._path_helper,
                                                    extmethods=self._extmethods, register_paths=True,
                                                    namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                    defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)

    def _get_default_localization_language(self):
        """
    Getter method for default_localization_language, mapped from YANG variable /vnfd/default_localization_language (string)

    YANG Description: Default localization language that is instantiated if no
information about selected localization language is
available. Shall be present if 'localization-language'
is present and shall be absent otherwise.
    """
        return self.__default_localization_language

    def _set_default_localization_language(self, v, load=False):
        """
    Setter method for default_localization_language, mapped from YANG variable /vnfd/default_localization_language (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_default_localization_language is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_default_localization_language() directly.

    YANG Description: Default localization language that is instantiated if no
information about selected localization language is
available. Shall be present if 'localization-language'
is present and shall be absent otherwise.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="default-localization-language",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """default_localization_language must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="default-localization-language", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__default_localization_language = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_default_localization_language(self):
        self.__default_localization_language = YANGDynClass(base=six.text_type, is_leaf=True,
                                                            yang_name="default-localization-language", parent=self,
                                                            path_helper=self._path_helper, extmethods=self._extmethods,
                                                            register_paths=True,
                                                            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                                            defining_module='etsi-nfv-vnfd', yang_type='string',
                                                            is_config=True)

    def _get_vdu(self):
        """
    Getter method for vdu, mapped from YANG variable /vnfd/vdu (list)

    YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
    """
        return self.__vdu

    def _set_vdu(self, v, load=False):
        """
    Setter method for vdu, mapped from YANG variable /vnfd/vdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vdu() directly.

    YANG Description: The Virtualisation Deployment Unit (VDU) is a construct supporting
the description of the deployment and operational behaviour of a
VNF component, or the entire VNF if it was not componentized in
components.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_vdu_etsi_nfv_vnfd__vnfd_vdu, yang_name="vdu", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vdu must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_vdu_etsi_nfv_vnfd__vnfd_vdu, yang_name="vdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__vdu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vdu(self):
        self.__vdu = YANGDynClass(
            base=YANGListType("id", yc_vdu_etsi_nfv_vnfd__vnfd_vdu, yang_name="vdu", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="vdu", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_virtual_compute_desc(self):
        """
    Getter method for virtual_compute_desc, mapped from YANG variable /vnfd/virtual_compute_desc (list)

    YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
    """
        return self.__virtual_compute_desc

    def _set_virtual_compute_desc(self, v, load=False):
        """
    Setter method for virtual_compute_desc, mapped from YANG variable /vnfd/virtual_compute_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_compute_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_compute_desc() directly.

    YANG Description: Defines descriptors of virtual compute resources to be
used by the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_virtual_compute_desc_etsi_nfv_vnfd__vnfd_virtual_compute_desc,
                                               yang_name="virtual-compute-desc", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="virtual-compute-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_compute_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_compute_desc_etsi_nfv_vnfd__vnfd_virtual_compute_desc, yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_compute_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_compute_desc(self):
        self.__virtual_compute_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_compute_desc_etsi_nfv_vnfd__vnfd_virtual_compute_desc,
                              yang_name="virtual-compute-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-compute-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_virtual_storage_desc(self):
        """
    Getter method for virtual_storage_desc, mapped from YANG variable /vnfd/virtual_storage_desc (list)

    YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
    """
        return self.__virtual_storage_desc

    def _set_virtual_storage_desc(self, v, load=False):
        """
    Setter method for virtual_storage_desc, mapped from YANG variable /vnfd/virtual_storage_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_virtual_storage_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_virtual_storage_desc() directly.

    YANG Description: Storage requirements for a Virtual Storage instance
attached to the VNFC created from this VDU
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_virtual_storage_desc_etsi_nfv_vnfd__vnfd_virtual_storage_desc,
                                               yang_name="virtual-storage-desc", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="virtual-storage-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """virtual_storage_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_virtual_storage_desc_etsi_nfv_vnfd__vnfd_virtual_storage_desc, yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__virtual_storage_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_virtual_storage_desc(self):
        self.__virtual_storage_desc = YANGDynClass(
            base=YANGListType("id", yc_virtual_storage_desc_etsi_nfv_vnfd__vnfd_virtual_storage_desc,
                              yang_name="virtual-storage-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="virtual-storage-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_sw_image_desc(self):
        """
    Getter method for sw_image_desc, mapped from YANG variable /vnfd/sw_image_desc (list)

    YANG Description: Defines descriptors of software images to be used by the
VNF.
    """
        return self.__sw_image_desc

    def _set_sw_image_desc(self, v, load=False):
        """
    Setter method for sw_image_desc, mapped from YANG variable /vnfd/sw_image_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_sw_image_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_sw_image_desc() directly.

    YANG Description: Defines descriptors of software images to be used by the
VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_sw_image_desc_etsi_nfv_vnfd__vnfd_sw_image_desc,
                                                  yang_name="sw-image-desc", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="sw-image-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """sw_image_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_sw_image_desc_etsi_nfv_vnfd__vnfd_sw_image_desc, yang_name="sw-image-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__sw_image_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_sw_image_desc(self):
        self.__sw_image_desc = YANGDynClass(
            base=YANGListType("id", yc_sw_image_desc_etsi_nfv_vnfd__vnfd_sw_image_desc, yang_name="sw-image-desc",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="sw-image-desc",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

    def _get_int_virtual_link_desc(self):
        """
    Getter method for int_virtual_link_desc, mapped from YANG variable /vnfd/int_virtual_link_desc (list)

    YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
    """
        return self.__int_virtual_link_desc

    def _set_int_virtual_link_desc(self, v, load=False):
        """
    Setter method for int_virtual_link_desc, mapped from YANG variable /vnfd/int_virtual_link_desc (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_int_virtual_link_desc is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_int_virtual_link_desc() directly.

    YANG Description: Represents the type of network connectivity mandated by the
VNF provider between two or more CPs which includes at
least one internal CP.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_int_virtual_link_desc_etsi_nfv_vnfd__vnfd_int_virtual_link_desc,
                                               yang_name="int-virtual-link-desc", parent=self, is_container='list',
                                               user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                               extensions=None), is_container='list', yang_name="int-virtual-link-desc",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """int_virtual_link_desc must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_int_virtual_link_desc_etsi_nfv_vnfd__vnfd_int_virtual_link_desc, yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__int_virtual_link_desc = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_int_virtual_link_desc(self):
        self.__int_virtual_link_desc = YANGDynClass(
            base=YANGListType("id", yc_int_virtual_link_desc_etsi_nfv_vnfd__vnfd_int_virtual_link_desc,
                              yang_name="int-virtual-link-desc", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="int-virtual-link-desc", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_security_group_rule(self):
        """
    Getter method for security_group_rule, mapped from YANG variable /vnfd/security_group_rule (list)

    YANG Description: Defines security group rules to be used by the VNF.
    """
        return self.__security_group_rule

    def _set_security_group_rule(self, v, load=False):
        """
    Setter method for security_group_rule, mapped from YANG variable /vnfd/security_group_rule (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_security_group_rule is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_security_group_rule() directly.

    YANG Description: Defines security group rules to be used by the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_security_group_rule_etsi_nfv_vnfd__vnfd_security_group_rule,
                                                  yang_name="security-group-rule", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list',
                             yang_name="security-group-rule", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """security_group_rule must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_security_group_rule_etsi_nfv_vnfd__vnfd_security_group_rule, yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__security_group_rule = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_security_group_rule(self):
        self.__security_group_rule = YANGDynClass(
            base=YANGListType("id", yc_security_group_rule_etsi_nfv_vnfd__vnfd_security_group_rule,
                              yang_name="security-group-rule", parent=self, is_container='list', user_ordered=False,
                              path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list',
            yang_name="security-group-rule", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)

    def _get_ext_cpd(self):
        """
    Getter method for ext_cpd, mapped from YANG variable /vnfd/ext_cpd (list)

    YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
    """
        return self.__ext_cpd

    def _set_ext_cpd(self, v, load=False):
        """
    Setter method for ext_cpd, mapped from YANG variable /vnfd/ext_cpd (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_ext_cpd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_ext_cpd() directly.

    YANG Description: Describes an external interface exposed by this VNF enabling
connection with a Virual Link
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_ext_cpd_etsi_nfv_vnfd__vnfd_ext_cpd, yang_name="ext-cpd",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """ext_cpd must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_ext_cpd_etsi_nfv_vnfd__vnfd_ext_cpd, yang_name="ext-cpd", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="ext-cpd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__ext_cpd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_ext_cpd(self):
        self.__ext_cpd = YANGDynClass(
            base=YANGListType("id", yc_ext_cpd_etsi_nfv_vnfd__vnfd_ext_cpd, yang_name="ext-cpd", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="ext-cpd", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_df(self):
        """
    Getter method for df, mapped from YANG variable /vnfd/df (list)

    YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
    """
        return self.__df

    def _set_df(self, v, load=False):
        """
    Setter method for df, mapped from YANG variable /vnfd/df (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_df is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_df() directly.

    YANG Description: Describes a specific Deployment Flavour (DF) of a VNF with
specific requirements for capacity and performance.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_df_etsi_nfv_vnfd__vnfd_df, yang_name="df", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """df must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_df_etsi_nfv_vnfd__vnfd_df, yang_name="df", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="df", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__df = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_df(self):
        self.__df = YANGDynClass(
            base=YANGListType("id", yc_df_etsi_nfv_vnfd__vnfd_df, yang_name="df", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="df", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_configurable_properties(self):
        """
    Getter method for configurable_properties, mapped from YANG variable /vnfd/configurable_properties (container)

    YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
    """
        return self.__configurable_properties

    def _set_configurable_properties(self, v, load=False):
        """
    Setter method for configurable_properties, mapped from YANG variable /vnfd/configurable_properties (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_configurable_properties is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_configurable_properties() directly.

    YANG Description: Describes the configurable properties of the VNF
(e.g. related to auto scaling and auto healing).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_configurable_properties_etsi_nfv_vnfd__vnfd_configurable_properties,
                             is_container='container', yang_name="configurable-properties", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """configurable_properties must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_configurable_properties_etsi_nfv_vnfd__vnfd_configurable_properties, is_container='container', yang_name="configurable-properties", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__configurable_properties = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_configurable_properties(self):
        self.__configurable_properties = YANGDynClass(
            base=yc_configurable_properties_etsi_nfv_vnfd__vnfd_configurable_properties, is_container='container',
            yang_name="configurable-properties", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container',
            is_config=True)

    def _get_modifiable_attributes(self):
        """
    Getter method for modifiable_attributes, mapped from YANG variable /vnfd/modifiable_attributes (container)

    YANG Description: Describes the modifiable attributes of the VNF.
    """
        return self.__modifiable_attributes

    def _set_modifiable_attributes(self, v, load=False):
        """
    Setter method for modifiable_attributes, mapped from YANG variable /vnfd/modifiable_attributes (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_modifiable_attributes is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_modifiable_attributes() directly.

    YANG Description: Describes the modifiable attributes of the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_modifiable_attributes_etsi_nfv_vnfd__vnfd_modifiable_attributes,
                             is_container='container', yang_name="modifiable-attributes", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """modifiable_attributes must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_modifiable_attributes_etsi_nfv_vnfd__vnfd_modifiable_attributes, is_container='container', yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__modifiable_attributes = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_modifiable_attributes(self):
        self.__modifiable_attributes = YANGDynClass(
            base=yc_modifiable_attributes_etsi_nfv_vnfd__vnfd_modifiable_attributes, is_container='container',
            yang_name="modifiable-attributes", parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
            register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
            defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    def _get_lifecycle_management_script(self):
        """
    Getter method for lifecycle_management_script, mapped from YANG variable /vnfd/lifecycle_management_script (list)

    YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
    """
        return self.__lifecycle_management_script

    def _set_lifecycle_management_script(self, v, load=False):
        """
    Setter method for lifecycle_management_script, mapped from YANG variable /vnfd/lifecycle_management_script (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_lifecycle_management_script is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_lifecycle_management_script() directly.

    YANG Description: Includes a list of events and corresponding management
scripts performed for the VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id",
                                                  yc_lifecycle_management_script_etsi_nfv_vnfd__vnfd_lifecycle_management_script,
                                                  yang_name="lifecycle-management-script", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="lifecycle-management-script", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """lifecycle_management_script must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_lifecycle_management_script_etsi_nfv_vnfd__vnfd_lifecycle_management_script, yang_name="lifecycle-management-script", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__lifecycle_management_script = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_lifecycle_management_script(self):
        self.__lifecycle_management_script = YANGDynClass(
            base=YANGListType("id", yc_lifecycle_management_script_etsi_nfv_vnfd__vnfd_lifecycle_management_script,
                              yang_name="lifecycle-management-script", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None),
            is_container='list', yang_name="lifecycle-management-script", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_element_group(self):
        """
    Getter method for element_group, mapped from YANG variable /vnfd/element_group (list)

    YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
    """
        return self.__element_group

    def _set_element_group(self, v, load=False):
        """
    Setter method for element_group, mapped from YANG variable /vnfd/element_group (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_element_group is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_element_group() directly.

    YANG Description: Describes the associated elements of a VNFD for a certain
purpose during VNF lifecycle management.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("id", yc_element_group_etsi_nfv_vnfd__vnfd_element_group,
                                                  yang_name="element-group", parent=self, is_container='list',
                                                  user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                                                  extensions=None), is_container='list', yang_name="element-group",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """element_group must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_element_group_etsi_nfv_vnfd__vnfd_element_group, yang_name="element-group", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="element-group", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__element_group = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_element_group(self):
        self.__element_group = YANGDynClass(
            base=YANGListType("id", yc_element_group_etsi_nfv_vnfd__vnfd_element_group, yang_name="element-group",
                              parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper,
                              yang_keys='id', extensions=None), is_container='list', yang_name="element-group",
            parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
            extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
            yang_type='list', is_config=True)

    def _get_indicator(self):
        """
    Getter method for indicator, mapped from YANG variable /vnfd/indicator (list)

    YANG Description: Declares the VNF indicators that are supported by this
VNF.
    """
        return self.__indicator

    def _set_indicator(self, v, load=False):
        """
    Setter method for indicator, mapped from YANG variable /vnfd/indicator (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_indicator is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_indicator() directly.

    YANG Description: Declares the VNF indicators that are supported by this
VNF.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v,
                             base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_indicator, yang_name="indicator",
                                               parent=self, is_container='list', user_ordered=False,
                                               path_helper=self._path_helper, yang_keys='id', extensions=None),
                             is_container='list', yang_name="indicator", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='list', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """indicator must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("id",yc_indicator_etsi_nfv_vnfd__vnfd_indicator, yang_name="indicator", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id', extensions=None), is_container='list', yang_name="indicator", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list', is_config=True)""",
            })

        self.__indicator = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_indicator(self):
        self.__indicator = YANGDynClass(
            base=YANGListType("id", yc_indicator_etsi_nfv_vnfd__vnfd_indicator, yang_name="indicator", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='id',
                              extensions=None), is_container='list', yang_name="indicator", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='list',
            is_config=True)

    def _get_auto_scale(self):
        """
    Getter method for auto_scale, mapped from YANG variable /vnfd/auto_scale (string)

    YANG Description: Rule that determines when a scaling action needs to be
triggered on a VNF instance e.g. based on certain VNF
indicator values or VNF indicator value changes or a
combination of VNF indicator value(s) and monitoring
parameter(s).
    """
        return self.__auto_scale

    def _set_auto_scale(self, v, load=False):
        """
    Setter method for auto_scale, mapped from YANG variable /vnfd/auto_scale (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_auto_scale is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_auto_scale() directly.

    YANG Description: Rule that determines when a scaling action needs to be
triggered on a VNF instance e.g. based on certain VNF
indicator values or VNF indicator value changes or a
combination of VNF indicator value(s) and monitoring
parameter(s).
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                             yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """auto_scale must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False, yang_name="auto-scale", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='string', is_config=True)""",
            })

        self.__auto_scale = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_auto_scale(self):
        self.__auto_scale = YANGDynClass(unique=True, base=TypedListType(allowed_type=six.text_type), is_leaf=False,
                                         yang_name="auto-scale", parent=self, path_helper=self._path_helper,
                                         extmethods=self._extmethods, register_paths=True,
                                         namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd',
                                         yang_type='string', is_config=True)

    def _get_description(self):
        """
    Getter method for description, mapped from YANG variable /vnfd/description (string)
    """
        return self.__description

    def _set_description(self, v, load=False):
        """
    Setter method for description, mapped from YANG variable /vnfd/description (string)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_description is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_description() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info',
                             yang_type='string', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """description must be of a type compatible with string""",
                'defined-type': "string",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info', defining_module='additional-info', yang_type='string', is_config=True)""",
            })

        self.__description = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_description(self):
        self.__description = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="description", parent=self,
                                          path_helper=self._path_helper, extmethods=self._extmethods,
                                          register_paths=True, namespace='urn:etsi:osm:yang:augments:additional-info',
                                          defining_module='additional-info', yang_type='string', is_config=True)

    def _get_kdu(self):
        """
    Getter method for kdu, mapped from YANG variable /vnfd/kdu (list)

    YANG Description: List of K8s Deployment Units
    """
        return self.__kdu

    def _set_kdu(self, v, load=False):
        """
    Setter method for kdu, mapped from YANG variable /vnfd/kdu (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_kdu is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_kdu() directly.

    YANG Description: List of K8s Deployment Units
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name", yc_kdu_etsi_nfv_vnfd__vnfd_kdu, yang_name="kdu", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """kdu must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_kdu_etsi_nfv_vnfd__vnfd_kdu, yang_name="kdu", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)""",
            })

        self.__kdu = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_kdu(self):
        self.__kdu = YANGDynClass(
            base=YANGListType("name", yc_kdu_etsi_nfv_vnfd__vnfd_kdu, yang_name="kdu", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="kdu", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)

    def _get_k8s_cluster(self):
        """
    Getter method for k8s_cluster, mapped from YANG variable /vnfd/k8s_cluster (container)
    """
        return self.__k8s_cluster

    def _set_k8s_cluster(self, v, load=False):
        """
    Setter method for k8s_cluster, mapped from YANG variable /vnfd/k8s_cluster (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_k8s_cluster is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_k8s_cluster() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_k8s_cluster_etsi_nfv_vnfd__vnfd_k8s_cluster, is_container='container',
                             yang_name="k8s-cluster", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='container',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """k8s_cluster must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_k8s_cluster_etsi_nfv_vnfd__vnfd_k8s_cluster, is_container='container', yang_name="k8s-cluster", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='container', is_config=True)""",
            })

        self.__k8s_cluster = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_k8s_cluster(self):
        self.__k8s_cluster = YANGDynClass(base=yc_k8s_cluster_etsi_nfv_vnfd__vnfd_k8s_cluster, is_container='container',
                                          yang_name="k8s-cluster", parent=self, path_helper=self._path_helper,
                                          extmethods=self._extmethods, register_paths=True, extensions=None,
                                          namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu',
                                          yang_type='container', is_config=True)

    def _get_service(self):
        """
    Getter method for service, mapped from YANG variable /vnfd/service (list)

    YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
    """
        return self.__service

    def _set_service(self, v, load=False):
        """
    Setter method for service, mapped from YANG variable /vnfd/service (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_service is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_service() directly.

    YANG Description: List of Kubernetes services exposed by the KDU.
If empty, all services are assumed to be exposed in the CP associated to the first network
in k8s-cluster.nets.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name", yc_service_etsi_nfv_vnfd__vnfd_service, yang_name="service",
                                                  parent=self, is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="service", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """service must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_service_etsi_nfv_vnfd__vnfd_service, yang_name="service", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="service", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)""",
            })

        self.__service = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_service(self):
        self.__service = YANGDynClass(
            base=YANGListType("name", yc_service_etsi_nfv_vnfd__vnfd_service, yang_name="service", parent=self,
                              is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name',
                              extensions=None), is_container='list', yang_name="service", parent=self,
            path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:kdu', defining_module='kdu', yang_type='list', is_config=True)

    def _get_mgmt_cp(self):
        """
    Getter method for mgmt_cp, mapped from YANG variable /vnfd/mgmt_cp (leafref)

    YANG Description: Connection point over which the VNF is managed.
    """
        return self.__mgmt_cp

    def _set_mgmt_cp(self, v, load=False):
        """
    Setter method for mgmt_cp, mapped from YANG variable /vnfd/mgmt_cp (leafref)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_mgmt_cp is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_mgmt_cp() directly.

    YANG Description: Connection point over which the VNF is managed.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=six.text_type, is_leaf=True, yang_name="mgmt-cp", parent=self,
                             path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                             namespace='urn:etsi:osm:yang:augments:mgmt-interface', defining_module='mgmt-interface',
                             yang_type='leafref', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """mgmt_cp must be of a type compatible with leafref""",
                'defined-type': "leafref",
                'generated-type': """YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-cp", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, namespace='urn:etsi:osm:yang:augments:mgmt-interface', defining_module='mgmt-interface', yang_type='leafref', is_config=True)""",
            })

        self.__mgmt_cp = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_mgmt_cp(self):
        self.__mgmt_cp = YANGDynClass(base=six.text_type, is_leaf=True, yang_name="mgmt-cp", parent=self,
                                      path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True,
                                      namespace='urn:etsi:osm:yang:augments:mgmt-interface',
                                      defining_module='mgmt-interface', yang_type='leafref', is_config=True)

    def _get_vip(self):
        """
    Getter method for vip, mapped from YANG variable /vnfd/vip (list)

    YANG Description: Paired interfaces from different VDUs that share a Virtual IP
    """
        return self.__vip

    def _set_vip(self, v, load=False):
        """
    Setter method for vip, mapped from YANG variable /vnfd/vip (list)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vip is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vip() directly.

    YANG Description: Paired interfaces from different VDUs that share a Virtual IP
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=YANGListType("name", yc_vip_etsi_nfv_vnfd__vnfd_vip, yang_name="vip", parent=self,
                                                  is_container='list', user_ordered=False,
                                                  path_helper=self._path_helper, yang_keys='name', extensions=None),
                             is_container='list', yang_name="vip", parent=self, path_helper=self._path_helper,
                             extmethods=self._extmethods, register_paths=True, extensions=None,
                             namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list',
                             is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vip must be of a type compatible with list""",
                'defined-type': "list",
                'generated-type': """YANGDynClass(base=YANGListType("name",yc_vip_etsi_nfv_vnfd__vnfd_vip, yang_name="vip", parent=self, is_container='list', user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None), is_container='list', yang_name="vip", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)""",
            })

        self.__vip = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vip(self):
        self.__vip = YANGDynClass(
            base=YANGListType("name", yc_vip_etsi_nfv_vnfd__vnfd_vip, yang_name="vip", parent=self, is_container='list',
                              user_ordered=False, path_helper=self._path_helper, yang_keys='name', extensions=None),
            is_container='list', yang_name="vip", parent=self, path_helper=self._path_helper,
            extmethods=self._extmethods, register_paths=True, extensions=None,
            namespace='urn:etsi:osm:yang:augments:vip', defining_module='vip', yang_type='list', is_config=True)

    id = __builtin__.property(_get_id, _set_id)
    provider = __builtin__.property(_get_provider, _set_provider)
    product_name = __builtin__.property(_get_product_name, _set_product_name)
    software_version = __builtin__.property(_get_software_version, _set_software_version)
    version = __builtin__.property(_get_version, _set_version)
    product_info_name = __builtin__.property(_get_product_info_name, _set_product_info_name)
    product_info_description = __builtin__.property(_get_product_info_description, _set_product_info_description)
    vnfm_info = __builtin__.property(_get_vnfm_info, _set_vnfm_info)
    localization_language = __builtin__.property(_get_localization_language, _set_localization_language)
    default_localization_language = __builtin__.property(_get_default_localization_language,
                                                         _set_default_localization_language)
    vdu = __builtin__.property(_get_vdu, _set_vdu)
    virtual_compute_desc = __builtin__.property(_get_virtual_compute_desc, _set_virtual_compute_desc)
    virtual_storage_desc = __builtin__.property(_get_virtual_storage_desc, _set_virtual_storage_desc)
    sw_image_desc = __builtin__.property(_get_sw_image_desc, _set_sw_image_desc)
    int_virtual_link_desc = __builtin__.property(_get_int_virtual_link_desc, _set_int_virtual_link_desc)
    security_group_rule = __builtin__.property(_get_security_group_rule, _set_security_group_rule)
    ext_cpd = __builtin__.property(_get_ext_cpd, _set_ext_cpd)
    df = __builtin__.property(_get_df, _set_df)
    configurable_properties = __builtin__.property(_get_configurable_properties, _set_configurable_properties)
    modifiable_attributes = __builtin__.property(_get_modifiable_attributes, _set_modifiable_attributes)
    lifecycle_management_script = __builtin__.property(_get_lifecycle_management_script,
                                                       _set_lifecycle_management_script)
    element_group = __builtin__.property(_get_element_group, _set_element_group)
    indicator = __builtin__.property(_get_indicator, _set_indicator)
    auto_scale = __builtin__.property(_get_auto_scale, _set_auto_scale)
    description = __builtin__.property(_get_description, _set_description)
    kdu = __builtin__.property(_get_kdu, _set_kdu)
    k8s_cluster = __builtin__.property(_get_k8s_cluster, _set_k8s_cluster)
    service = __builtin__.property(_get_service, _set_service)
    mgmt_cp = __builtin__.property(_get_mgmt_cp, _set_mgmt_cp)
    vip = __builtin__.property(_get_vip, _set_vip)

    _pyangbind_elements = OrderedDict(
        [('id', id), ('provider', provider), ('product_name', product_name), ('software_version', software_version),
         ('version', version), ('product_info_name', product_info_name),
         ('product_info_description', product_info_description), ('vnfm_info', vnfm_info),
         ('localization_language', localization_language),
         ('default_localization_language', default_localization_language), ('vdu', vdu),
         ('virtual_compute_desc', virtual_compute_desc), ('virtual_storage_desc', virtual_storage_desc),
         ('sw_image_desc', sw_image_desc), ('int_virtual_link_desc', int_virtual_link_desc),
         ('security_group_rule', security_group_rule), ('ext_cpd', ext_cpd), ('df', df),
         ('configurable_properties', configurable_properties), ('modifiable_attributes', modifiable_attributes),
         ('lifecycle_management_script', lifecycle_management_script), ('element_group', element_group),
         ('indicator', indicator), ('auto_scale', auto_scale), ('description', description), ('kdu', kdu),
         ('k8s_cluster', k8s_cluster), ('service', service), ('mgmt_cp', mgmt_cp), ('vip', vip), ])


class etsi_nfv_vnfd(PybindBase):
    """
  This class was auto-generated by the PythonClass plugin for PYANG
  from YANG module etsi-nfv-vnfd - based on the path /etsi-nfv-vnfd. Each member element of
  the container is represented as a class variable - with a specific
  YANG type.

  YANG Description: Virtual Network Function Descriptor.
  """
    __slots__ = ('_path_helper', '_extmethods', '__vnfd',)

    _yang_name = 'etsi-nfv-vnfd'

    _pybind_generated_by = 'container'

    def __init__(self, *args, **kwargs):

        self._path_helper = False

        self._extmethods = False
        self.__vnfd = YANGDynClass(base=yc_vnfd_etsi_nfv_vnfd__vnfd, is_container='container', yang_name="vnfd",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

        load = kwargs.pop("load", None)
        if args:
            if len(args) > 1:
                raise TypeError("cannot create a YANG container with >1 argument")
            all_attr = True
            for e in self._pyangbind_elements:
                if not hasattr(args[0], e):
                    all_attr = False
                    break
            if not all_attr:
                raise ValueError("Supplied object did not have the correct attributes")
            for e in self._pyangbind_elements:
                nobj = getattr(args[0], e)
                if nobj._changed() is False:
                    continue
                setmethod = getattr(self, "_set_%s" % e)
                if load is None:
                    setmethod(getattr(args[0], e))
                else:
                    setmethod(getattr(args[0], e), load=load)

    def _path(self):
        if hasattr(self, "_parent"):
            return self._parent._path() + [self._yang_name]
        else:
            return []

    def _get_vnfd(self):
        """
    Getter method for vnfd, mapped from YANG variable /vnfd (container)
    """
        return self.__vnfd

    def _set_vnfd(self, v, load=False):
        """
    Setter method for vnfd, mapped from YANG variable /vnfd (container)
    If this variable is read-only (config: false) in the
    source YANG file, then _set_vnfd is considered as a private
    method. Backends looking to populate this variable should
    do so via calling thisObj._set_vnfd() directly.
    """
        if hasattr(v, "_utype"):
            v = v._utype(v)
        try:
            t = YANGDynClass(v, base=yc_vnfd_etsi_nfv_vnfd__vnfd, is_container='container', yang_name="vnfd",
                             parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                             register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                             defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)
        except (TypeError, ValueError):
            raise ValueError({
                'error-string': """vnfd must be of a type compatible with container""",
                'defined-type': "container",
                'generated-type': """YANGDynClass(base=yc_vnfd_etsi_nfv_vnfd__vnfd, is_container='container', yang_name="vnfd", parent=self, path_helper=self._path_helper, extmethods=self._extmethods, register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd', defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)""",
            })

        self.__vnfd = t
        if hasattr(self, '_set'):
            self._set()

    def _unset_vnfd(self):
        self.__vnfd = YANGDynClass(base=yc_vnfd_etsi_nfv_vnfd__vnfd, is_container='container', yang_name="vnfd",
                                   parent=self, path_helper=self._path_helper, extmethods=self._extmethods,
                                   register_paths=True, extensions=None, namespace='urn:etsi:nfv:yang:etsi-nfv-vnfd',
                                   defining_module='etsi-nfv-vnfd', yang_type='container', is_config=True)

    vnfd = __builtin__.property(_get_vnfd, _set_vnfd)

    _pyangbind_elements = OrderedDict([('vnfd', vnfd), ])
